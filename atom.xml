<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://blog.dselegent.icu/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://blog.dselegent.icu/</id>
  <title>dselegent-blog</title>
  <subtitle>开源工具、效率方法的自我提升笔记，记录并输出一切能让自己提升的知识。</subtitle>
  <author>
    <name>dselegent</name>
    <uri>https://blog.dselegent.icu</uri>
  </author>
  <logo>https://blog.dselegent.icu/logo.png</logo>
  <rights>Copyright by dselegent</rights>
  <updated>2023-04-11T09:37:42.419Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://blog.dselegent.icu/atom.xml"/>
  <link rel="alternate" href="https://blog.dselegent.icu/"/>
  <contributor>
    <name>dselegent</name>
    <uri>https://blog.dselegent.icu</uri>
  </contributor>
  <entry>
    <title type="text">01 【软件工程学概述】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/01.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/01.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 01 【软件工程学概述】</h1>
<p>迄今为止，计算机系统已经经历了4个不同的发展阶段，但是，人们仍然没有彻底摆脱“软件危机”的困扰，软件已经成为限制计算机系统发展的瓶颈。</p>
<p>为了更有效地开发与维护软件，软件工作者在20世纪60年代后期开始认真研究消除软件危机的途径，从而逐渐形成了一门新兴的工程学科——计算机软件工程学。</p>
<h2> 1.软件危机</h2>
<h3> 1.1 软件危机的介绍</h3>
<p>在计算机软件的开发和维护过程中所遇到的一系列严重问题。</p>
<p><strong>软件危机的典型表现</strong></p>
<ul>
<li>对软件开发成本和进度的估算很不准确</li>
<li>难以准确获取用户需求，用户不满意</li>
<li>质量很不可靠，没有适当的文档</li>
<li>缺乏方法指导和工具支持，大型软件系统经常失败</li>
<li>供不应求：软件开发生产率跟不上计算机应用的迅速发展</li>
<li>做好软件定义时期的工作，是降低软件成本提高软件质量的关键。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h1> 01 【软件工程学概述】</h1>
<p>迄今为止，计算机系统已经经历了4个不同的发展阶段，但是，人们仍然没有彻底摆脱“软件危机”的困扰，软件已经成为限制计算机系统发展的瓶颈。</p>
<p>为了更有效地开发与维护软件，软件工作者在20世纪60年代后期开始认真研究消除软件危机的途径，从而逐渐形成了一门新兴的工程学科——计算机软件工程学。</p>
<h2> 1.软件危机</h2>
<h3> 1.1 软件危机的介绍</h3>
<p>在计算机软件的开发和维护过程中所遇到的一系列严重问题。</p>
<p><strong>软件危机的典型表现</strong></p>
<ul>
<li>对软件开发成本和进度的估算很不准确</li>
<li>难以准确获取用户需求，用户不满意</li>
<li>质量很不可靠，没有适当的文档</li>
<li>缺乏方法指导和工具支持，大型软件系统经常失败</li>
<li>供不应求：软件开发生产率跟不上计算机应用的迅速发展</li>
<li>做好软件定义时期的工作，是降低软件成本提高软件质量的关键。</li>
</ul>
<h3> 1.2 产生软件危机的原因</h3>
<p><strong>与软件本身特点有关</strong></p>
<ul>
<li>软件不同于硬件，管理和控制软件开发过程相当困难。</li>
<li>软件在运行过程中不会因为使用时间过长而被 “用坏 “如果运行中发现了错误,很可能是遇到了一个在开发时期引入的在测试阶段没能检测出来的错误。</li>
<li>软件不同于一般程序 ，它的一个显著特点是规模庞大 ，而且程序复杂性将随着程序规模的增加而呈指数上升。</li>
<li>事实上，对用户要求没有完整准确的认识就匆忙着手编写程序是许多软件开发工程失败的主要原因之一。</li>
<li>目前相当多的软件专业人员对软件开发和维护还有不少糊涂观念 。在实践过程中或多或少地采用了错误的方法和技术，这可能是使软件问题发展成软件危机的主要原因。</li>
<li>错误的认识和做法主要表现为忽视软件需求分析的重要性，认为软件开发就是写程序并设法使之运行,轻视软件维护等</li>
</ul>
<p><strong>软件开发与维护的方法不正确有关</strong></p>
<ul>
<li>只重视程序而忽视软件配置其余成分的糊涂观念。</li>
<li>软件开发人员在定义时期没有正确全面地理解用户需求，直到测试阶段或软件交付使用后才发现 “已完成的 ”软件不完全符合用户的需要。</li>
<li>严重的问题是在软件开发的不同阶段进行修改需要付出的代价是很不相同的，如下图所示。</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/9a0798f5f83bd1d446cc378f815b3ea41fe8a3c1.png" alt="image-20230124173056597" style="zoom: 33%;">
<h3> 1.3 消除软件危机的途径</h3>
<ul>
<li>首先应该对计算机软件有一个正确的认识。</li>
<li>充分认识到软件开发不是某种个体劳动的神秘技巧 ，而应该是各类人员协同配合，共同完成的工程项目。</li>
<li>推广使用在实践中总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法。</li>
<li>应该开发和使用更好的软件工具。</li>
</ul>
<h2> 2.软件工程</h2>
<h3> 2.1 软件工程的介绍</h3>
<p><strong>软件工程概述</strong></p>
<p>软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p>
<p>1968年在第一届NATO会议上曾经给出了软件工程的一个早期定义：“软件工程就是为了经济地获得可靠的且能在实际机器上有效地运行的软件，而建立和使用完善的工程原理。”</p>
<p>1993年IEEE进一步给出了一个更全面更具体的定义：“软件工程是： ①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件； ②研究①中提到的途径。</p>
<p><strong>软件具有的本质特性</strong></p>
<img src="https://i0.hdslb.com/bfs/album/11251bffbb2960e31a06a9c80a0a0abca9d3f72a.png" alt="image-20230124174920751" style="zoom:67%;">
<h3> 2.2 软件工程的基本原理</h3>
<img src="https://i0.hdslb.com/bfs/album/0ee13ee436cf5c39b23b791a7bccb217851ae255.png" alt="image-20230124174945098" style="zoom:67%;">
<h3> 2.3 软件工程的原则</h3>
<ol>
<li>抽象</li>
</ol>
<p>抽取事物最基本的特性和行为，忽略非基本的细节。采用分层次抽象、自顶向下、逐层分解的办法控制软件开发过程的复杂性。例如：软件瀑布模型、结构化分析方法、结构化设计方法，以及面向对象建模技术等都体现了抽象的原则。</p>
<ol start="2">
<li>信息隐蔽</li>
</ol>
<p>将模块设计成“黑箱”，实现的细节隐藏在模块内部，不让模块的使用者直接访问。</p>
<ol start="3">
<li>模块化</li>
</ol>
<p>模块是程序在逻辑上相对独立的成分，是独立的编程单位，应有良好的接口定义。模块化有助于信息隐蔽和抽象，有助于表示复杂的系统。</p>
<ol start="4">
<li>局部化</li>
</ol>
<p>要求在一个物理模块内集中逻辑上相互关联的计算机资源，保证 模块之间具有松散的耦合，模块内部具有较强的内聚。这有助于加强模块的独立性，控制解的复杂性。</p>
<ol start="5">
<li>确定性</li>
</ol>
<p>软件开发过程中所有概念的表达应该是确定的、无歧义的、规范的。这有助于人们之间在交流时不会产生误解、遗漏，保证整个开发工作协调一致。</p>
<ol start="6">
<li>一致性</li>
</ol>
<p>整个软件系统（包括程序、文档和数据）的各个模块应使用一致的概念、符号和术语。程序内部接口应保持一致。软件和硬件、操作系统的接口应保持一致。系统规格说明与系统行为应保持一致。用于形式化规格说明的公理系统应保持一致。</p>
<ol start="7">
<li>完备性</li>
</ol>
<p>软件系统不丢失任何重要成分，可以完全实现系统所要求功能的程度。为了保证系统的完备性，在软件开发和运行过程中需要严格的技术评审。</p>
<ol start="8">
<li>可验证性</li>
</ol>
<p>开发大型的软件系统需要对系统自顶向下、逐层分解。系统分解应遵循系统已于检查、测试、评审的原则，以确保系统的正确性。</p>
<h3> 2.4 软件工程的本质特征</h3>
<ul>
<li>软件工程关注大型程序的构造</li>
<li>软件工程的中心课题是控制复杂性</li>
<li>软件经常变化</li>
<li>开发软件的效率非常重要</li>
<li>和谐地合作是开发软件的关键</li>
<li>软件必须有效地支持它的用户</li>
<li>在软件工程领域中是由具有一种文化背景的人替具有另一种文化背景的人</li>
</ul>
<h3> 2.6 软件工程的基本原理</h3>
<ol>
<li>用分阶段的生命周期计划严格管理</li>
</ol>
<p>把软件生命周期划分为若干个阶段，并相应地制定出切实可行的计划，然后严格按照计划对软件的开发和维护工作进行管理。</p>
<ol start="2">
<li>坚持进行阶段评审</li>
</ol>
<p>软件的质量保证工作不能等到编码阶段结束之后再进行。错误发现与改正越晚，所需付出的代价也越高。因此，在每个阶段都进行严格的评审，以便尽早发现在软件开发过程中所犯的错误，是一条必须遵循的重要原则。</p>
<ol start="3">
<li>
<p>实行严格的产品控制</p>
</li>
<li>
<p>采用现代程序设计技术</p>
</li>
</ol>
<p>采用先进的技术不仅可以提高软件开发和维护的效率，而且可以提高软件产品的质量。</p>
<ol start="5">
<li>结果应能清楚地审查</li>
</ol>
<p>应该根据软件开发项目的总目标及完成期限，规定开发组织的责任和产品标准，从而使得所得到的结果能够清楚地审查。</p>
<ol start="6">
<li>开发小组的人员应该少而精</li>
</ol>
<h3> 2.7 软件工程方法学</h3>
<img src="https://i0.hdslb.com/bfs/album/8cb10d9365893237454b1eb56555a0e1950f2ac5.png" alt="image-20230124175422473" style="zoom: 50%;">
<ul>
<li>
<p>传统方法学</p>
<ul>
<li>**概念：**传统方法学也称为生命周期方法学或结构化范型。它采用结构化技术(结构化分析、结构化设计和结构化实现)来完成软件开发的各项任务，并使用适当的软件工具或软件工程环境来支持结构化技术的运用。</li>
<li><strong>特点</strong>：
<ul>
<li>传统方法学把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。</li>
<li>每个阶段的开始和结束都有严格标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段的开始标准。</li>
<li>在每一个阶段结束之前都必须进行正式严格的技术审查和管理复审。</li>
<li>审查的一条主要标准就是每个阶段都应该交出“最新式的”(即和所开发的软件完全一致的)高质量的文档资料，从而保证在软件开发工程结束时有一个完整准确的软件配置交付使用。</li>
<li>采用生命周期方法学可以大大提高软件开发的成功率，软件开发的生产率也能明显提高。</li>
<li>目前，传统方法学仍然是人们在开发软件时使用得十分广泛的软件工程方法学。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>面向对象方法学</p>
<ul>
<li>
<p>**概念：**与传统方法相反，面向对象方法把数据和行为看成是同等重要的，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。</p>
</li>
<li>
<p><strong>四个要点</strong></p>
<ul>
<li>把对象(object)作为融合了数据及在数据上的操作行为的统一的软件构件。</li>
<li>把所有对象都划分成类(class)。</li>
<li>按照父类与子类的关系，把若干个相关类组成一个层次结构的系统。</li>
<li>对象彼此间仅能通过发送消息互相联系。</li>
</ul>
</li>
<li>
<p>**基本原则：**尽量模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界、解决问题的方法与过程，从而使描述问题的问题空间(也称为问题域)与实现解法的解空间(也称为求解域)在结构上尽可能一致。</p>
</li>
<li>
<p>**优点：**降低了软件产品的复杂性，提高了软件的可理解性，简化了软件的开发和维护工作。</p>
<p>面向对象方法特有的继承性和多态性，进一步提高了面向对象软件的可重用性。</p>
</li>
</ul>
</li>
</ul>
<h2> 3.软件生命周期</h2>
<p>软件生命周期由软件定义、软件开发和运行维护(也称为软件维护)3个时期组成，每个时期又进一步划分成若干个阶段。</p>
<p>软件定义时期的任务是： 确定软件开发工程必须完成的总目标；确定工程的可行性；导出实现工程目标应该采用的策略及系统必须完成的功能；估计完成该项工程需要的资源和成本，并且制定工程进度表。这个时期的工作通常又称为系统分析，由系统分析员负责完成。</p>
<p>软件定义时期通常进一步划分成3个阶段，即问题定义、可行性研究和需求分析。开发时期具体设计和实现在前一个时期定义的软件，它通常由下述4个阶段组成：总体设计，详细设计，编码和单元测试，综合测试。其中前两个阶段又称为系统设计，后两个阶段又称为系统实现。维护时期的主要任务是使软件持久地满足用户的需要。</p>
<ol>
<li>问题定义</li>
</ol>
<p>问题定义阶段必须回答的关键问题是：“要解决的问题是什么？”</p>
<p>通过对客户的访问调查，系统分析员扼要地写出关于问题性质、工程目标和工程规模的书面报告，经过讨论和必要的修改之后这份报告应该得到客户的确认。</p>
<ol start="2">
<li>可行性研究</li>
</ol>
<p>这个阶段回答的关键问题是：“对于上一个阶段所确定的问题有行得通的解决方法吗？”</p>
<p>技术上、经济上、操作上、时间上、法律上</p>
<ol start="3">
<li>需求分析（功能分析）</li>
</ol>
<p>这个阶段的任务仍然不是具体解决问题，而是确定“为了解决这个问题，目标系统必须做什么？”，主要是确定目标系统必须具备哪些功能。</p>
<p>系统分析员必须和用户密切配合，充分交流信息，以得出经过用户确认的系统逻辑模型。通常用数据流图（DFD）、数据字典（DD）和简要的算法表示。</p>
<p>在需求分析阶段确定的系统逻辑模型是以后设计和实现系统的基础。这个阶段的一项重要任务是用正式文档准确地记录对目标系统的需求，这份文档通常称为 规格说明书（specification）。（SRS）</p>
<ol start="4">
<li>总体设计</li>
</ol>
<p>这个阶段必须回答的关键问题是：“怎样实现目标系统？”</p>
<p>成果：系统结构图（SC）</p>
<p>一个程序应该由若干个规模适中的模块按合理的层次结构组织而成。总体设计的另一项主要任务是设计程序的体系结构，也就是确定程序由哪些模块组成以及模块间的关系。</p>
<ol start="5">
<li>详细设计</li>
</ol>
<p>这个阶段的任务就是把解法具体化，也就是回答这个关键问题：“应该怎样具体地实现这个系统呢？”</p>
<p>这个阶段的任务还不是编写程序，而是设计出程序的详细规格说明。这种规格说明应该包含必要的细节，程序员可以根据它们写出实际的程序代码。</p>
<p>详细设计也称为模块设计，在这个阶段将详细地设计每个模块，确定实现模块功能所需要的算法和数据结构。</p>
<ol start="6">
<li>编码和单元测试</li>
</ol>
<p>这个阶段的关键任务是写出正确的、容易理解、容易维护的程序模块。</p>
<p>程序员应该根据目标系统的性质和实质环境，选择一种适当的高级程序设计语言，把详细设计的结果翻译成用选定的语言书写的程序，并且仔细测试编写出的每一个模块。</p>
<ol start="7">
<li>综合测试</li>
</ol>
<p>这个阶段的关键任务是通过各种类型的测试使软件达到预定的要求。</p>
<p>最基本的测试是集成测试和验收测试。</p>
<p>集成测试是根据设计的软件结构，把经过单元测试检验的模块按某种选定的策略装配起来，在装配过程中对程序进行必要的测试。</p>
<p>验收测试是按照规格说明书的规定，由用户对目标系统进行验收。</p>
<p>必要时还可以再通过现场测试或平行运行等方法对目标系统进一步测试检验。</p>
<ol start="8">
<li>软件维护</li>
</ol>
<p>这个阶段的关键任务是，通过各种必要的维护活动使系统持久地满足用户的需要。</p>
<p>改正性维护，也就是诊断和改正在使用过程中出现的软件错误； 适应性维护，即修改软件以适应环境的变化 完善性维护，即根据用户的要求改进或扩充软件使它更完善； 预防性维护，即修改软件为将来的维护活动预先做准备。</p>
<h2> 4.软件过程</h2>
<p>软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。</p>
<p>软件过程描述为了开发出客户需要的软件，什么人（who）、在什么时候（when）、做什么事（what）以及怎样（how）做这些事以实现某一个特定的具体目标。</p>
<h3> 4.1 瀑布模型</h3>
<p>瀑布模型一直是唯一被广泛采用的生命周期模型，现在它仍然是软件工程中应用得最广泛的过程模型。如下图所示为传统的瀑布模型</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d48273e5bdaef8b94afe64c6968fc6d1d835e006.png" alt="image-20230124180734730" tabindex="0" loading="lazy"><figcaption>image-20230124180734730</figcaption></figure>
<p>按照传统的瀑布模型开发软件，有下述的几个特点。</p>
<ul>
<li>
<p>阶段间具有顺序性和依赖性：</p>
<p>两重含义： ①必须等前一阶段的工作完成之后，才能开始后一阶段的工作； ②前一阶段的输出文档就是后一阶段的输入文档，因此，只有前一阶段的输出文档正确，后一阶段的工作才能获得正确的结果。</p>
</li>
<li>
<p>推迟实现的观点：</p>
<p>瀑布模型在编码之前设置了系统分析与系统设计的各个阶段，分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的物理实现。</p>
</li>
<li>
<p>质量保证的观点：</p>
<p>软件工程的基本目标是优质、高产。为了保证所开发的软件的质量，在瀑布模型的每个阶段都应坚持两个重要做法。</p>
<ol>
<li>
<p>每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。</p>
</li>
<li>
<p>每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误。</p>
</li>
</ol>
</li>
</ul>
<p>传统的瀑布模型过于理想化了，事实上，人在工作过程中不可能不犯错误。实际的瀑布模型是带“反馈环”的，如系统图所示。</p>
<img src="https://i0.hdslb.com/bfs/album/8f2f43fffe779be86b72f6b3f6d4c2520a00d6e2.png" alt="image-20230124180838938" style="zoom: 67%;">
<p><strong>瀑布模型有许多优点：</strong></p>
<ol>
<li>可强迫开发人员采用规范的方法（例如，结构化技术）；</li>
<li>严格地规定了每个阶段必须提交的文档；</li>
<li>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。</li>
</ol>
<h3> 4.2 快速原型模型</h3>
<p>快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。</p>
<p>快速原型模型适用于中小型软件，且需求模糊的用户。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/8183debd4087a32475a9c27db146bb8ce165d391.png" alt="image-20230124181237898" tabindex="0" loading="lazy"><figcaption>image-20230124181237898</figcaption></figure>
<p>快速原型模型是不带反馈环的，这正是这种过程模型的主要优点： 软件产品的开发基本上是线性顺序进行的。能基本上做到线性顺序开发的主要原因如下：</p>
<p>（1） 原型系统已经通过与用户交互而得到验证，据此产生的规格说明文档正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现了规格说明文档的错误而进行较大的返工。</p>
<p>（2） 开发人员通过建立原型系统已经学到了许多东西，因此，在设计和编码阶段发生错误的可能性也比较小，这自然减少了在后续阶段需要改正前面阶段所犯错误的可能性。</p>
<p><strong>快速原型模型的特点</strong>：</p>
<ul>
<li>快速开发工具</li>
<li>循环</li>
<li>低成本</li>
</ul>
<p><strong>种类</strong>：</p>
<ul>
<li>渐进型</li>
<li>抛弃型</li>
</ul>
<h3> 4.3 增量模型</h3>
<p>增量模型也称为渐增模型。使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能。使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。</p>
<img src="https://i0.hdslb.com/bfs/album/b09288f2e9ef762f2190bb16136a2ae896262104.png" alt="image-20230124182358289" style="zoom:67%;">
<p><strong>优点：</strong></p>
<ul>
<li>能在较短时间内向用户提交可完成部分工作的产品。</li>
<li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li>
</ul>
<p><strong>使用增量模型的困难：</strong></p>
<ul>
<li>在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。</li>
<li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品，从而减少一个全新的软件可能给客户组织带来的冲击。</li>
<li>在把每个新的增量构件集成到现有软件体系结构中时，必须不破坏原来已经开发出的产品。</li>
<li>必须把软件的体系结构设计得便于按这种方式进行扩充，向现有产品中加入新构件的过程必须简单、方便，也就是说，软件体系结构必须是开放的。</li>
</ul>
<h3> 4.4 螺旋模型</h3>
<p>螺旋模型是风险驱动的。</p>
<p>螺旋模型的基本思想是，使用原型及其他方法来尽量降低风险。理解这种模型的一个简便方法，是把它看作在每个阶段之前都增加了风险分析过程的快速原型模型。</p>
<img src="https://i0.hdslb.com/bfs/album/93eb2b033d60c69c3be631a7a449b8acc8a34e6f.png" alt="image-20230124182824638" style="zoom:67%;">
<p><strong>螺旋模型的特点</strong>：</p>
<ul>
<li>瀑布模型+快速原型+风险分析</li>
<li>迭代过程</li>
</ul>
<p><strong>一个螺旋式周期</strong>：</p>
<p>确定目标、选择方案、选定完成目标的策略 风险角度分析该策略 启动一个开发阶段 评价前一步的结果，计划下一轮的工作</p>
<h3> 4.5 喷泉模型</h3>
<p>“喷泉”这个词体现了面向对象软件开发过程迭代和无缝的特性。迭代是软件开发过程中普遍存在的一种内在属性。用面向对象方法学开发软件时，工作重点应该放在生命周期中的分析阶段。</p>
<img src="https://i0.hdslb.com/bfs/album/f57b4766bba1a833dc8402ceefd2bdbb906cc35e.png" alt="image-20230124182909042" style="zoom:67%;">
<h2> 5.本章小结</h2>
<ol>
<li>
<p>本章对计算机软件工程学作一个简短的概述，回顾计算机系统发展简史。</p>
</li>
<li>
<p>本章介绍 软件工程的基本原理和方法有概括的本质的认识，详细讲解生命周期相关知识。</p>
</li>
<li>
<p>详细讲解8种典型的软件过程模型。</p>
</li>
</ol>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">02 【可行性研究】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/02.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/02.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 02 【可行性研究】</h1>
<h2> 1.可行性研究的任务</h2>
<h3> 1.1 目的和任务</h3>
<blockquote>
<p>可行性研究的目的不是解决问题，而是<strong>确定问题是否值得去解决。</strong></p>
<p>可行性研究最根本的任务是对以后的行动方针提出建议。</p>
</blockquote>
<h3> 1.2 本质</h3>
<p>可行性研究的本质是要进行一次大大压缩简化了的系统分析和设计的过程，也就是在较高层次上以较抽象的方式进行的系统分析和设计的过程。</p>
<h3> 1.3 步骤</h3>
<ul>
<li>首先需要进一步分析和澄清问题定义</li>
<li>在澄清了问题定义之后，分析员应该导出系统的逻辑模型。</li>
<li>再从逻辑模型出发，探索若干种可供选择的主要解法（即系统实现方案）。对每种解法都应该仔细研究它的可行性，一般说来，至少应该从下述三个方面研究每种解法的可行性：
<ul>
<li>技术可行性：使用现有的技术能够实现这个系统</li>
<li>经济可行性：这个系统的经济效益能超过它的开发成本？</li>
<li>操作可行性：系统的操作方式在这个用户组织内行得通吗</li>
<li>必要时还应该从法律、社会效益等更广泛的方面研究每种解法的可行性。</li>
</ul>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h1> 02 【可行性研究】</h1>
<h2> 1.可行性研究的任务</h2>
<h3> 1.1 目的和任务</h3>
<blockquote>
<p>可行性研究的目的不是解决问题，而是<strong>确定问题是否值得去解决。</strong></p>
<p>可行性研究最根本的任务是对以后的行动方针提出建议。</p>
</blockquote>
<h3> 1.2 本质</h3>
<p>可行性研究的本质是要进行一次大大压缩简化了的系统分析和设计的过程，也就是在较高层次上以较抽象的方式进行的系统分析和设计的过程。</p>
<h3> 1.3 步骤</h3>
<ul>
<li>首先需要进一步分析和澄清问题定义</li>
<li>在澄清了问题定义之后，分析员应该导出系统的逻辑模型。</li>
<li>再从逻辑模型出发，探索若干种可供选择的主要解法（即系统实现方案）。对每种解法都应该仔细研究它的可行性，一般说来，至少应该从下述三个方面研究每种解法的可行性：
<ul>
<li>技术可行性：使用现有的技术能够实现这个系统</li>
<li>经济可行性：这个系统的经济效益能超过它的开发成本？</li>
<li>操作可行性：系统的操作方式在这个用户组织内行得通吗</li>
<li>必要时还应该从法律、社会效益等更广泛的方面研究每种解法的可行性。</li>
</ul>
</li>
</ul>
<h3> 1.4 投入时间</h3>
<p>可行性研究需要的时间长短取决于工程的规模。一般来说，可行性研究的成本只是预期的工程总成本的5%~10%。</p>
<h2> 2.可行性研究过程</h2>
<p>典型的可行性研究过程有下述一些步骤：</p>
<h3> 2.1 复查系统规模和目标</h3>
<p>分析员对问题定义阶段书写的关于规模和目标的报告书进一步复查确认，改正含糊或不确切的叙述，清晰地描述对目标系统的一切限制和约束</p>
<h3> 2.2 研究目前正在使用的系统</h3>
<p>现有的系统是信息的重要来源，新的目标系统必须也能完成它的基本功能 现有的系统必然有某些缺点，新系统必须能解决旧系统中存在的问题 运行使用旧系统所需要的费用是一个重要的经济指标，如果新系统不能增加收入或减少使用费用，那么从经济角度看新系统就不如旧系统。</p>
<h3> 2.3 导出新系统的高层逻辑模型</h3>
<p>优秀的设计过程通常总是从现有的物理系统出发，导出现有系统的逻辑模型，再参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理系统。</p>
<p>通过前一步的工作，分析员能够使用数据流图，描绘数据在系统中流动和处理的情况，从而概括的表达出对新系统的设想。为了把系统描绘的更清洗准确，还应该有一个初步的数据字典，定义系统中使用的数据。</p>
<h3> 2.4 进一步定义问题</h3>
<p>新系统的逻辑模型实质上表达了分析员对新系统必须做什么的看法。分析员应该和用户一起再次复查问题定义、工程规模和目标，这次复查应该把数据流图和数据字典作为讨论的基础</p>
<p>前4个步骤构成一个循环，直到提出的逻辑模型完全符合系统目标。</p>
<h3> 2.5 导出和评价供选择的解法</h3>
<p>分析员应该从他建议的系统逻辑模型出发，导出若干个较高层次的物理解法供比较和选择。</p>
<p>导出供选择的解法的最简单的途径，是从技术角度出发考虑解决问题的不同方案。</p>
<p>首先，根据技术可行性的考虑初步排除一些不现实的系统方案 其次，考虑操作方面的可行性。分析员应该根据使用部门处理事务的原则和习惯检查技术上可行的哪些方案。 最后考虑经济方面的可行性。分析员应该估计余下的每个可能的系统的开发成本和运行费用，并且估计相对于现有的系统而言这个系统可以节省的开支或可以增加的收入。</p>
<h3> 2.6 推荐行动方针</h3>
<p>根据可行性研究结果应该做出的一个关键性决定是，是否继续进行这项开发工程 如果分析员认为值得继续进行这项开发工程，那么他应该选择一种最好的解法，并且说明选择这个解决方案的理由 通常使用部门的负责人主要根据经济上是否划算决定是否投资于一项开发工程，因此分析员对于所推荐的系统必须进行比较仔细的成本/效益分析。</p>
<h3> 2.7 草拟开发计划</h3>
<p>分析员应该为所推荐的方案草拟一份开发计划，除了制定工程进度表之外还应该估计对各类开发人员和各种资源的需要情况，应该指明什么时候使用以及使用多长时间。</p>
<p>此外，还应该估计系统生命周期每个阶段的成本。</p>
<p>最后，应该给出下一个阶段（需求分析）的详细进度表和成本估计。</p>
<h3> 2.8 书写文档提交审查</h3>
<p>应该把上述可行性研究各个步骤的工作结果写成清晰的文档，请用户、客户组织的负责人及评审组审查，以决定是否继续这项工程及是否接受分析员推荐的方案。</p>
<h2> 3.系统流程图</h2>
<blockquote>
<p>系统流程图是概括地描绘物理系统的传统工具。它的基本思想是用图形符号以黑盒子形式描绘组成系统的每个组件（程序、文档、数据库、人工过程等）</p>
<p>系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程，因此尽管系统流程图的某些符号和程序流程图的符号形式相同，但是它却是物理数据流图而不是程序流程图。</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/c77580d1c7699be67bee618f50e573fa30f3976c.png" alt="image-20230125232134632" tabindex="0" loading="lazy"><figcaption>image-20230125232134632</figcaption></figure>
<h2> 4.数据流图 DFD</h2>
<h3> 4.1 概念</h3>
<p>数据流图是一种图形化技术，它描绘信息流和数据从输入移动到输出的过程中所经受的变换（加工、处理）。</p>
<blockquote>
<p><strong>它是以图示的方式来表示软件模型</strong></p>
</blockquote>
<ul>
<li>在数据流图中没有任何具体的物理部件，它只是描绘数据在软件中流动和被处理的逻辑过程。</li>
<li>数据流图是系统逻辑功能的图形表示，即使不是专业的计算机技术人员也容易理解它，因此是分析员与用户之间极好的通信工具</li>
<li>设计数据流程图时只需考虑系统必须完成的基本逻辑功能，完全不需要考虑怎样具体地实现这些功能。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/44dd497329d1bce30fb5a00529238d99fe6288e0.png" alt="image-20230125232428889" tabindex="0" loading="lazy"><figcaption>image-20230125232428889</figcaption></figure>
<h3> 4.2 符号</h3>
<p>四种基本符号：</p>
<ul>
<li>正方形或立方体表示数据的源点或终点</li>
<li>圆角矩形或圆形代表变换数据的处理</li>
<li>开口矩形或两条平行横线代表数据存储</li>
<li>箭头表示数据流，即特定数据的流动方向</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/3c8574d5213656d828748ac4e743dc1e3d227473.png" alt="image-20230125232503486" tabindex="0" loading="lazy"><figcaption>image-20230125232503486</figcaption></figure>
<h3> 4.3 例子</h3>
<p>假设一家工厂的采购部每天需要一张订货报表，报表按零件编号排序，表中列出所有需要再次订货的零件。对于每个需要再次订货的零件应该列出下述数据：零件编号，零件名称，订货数量，目前价格，主要供应者，次要供应者。零件入库或出库称为事务，通过放在仓库中的CRT终端把事务报告给订货系统。当某种零件的库存数量少于库存量临界值时就应该再次订货。</p>
<p>第一步可以从问题描述中提取数据流图的4种成分：</p>
<blockquote>
<p>首先考虑数据的源点和终点，从上面对系统的描述可以知道“采购部每天需要一张订货报表”，“通过放在仓库中的CRT终端把事务报告给订货系统”，所以采购员是数据终点，而仓库管理员是数据源点。</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/942ad121235fca879ed3dfb846dd2cf27832ea5e.png" alt="image-20230125232722928" tabindex="0" loading="lazy"><figcaption>image-20230125232722928</figcaption></figure>
<p>第二步：再一次阅读问题描述，“采购部需要报表”</p>
<blockquote>
<p>因此必须有一个用于产生报表的处理。事务的后果是改变零件库存量，然而任何改变数据的操作都是处理，因此对事务进行的加工是另一个处理。注意，在问题描述中并没有明显地提到需要对事务进行处理，但是通过分析可以看出这种需要。</p>
</blockquote>
<p>把数据流图的4种成分都分离出来以后，就可以着手画数据流图了</p>
<figure><img src="https://i0.hdslb.com/bfs/album/f5c660666f149f24e0b5481619234aa2e8c81f5f.png" alt="image-20230125232927713" tabindex="0" loading="lazy"><figcaption>image-20230125232927713</figcaption></figure>
<p>第三步：考虑数据流和数据存储</p>
<blockquote>
<p>系统把订货报表送给采购部，因此订货报表是一个数据流；事务需要从仓库送到系统中，显然事务是另一个数据流。产生报表和处理事务这两个处理在时间上明显不匹配——每当有一个事务发生时立即处理它，然而每天只产生一次订货报表。因此，用来产生订货报表的数据必须存放一段时间，也就是应该有一个数据存储。</p>
</blockquote>
<p>把基本系统模型细化，描绘系统的主要功能</p>
<figure><img src="https://i0.hdslb.com/bfs/album/a8b52cbd87dffa68ac9c8207c5d81c6b051ac974.png" alt="image-20230125232950795" tabindex="0" loading="lazy"><figcaption>image-20230125232950795</figcaption></figure>
<p>对功能级数据流图中描绘的系统主要功能进一步细化</p>
<figure><img src="https://i0.hdslb.com/bfs/album/f75bd43e95fb35c8422920827f89e33c635dcc36.png" alt="image-20230125233147062" tabindex="0" loading="lazy"><figcaption>image-20230125233147062</figcaption></figure>
<h3> 4.4 命名</h3>
<p>​     数据流图中每个成分的命名是否恰当，直接影响数据流图的可理解性。因此，给这些成分起名字时应该仔细推敲。</p>
<p><strong>数据流命名时应注意的问题</strong></p>
<ol>
<li>
<p>名字应代表整个数据流的内容，而不是仅仅反映它的某些成分</p>
</li>
<li>
<p>不要使用空洞的、缺乏具体含义的名字</p>
</li>
<li>
<p>在为某个数据流(或数据存储)起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成的，应该试试重新分解</p>
</li>
</ol>
<p><strong>为处理命名时应注意的问题</strong></p>
<ol>
<li>
<p>通常先为数据流命名，然后再为与之相关联的处理命名。</p>
</li>
<li>
<p>名字应该反映整个处理的功能，而不是它的一部分功能。</p>
</li>
<li>
<p>名字最好由一个具体的及物动词加上一个具体的宾语组成。</p>
</li>
<li>
<p>通常名字中仅包括一个动词，如果必须用两个动词才能描述整个处理的功能，则把这个处理再分解成两个处理可能更恰当些。</p>
</li>
<li>
<p>如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的迹象，应考虑重新分解。</p>
</li>
</ol>
<h3> 4.5 用途</h3>
<ol>
<li>
<p>画数据流图的基本目的是利用它作为交流信息的工具。</p>
</li>
<li>
<p>数据流图的另一个主要用途是作为分析和设计的工具。</p>
</li>
<li>
<p>数据流图辅助物理系统的设计时，以图中不同处理的定时要求为指南，能够在数据流图上画出许多组自动化边界，每组自动化边界可能意味着一个不同的物理系统。</p>
</li>
</ol>
<h2> 5.数据字典 DD</h2>
<blockquote>
<p>数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。</p>
</blockquote>
<h3> 5.1 内容</h3>
<p>数据字典有以下四类条目：数据项(数据流分量)、数据流、文件(数据存储)、基本加工(处理)。</p>
<p>除了数据定义之外，数据字典中还应该包含关于数据的一些其他信息。典型的情况是，在数据字典中记录数据元素的下列信息： 一般信息(名字，别名，描述等)，定义(数据类型，长度，结构等)，使用特点(值的范围，使用频率，使用方式——输入、输出、本地，条件值等)，控制信息(来源，用户，使用它的程序，改变权，使用权等)和分组信息(父结构，从属结构，物理位置——记录、文件和数据库等)。</p>
<p>数据元素的别名就是该元素的其他等价的名字，出现别名主要有下述3个原因：</p>
<ul>
<li>对于同样的数据，不同的用户使用了不同的名字。</li>
<li>一个分析员在不同时期对同一个数据使用了不同的名字。</li>
<li>两个分析员分别分析同一个数据流时，使用了不同的名字。</li>
</ul>
<h3> 5.2 定义数据的方法</h3>
<p>由数据元素组成数据的方式只有下述3种基本类型：</p>
<ul>
<li><strong>顺序</strong>即以确定次序连接两个或多个分量。</li>
<li><strong>选择</strong>即从两个或多个可能的元素中选取一个。</li>
<li><strong>重复</strong>即把指定的分量重复零次或多次。</li>
</ul>
<p>关系算符</p>
<ul>
<li>= 意思是等价于(或定义为)；</li>
<li>+ 意思是和(即连接两个分量)；</li>
<li>［］意思是或(即从方括弧内列出的若干个分量中选择一个)，通常用“|”号隔开供选择的分量；</li>
<li>{} 意思是重复(即重复花括弧内的分量)；</li>
<li>() 意思是可选(即圆括弧里的分量可有可无)。</li>
</ul>
<h3> 5.3 数据字典的用途</h3>
<ul>
<li>数据字典最重要的用途是作为分析阶段的工具</li>
<li>数据字典中包含的每个数据元素的控制信息是很有价值的</li>
<li>数据字典是开发数据库的第一步，而且是很有价值的一步。</li>
</ul>
<h3> 5.4 数据字典的实现</h3>
<p>目前，数据字典几乎总是作为CASE“结构化分析与设计工具”的一部分实现的。在开发大型软件系统的过程中，数据字典的规模和复杂程度迅速增加，人工维护数据字典几乎是不可能的。</p>
<p>在开发小型软件系统时暂时没有数据字典处理程序，建议采用卡片形式书写数据字典，每张卡片上保存描述一个数据的信息。</p>
<p>下面给出第4.3节的例子中几个数据元素的数据字典卡片，以具体说明数据字典卡片中上述几项内容的含义。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/6893276e702422b328e53fdf765dd9c6db1a6e5f.png" alt="image-20230126215439920" tabindex="0" loading="lazy"><figcaption>image-20230126215439920</figcaption></figure>
<h2> 6.成本/效益分析</h2>
<h3> 6.1 成本估计</h3>
<p>软件开发成本主要表现为人力消耗(乘以平均工资则得到开发费用)。成本估计不是精确的科学，因此应该使用几种不同的估计技术以便相互校验。</p>
<p>下面简单介绍3种估算技术。</p>
<ol>
<li>代码行技术</li>
<li>任务分解技术</li>
<li>自动估计成本技术</li>
</ol>
<p>任务分解技术最常用的办法是按开发阶段划分任务。典型环境下各个开发阶段需要使用的人力的百分比大致如下表所示:</p>
<figure><img src="https://i0.hdslb.com/bfs/album/3f7e54b605c1dd01c89da79fb0fcd1e654bdd6b7.png" alt="image-20230126220107192" tabindex="0" loading="lazy"><figcaption>image-20230126220107192</figcaption></figure>
<h3> 6.2 成本/效益分析的方法</h3>
<p>成本/效益分析方法主要从四个方面考虑</p>
<ul>
<li>
<p>货币的时间价值</p>
</li>
<li>
<p>投资回收期</p>
</li>
<li>
<p>纯收入</p>
</li>
<li>
<p>投资回收率</p>
</li>
</ul>
<p>货币的时间价值</p>
<figure><img src="https://i0.hdslb.com/bfs/album/8f9c0d28098866b2e38d4abf0a739610853be8d6.png" alt="image-20230126220405883" tabindex="0" loading="lazy"><figcaption>image-20230126220405883</figcaption></figure>
<p>例如，修改一个已有的库存清单系统，使它能在每天送给采购员一份订货报表。修改已有的库存清单程序并且编写产生报表的程序，估计共需5000元；系统修改后能及时订货，这将消除零件短缺问题，估计因此每年可以节省2500元，5年共可节省12500元。但是，不能简单地把5000元和12500元相比较，因为前者是现在投资的钱，后者是若干年以后节省的钱。</p>
<p>假定年利率为12%，利用上面计算货币现在价值的公式可以算出修改库存清单系统后每年预计节省的钱的现在价值，如下表所示。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/c716d3f63fbf6e106d95ffa03fcef3d1f001aca2.png" alt="image-20230126220419136" tabindex="0" loading="lazy"><figcaption>image-20230126220419136</figcaption></figure>
<h2> 7.本章小结</h2>
<ol>
<li>
<p>了解可行性研究的必要性，以及如何进行可行性研究</p>
</li>
<li>
<p>学习系统流程图、数据流图</p>
</li>
<li>
<p>学习数据字典的概念、用途及实现</p>
</li>
<li>
<p>成本/效益分析方法</p>
</li>
</ol>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">03 【需求分析】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/03.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/03.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 03 【需求分析】</h1>
<p>为了开发出真正满足用户需求的软件产品，首先必须知道用户的需求。对软件需求的深入理解是软件开发工作获得成功的前提条件，不论人们把设计和编码工作做得如何出色，不能真正满足用户需求的程序只会令用户失望，给开发者带来烦恼。</p>
<p>需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答“系统必须做什么?”这个问题，对目标系统提出完整、准确、清晰、具体的要求。 系统分析员应该写出<strong>软件需求规格说明书</strong>，以书面形式准确地描述软件需求。</p>
<h2> 1.需求分析的任务</h2>
<h3> 1.1 确定对系统的综合要求</h3>]]></summary>
    <content type="html"><![CDATA[<h1> 03 【需求分析】</h1>
<p>为了开发出真正满足用户需求的软件产品，首先必须知道用户的需求。对软件需求的深入理解是软件开发工作获得成功的前提条件，不论人们把设计和编码工作做得如何出色，不能真正满足用户需求的程序只会令用户失望，给开发者带来烦恼。</p>
<p>需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答“系统必须做什么?”这个问题，对目标系统提出完整、准确、清晰、具体的要求。 系统分析员应该写出<strong>软件需求规格说明书</strong>，以书面形式准确地描述软件需求。</p>
<h2> 1.需求分析的任务</h2>
<h3> 1.1 确定对系统的综合要求</h3>
<p>虽然功能需求是对软件系统的一项基本需求，但却并不是唯一的需求。通常对软件系统有下述几方面的综合要求。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d336da3a6ae5338e6ff68b1dabfb1a46edb1ba94.png" alt="image-20230126221725410" tabindex="0" loading="lazy"><figcaption>image-20230126221725410</figcaption></figure>
<p><strong>功能性需求</strong></p>
<p>这方面的需求指定系统必须提供的服务。通过需求分析应该划分出系统必须完成的所有功能</p>
<p><strong>性能需求</strong></p>
<p>性能需求指定系统必须满足的定时约束或容量约束，通常包括速度(响应时间)、信息量速率、主存容量、磁盘容量、安全性等方面的需求。</p>
<p><strong>可靠性和可用性需求</strong></p>
<p>可靠性需求定量地指定系统的可靠性，可用性与可靠性密切相关，它量化了用户可以使用系统的程度。</p>
<p><strong>出错处理需求</strong></p>
<p>这类需求说明系统对环境错误应该怎样响应。例如，如果它接收到从另一个系统发来的违反协议格式的消息，应该做什么?注意，上述这类错误并不是由该应用系统本身造成的。</p>
<p><strong>接口需求</strong></p>
<p>接口需求描述应用系统与它的环境通信的格式。常见的接口需求有：用户接口需求；硬件接口需求；软件接口需求；通信接口需求。</p>
<p><strong>约束</strong></p>
<p>设计约束或实现约束描述在设计或实现应用系统时应遵守的限制条件。常见的约束有：精度；工具和语言约束；设计约束；应该使用的标准；应该使用的硬件平台。</p>
<p><strong>逆向需求</strong></p>
<p>逆向需求说明软件系统不应该做什么。理论上有无限多个逆向需求，人们应该仅选取能澄清真实需求且可消除可能发生的误解的那些逆向需求。</p>
<p><strong>将来可能提出的要求</strong></p>
<p>应该明确地列出那些虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。这样做的目的是，在设计过程中对系统将来可能的扩充和修改预做准备，以便一旦确实需要时能比较容易地进行这种扩充和修改。</p>
<h3> 1.2 分析系统的数据要求</h3>
<p>任何一个软件系统本质上都是信息处理系统，系统必须处理的信息和系统应该产生的信息在很大程度上决定了系统的面貌，对软件设计有深远影响，因此，必须分析系统的数据要求，这是软件需求分析的一个重要任务。</p>
<p>复杂的数据由许多基本的数据元素组成，数据结构表示数据元素之间的逻辑关系。利用数据字典可以全面准确地定义数据，但是数据字典的缺点是不够形象直观。为了提高可理解性，常常利用图形工具辅助描绘数据结构。</p>
<h3> 1.3 导出系统的逻辑模型</h3>
<p>综合上述两项分析的结果可以导出系统的详细的逻辑模型，通常用数据流图、实体联系图、状态转换图、数据字典和主要的处理算法描述这个逻辑模型。</p>
<h3> 1.4 修正系统开发计划</h3>
<p>根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。</p>
<h2> 2.分析建模与规格说明（重要）</h2>
<h3> 2.1 分析建模</h3>
<p>模型，就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。</p>
<p>为了开发复杂的系统，应从不同角度（模型）抽象出目标系统的特性（数据模型、功能模型、行为模型）</p>
<figure><img src="https://i0.hdslb.com/bfs/album/7d4221ef7f36e4686a3e212220205c90704bb138.png" alt="image-20230126223449383" tabindex="0" loading="lazy"><figcaption>image-20230126223449383</figcaption></figure>
<ul>
<li>实体联系图，描绘数据对象及数据对象之间的关系，是用于建立数据模型的图形。</li>
<li>数据流图是建立功能模型的基础。</li>
<li>状态转换图描绘了系统的各种行为模式和在不同状态间转换的方式。</li>
</ul>
<h3> 2.2  软件需求规格说明</h3>
<p>软件需求规格说明是需求分析阶段得出的最主要的文档。</p>
<p>通常用自然语言完整、准确、具体地描述系统的数据要求、功能需求、性能需求、可靠性和可用性要求、出错处理需求、接口需求、约束、逆向需求以及将来可能提出的要求。</p>
<h2> 3.实体-联系图</h2>
<p>数据模型中包含3种相互关联的信息：数据对象、数据对象的属性及数据对象彼此间相互连接的关系。</p>
<h3> 3.1 数据对象</h3>
<p><strong>数据对象是对软件必须理解的复合信息的抽象。</strong></p>
<p>数据对象可以是外部实体、事物、行为、事件、角色、单位、地点或结构等。总之，可以由一组属性来定义的实体都可以被认为是数据对象。</p>
<h3> 3.2 属性</h3>
<p><strong>属性定义了数据对象的性质</strong>。</p>
<p>必须把一个或多个属性定义为“标识符”，也就是说，当人们希望找到数据对象的一个实例时，用标识符属性作为“关键字”(通常简称为“键”)。</p>
<h3> 3.3 联系</h3>
<p><strong>客观世界中的事物彼此间往往是有联系的</strong>。</p>
<p>数据对象彼此之间相互连接的方式称为联系，也称为关系。联系可分为以下3种类型。</p>
<ul>
<li>一对一联系(1∶1)</li>
<li>一对多联系(1∶N)</li>
<li>多对多联系(M∶N)</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/644d4026f5c62a3de2091e5138f6f9933be88bbd.png" alt="image-20230127223243074" tabindex="0" loading="lazy"><figcaption>image-20230127223243074</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/055f5a7108f92f0e8a6b509401eb601f08f375d6.png" alt="image-20230127223250799" tabindex="0" loading="lazy"><figcaption>image-20230127223250799</figcaption></figure>
<h3> 3.4 实体-联系图的符号</h3>
<p>通常，使用实体联系图(entityrelationship diagram)来建立数据模型。可以把实体联系图简称为ER图，相应地可把用ER图描绘的数据模型称为ER模型。</p>
<p>ER图中包含了实体(即数据对象)、关系和属性3种基本成分，通常用矩形框代表实体，用连接相关实体的菱形框表示关系，用椭圆形或圆角矩形表示实体(或关系)的属性，并用直线把实体(或关系)与其属性连接起来。</p>
<p>ER模型可以作为用户与分析员之间有效的交流工具。</p>
<h2> 4.状态转换图</h2>
<p>状态转换图(简称为状态图)通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。此外，状态图还指明了作为特定事件的结果系统将做哪些动作。</p>
<h3> 4.1 状态</h3>
<p>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。</p>
<p>在状态图中定义的状态主要有：初态(即初始状态)、终态(即最终状态)和中间状态。在一张状态图中只能有一个初态，而终态则可以有0至多个。</p>
<p>状态图既可以表示系统循环运行过程，也可以表示系统单程生命期。</p>
<h3> 4.2 事件</h3>
<p>事件是在某个特定时刻发生的事情，它是对引起系统做动作或(和)从一个状态转换到另一个状态的外界事件的抽象。</p>
<p>事件就是引起系统做动作或(和)转换状态的控制信息。</p>
<h3> 4.3 符号</h3>
<p>状态图中两个状态之间带箭头的连线称为状态转换，箭头指明了转换方向。状态变迁通常是由事件触发的，在这种情况下应在表示状态转换的箭头线上标出触发转换的事件表达式；如果在箭头线上未标明事件，则表示在源状态的内部活动执行完之后自动触发转换。</p>
<p>事件表达式的语法如下：</p>
<p>事件说明［守卫条件］／动作表达式其中，事件说明的语法为：事件名(参数表)。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/bed92b1f6dd9981f2e45e16bedbe872e39c92ee7.png" alt="image-20230127225650921" tabindex="0" loading="lazy"><figcaption>image-20230127225650921</figcaption></figure>
<h3> 4.4 例子</h3>
<p>为了具体说明怎样用状态图建立系统的行为模型，下面举一个例子</p>
<p>下图是人们非常熟悉的电话系统的状态图。</p>
<img src="https://i0.hdslb.com/bfs/album/2743f580af8935945d6ffc966f615c95b5e084d4.png" alt="image-20230127225722348" style="zoom: 50%;">
<h2> 5.其他图形工具</h2>
<h3> 5.1 层次方框图</h3>
<p>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。</p>
<p>例如，描绘一家计算机公司全部产品的数据结构可以用下图层次方框图表示。</p>
<p>这家公司的产品由硬件、软件和服务3类产品组成，软件产品又分为系统软件和应用软件，系统软件又进一步分为操作系统、编译程序和软件工具等。</p>
<img src="https://i0.hdslb.com/bfs/album/bf27e08f12f549fafb9f23c6630241f340299276.png" alt="image-20230127225905396" style="zoom:80%;">
<h3> 5.2 Warnier图</h3>
<p>和层次方框图类似，Warnier图也用树形结构描绘信息，但是这种图形工具比层次方框图提供了更丰富的描绘手段。</p>
<p>用Warnier图可以表明信息的逻辑组织，也就是说，它可以指出一类信息或一个信息元素是重复出现的，也可以表示特定信息在某一类信息中是有条件地出现的。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/0d7db7fbd91b2bf1e30532ddeb74cbd1366f23e0.png" alt="image-20230127225959364" tabindex="0" loading="lazy"><figcaption>image-20230127225959364</figcaption></figure>
<h3> 5.3 IPO图</h3>
<p>IPO图是输入、处理、输出图的简称，它是由美国IBM公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。</p>
<p>下图是主文件更新的例子，通过这个例子不难了解IPO图的用法</p>
<img src="https://i0.hdslb.com/bfs/album/9e60b8bf073a5253d44d6863dc782e05770ce25a.png" alt="image-20230127230124219" style="zoom:50%;">
<p>改进的IPO图</p>
<img src="https://i0.hdslb.com/bfs/album/3bfbcbfe61b6c1138ba100fb59f03505467f53be.png" alt="image-20230127230129596" style="zoom:50%;">
<h2> 6.本章小结</h2>
<ol>
<li>
<p>本章讲解了需求分析的重要性，以及如何与用户交谈获取需求</p>
</li>
<li>
<p>讲述建立模型的方法，在需求分析阶段建立数据模型、功能模型和行为模型。</p>
</li>
<li>
<p>讲述如何使用实体联系图建立数据模型，使用数据流图建立功能模型，使用状态图建立行为模型。</p>
</li>
<li>
<p>详细阐述状态转换图</p>
</li>
<li>
<p>最后讲解如何验证软件需求。</p>
</li>
</ol>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">04 【总体设计】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/04.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/04.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 04 【总体设计】</h1>
<p>总体设计的基本目的就是回答“概括地说，系统应该如何实现”这个问题，因此，总体设计又称为概要设计或初步设计。</p>
<p>总体设计阶段的另一项重要任务是设计软件的结构，也就是要确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。</p>
<h2> 1.设计过程</h2>
<p><strong>1.</strong> <strong>设想供选择的方案</strong></p>
<p>在总体设计阶段分析员应该考虑各种可能的实现方案，并且力求从中选出最佳方案。</p>
<p>需求分析阶段得出的数据流图是总体设计的极好的出发点。</p>
<p>设想供选择的方案的一种常用的方法是，设想把数据流图中的处理分组的各种可能的方法，抛弃在技术上行不通的分组方法(例如，组内不同处理的执行时间不相容)，余下的分组方法代表可能的实现策略，并且可以启示供选择的物理系统。</p>]]></summary>
    <content type="html"><![CDATA[<h1> 04 【总体设计】</h1>
<p>总体设计的基本目的就是回答“概括地说，系统应该如何实现”这个问题，因此，总体设计又称为概要设计或初步设计。</p>
<p>总体设计阶段的另一项重要任务是设计软件的结构，也就是要确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。</p>
<h2> 1.设计过程</h2>
<p><strong>1.</strong> <strong>设想供选择的方案</strong></p>
<p>在总体设计阶段分析员应该考虑各种可能的实现方案，并且力求从中选出最佳方案。</p>
<p>需求分析阶段得出的数据流图是总体设计的极好的出发点。</p>
<p>设想供选择的方案的一种常用的方法是，设想把数据流图中的处理分组的各种可能的方法，抛弃在技术上行不通的分组方法(例如，组内不同处理的执行时间不相容)，余下的分组方法代表可能的实现策略，并且可以启示供选择的物理系统。</p>
<p><strong>2.选取合理的方案</strong></p>
<p>应该从前一步得到的一系列供选择的方案中选取若干个合理的方案，通常至少选取低成本、中等成本和高成本的3种方案。在判断哪些方案合理时应该考虑在问题定义和可行性研究阶段确定的工程规模和目标，有时可能还需要进一步征求用户的意见。</p>
<p>对每个合理的方案，分析员都应该准备下列4份资料。</p>
<p>(1) 系统流程图。</p>
<p>(2) 组成系统的物理元素清单。</p>
<p>(3) 成本/效益分析。</p>
<p>(4) 实现这个系统的进度计划。</p>
<p><strong>3.推荐最佳方案</strong></p>
<p>用户和有关的技术专家应该认真审查分析员所推荐的最佳系统，如果该系统确实符合用户的需要，并且是在现有条件下完全能够实现的，则应该提请使用部门负责人进一步审批。在使用部门的负责人也接受了分析员所推荐的方案之后，将进入总体设计过程的下一个重要阶段——结构设计。</p>
<p><strong>4.功能分解</strong></p>
<p>为了最终实现目标系统，必须设计出组成这个系统的所有程序和文件(或数据库)。对程序(特别是复杂的大型程序)的设计，通常分为两个阶段完成：首先进行结构设计，然后进行过程设计。</p>
<p>为确定软件结构，首先需要从实现角度把复杂的功能进一步分解。分析员结合算法描述仔细分析数据流图中的每个处理，如果一个处理的功能过分复杂，必须把它的功能适当地分解成一系列比较简单的功能。</p>
<p><strong>5.</strong> <strong>设计软件结构</strong></p>
<p>通常程序中的一个模块完成一个适当的子功能。应该把模块组织成良好的层次系统，顶层模块调用它的下层模块以实现程序的完整功能，每个下层模块再调用更下层的模块，完成程序的一个子功能，最下层的模块完成最具体的功能。</p>
<p><strong>6.</strong> <strong>设计数据库</strong></p>
<p>对于需要使用数据库的那些应用系统，软件工程师应该在需求分析阶段所确定的系统数据需求的基础上，进一步设计数据库。</p>
<p><strong>7.制定测试计划</strong></p>
<p>在软件开发的早期阶段考虑测试问题，能促使软件设计人员在设计时注意提高软件的可测试性。第7章具体讨论</p>
<p><strong>8.</strong> <strong>书写文档</strong></p>
<p>应该用正式的文档记录总体设计的结果，在这个阶段应该完成的文档通常有下述几种。</p>
<p>(1) 系统说明</p>
<p>(2) 用户手册</p>
<p>(3) 测试计划包括测试策略，测试方案，预期的测试结果，测试进度计划等</p>
<p>(4) 详细的实现计划</p>
<p>(5) 数据库设计结果</p>
<p><strong>9.审查和复审</strong></p>
<p>最后应该对总体设计的结果进行严格的技术审查，在技术审查通过之后再由客户从管理角度进行复审。</p>
<h2> 2.设计原理</h2>
<h3> 2.1 模块化</h3>
<p><strong>模块</strong>是由边界元素限定的相邻程序元素（例如，数据说明，可执行的语句）的序列，而且有一个总体标识符代表它。<strong>模块</strong>是构成程序的基本构件。</p>
<p><strong>模块化</strong>就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。</p>
<p>模块化是为了使一个复杂的大型程序能被人的智力所管理，是软件应该具备的唯一属性。</p>
<h3> 2.2 抽象</h3>
<p>现实世界中一定事物、状态或过程之间总存在着某些相似的方面(共性)。把这些相似的方面集中和概括起来，暂时忽略它们之间的差异，这就是抽象。<strong>抽象就是抽出事物本质特性而暂时不考虑细节。</strong></p>
<h3> 2.3 逐步求精</h3>
<p>逐步求精定义为为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。</p>
<h3> 2.4 信息隐藏和局部化</h3>
<p>​    信息隐藏原理：应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。</p>
<p>​    局部化是指把一些关系密切的软件元素物理地放得彼此靠近。</p>
<p>​    如果在测试期间和以后的软件维护期间需要修改软件，使用信息隐藏原理作为模块化系统设计的标准就会带来极大好处。</p>
<h3> 2.5 模块独立</h3>
<p>独立的模块容易开发、维护和测试。 模块的独立程度有两个标准度量：内聚和耦合</p>
<h4> 耦合</h4>
<p>耦合是对于不同模块间互联程度的度量 耦合分为</p>
<ul>
<li>
<p>数据耦合</p>
<p>两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合。数据耦合是低耦合。系统中至少必须存在这种耦合。</p>
</li>
<li>
<p>控制耦合</p>
<p>传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则这种耦合称为控制耦合。控制耦合是中等程度的耦合。</p>
</li>
<li>
<p>特征耦合</p>
<p>当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。</p>
</li>
<li>
<p>公共环境耦合</p>
<p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。</p>
<p>公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。</p>
<p>公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。。</p>
</li>
<li>
<p>内容耦合</p>
<ul>
<li>一个模块访问另一个模块的内部数据</li>
<li>一个模块不通过正常入口进入另一模块的内部</li>
<li>两模块程序代码重叠</li>
<li>一个模块有多个入口</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>内容耦合</strong>是最高程度耦合，应坚决避免使用内容耦合。 耦合原则：尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合范围，完全不用内容耦合。</p>
</blockquote>
<h4> 内聚</h4>
<p>内聚衡量一个模块内部各个元素彼此结合的紧密程度。</p>
<p>内聚标志着一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然扩展。简单地说，理想内聚的模块只做一件事情。</p>
<p>内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。</p>
<p>内聚分为三大类低内聚、中内聚和高内聚</p>
<p>① <strong>低内聚</strong></p>
<p>一个模块完成一组任务，这些任务彼此间即使有关系，关系也是很松散的，就叫做偶然内聚。</p>
<p>一个模块完成的任务在逻辑上属于相同或相似的一类，则称为逻辑内聚。</p>
<p>一个模块包含的任务必须在同一段时间内执行，就叫时间内聚。</p>
<p>②<strong>中内聚</strong></p>
<p>一个模块内的处理元素是相关的，而且必须以特定次序执行，则称为过程内聚。</p>
<p>模块中所有元素都使用同一个输入数据和(或)产生同一个输出数据，则称为通信内聚。</p>
<p>③<strong>高内聚</strong></p>
<p>一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行(通常一个处理元素的输出数据作为下一个处理元素的输入数据)，则称为顺序内聚。</p>
<p>模块内所有处理元素属于一个整体，完成一个单一的功能，则称为功能内聚。功能内聚是最高程度的内聚。</p>
<p>耦合和内聚的概念是Constantine,Yourdon,Myers和Stevens等人提出来的。上述7种内聚的优劣评分，将得到如下结果：</p>
<figure><img src="https://article.biliimg.com/bfs/article/074fa4152def13353e0fe509c3af53c17cc16dfe.png" alt="image-20230204201314507" tabindex="0" loading="lazy"><figcaption>image-20230204201314507</figcaption></figure>
<p>事实上，没有必要精确确定内聚的级别。重要的是设计时高内聚，并且能够辨认出低内聚的模块，有能力通过修改设计提高模块的内聚程度并且降低模块间的耦合程度，从而获得较高的模块独立性。</p>
<h2> 3.启发规则</h2>
<p><strong>1.设计出软件的初步结构以后，应该审查分析这个结构，通过模块分解或合并，力求降低耦合提高内聚。</strong></p>
<p><img src="https://article.biliimg.com/bfs/article/14fe8203b6d9f1f27a8b0a3ff5c62767493c9d5b.png" alt="image-20230204201800466" style="zoom:67%;"><strong>2.</strong> <strong>模块规模应该适中</strong></p>
<p>一个模块的规模不应过大，最好能写在一页纸内(通常不超过60行语句)</p>
<p><strong>3.深度、宽度、扇出和扇入都应适当</strong></p>
<p>深度：软件结构中控制的层数</p>
<p>宽度：软件结构内同一个层次上的模块总数的最大值</p>
<p>扇出：一个模块直接控制(调用)的模块数目</p>
<p>扇入：一个模块被多少个上级模块直接调用的数目</p>
<p><strong>4.模块的作用域应该在控制域之内</strong></p>
<p>作用域：受该模块内一个判定影响的所有模块的集合。</p>
<p>控制域：模块本身以及所有直接或间接从属于它的模块的集合。</p>
<p>在一个设计得很好的系统中，所有受判定影响的模块应该都从属于做出判定的那个模块，最好局限于做出判定的那个模块本身及它的直属下级模块。</p>
<img src="https://article.biliimg.com/bfs/article/4b6f5a5a60893d05ebb3af0ffcf422a2fbe7e9fa.png" alt="image-20230204201837091" style="zoom:67%;">
<p><strong>5.力争降低模块接口的复杂程度</strong></p>
<p>模块接口复杂是软件发生错误的一个主要原因。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。</p>
<p><strong>6.设计单入口单出口的模块</strong></p>
<p>这条启发式规则警告软件工程师不要使模块间出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。</p>
<p><strong>7.模块功能应该可以预测</strong></p>
<p>模块的功能应该能够预测，但也要防止模块功能过分局限。</p>
<h2> 4.描绘软件结构的图形工具</h2>
<h3> 4.1 层次图和HIPO图</h3>
<p>层次图用来描绘软件的层次结构。数据结构的层次方框图相同，但是表现的内容却完全不同。层次图很适于在自顶向下设计软件的过程中使用。</p>
<img src="https://article.biliimg.com/bfs/article/579cdf0e7fe01611991c59b3d9db6f23fb71dd0b.png" alt="image-20230204202532287" style="zoom:50%;">
<p>HIPO图是美国IBM公司发明的“层次图加输入/处理/输出图”的英文缩写。为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。</p>
<img src="https://article.biliimg.com/bfs/article/e91c3c95de9990884a698213e66d4fdcb1e98d5a.png" alt="image-20230204202551001" style="zoom:50%;">
<h3> 4.2 结构图</h3>
<p>Yourdon提出的结构图是进行软件结构设计的工具。图中一个方框代表一个模块，框内注明模块的名字或主要功能；方框之间的箭头(或直线)表示模块的调用关系。尾部是空心圆表示传递的是数据，实心圆表示传递的是控制信息。</p>
<img src="https://article.biliimg.com/bfs/article/195034cf412a752b1a82daed0e8be12b11a48eec.png" alt="image-20230204202601657" style="zoom:50%;">
<p>一些附加的符号，可以表示模块的选择调用或循环调用。左图表示当模块M中某个判定为真时调用模块A，为假时调用模块B。右图表示模块M循环调用模块A、B和C。</p>
<img src="https://article.biliimg.com/bfs/article/80c86ce96664e1ec899865d0684b5403be195476.png" alt="image-20230204202628055" style="zoom:50%;">
<img src="https://article.biliimg.com/bfs/article/a4a94e1d60e2556db04af230efb39d4326cf96c2.png" alt="image-20230204202631387" style="zoom:50%;">
<h2> 5.面向数据流的设计方法</h2>
<h3> 5.1 概念</h3>
<p>面向数据流的设计方法把信息流映射成软件结构，信息流的类型决定了映射的方法。信息流有下述两种类型。</p>
<p><strong>1）变换流</strong></p>
<p>信息沿输入通路进入系统，由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。当数据流图具有这些特征时，这种信息流就叫作变换流。</p>
<img src="https://article.biliimg.com/bfs/article/f5be9b77c288c9810d0a326b785818b83878a1c9.png" alt="image-20230204202652471" style="zoom:50%;">
<p><strong>2）事务流</strong></p>
<p>数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。这类数据流应该划为一类特殊的数据流，称为事务流。图中的处理T称为事务中心，它完成下述任务。</p>
<p>(1) 接收输入数据(输入数据又称为事务)。</p>
<p>(2) 分析每个事务以确定它的类型。</p>
<p>(3) 根据事务类型选取一条活动通路。</p>
<img src="https://article.biliimg.com/bfs/article/ad35133cf58dd5a1549392ae3f3b308eabe5dfbc.png" alt="image-20230204202700643" style="zoom:50%;">
<p><strong>3）设计过程</strong></p>
<img src="https://article.biliimg.com/bfs/article/53a4828b6826a3addad09640b3c24e4fb61c0009.png" alt="image-20230204202707447" style="zoom:50%;">
<h2> 6.本章小结</h2>
<ol>
<li>
<p>总体设计阶段主要由系统设计和结构设计两阶段组成。</p>
</li>
<li>
<p>进行软件结构设计时应该遵循的最主要的原理是模块独立原理。</p>
</li>
<li>
<p>在软件开发过程中既要充分重视和利用这些启发式规则，又要从实际情况出发避免生搬硬套。</p>
</li>
<li>
<p>层次图和结构图是描绘软件结构的常用工具。</p>
</li>
<li>
<p>用形式化的方法由数据流图映射出软件结构。</p>
</li>
</ol>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">05 【详细设计】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/05.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/05.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 05 【详细设计】</h1>
<p>根本目标：确定应该怎样具体地实现所要求的系统。</p>
<p>详细设计阶段的任务不是具体地编写程序，而是要设计出程序的“蓝图”。</p>
<p>详细设计的结果基本上决定了最终的程序代码的质量。</p>
<h2> 1.结构程序设计</h2>
<p><strong>定义</strong></p>
<ul>
<li>结构化程序设计采用<strong>自顶向下、逐步求精</strong>的设计方法，各个模块通过“顺序、选择、循环”的控制结构进行连接，并且只有一个入口、一个出口。</li>
<li>结构化程序设计的原则可表示为：程序=(算法)+(数据结构)。</li>
<li>如果一个程序的代码块仅仅通过<strong>顺序、选择和循环</strong>这3 种基本控制结构进行连接，并且<strong>每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</strong></li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h1> 05 【详细设计】</h1>
<p>根本目标：确定应该怎样具体地实现所要求的系统。</p>
<p>详细设计阶段的任务不是具体地编写程序，而是要设计出程序的“蓝图”。</p>
<p>详细设计的结果基本上决定了最终的程序代码的质量。</p>
<h2> 1.结构程序设计</h2>
<p><strong>定义</strong></p>
<ul>
<li>结构化程序设计采用<strong>自顶向下、逐步求精</strong>的设计方法，各个模块通过“顺序、选择、循环”的控制结构进行连接，并且只有一个入口、一个出口。</li>
<li>结构化程序设计的原则可表示为：程序=(算法)+(数据结构)。</li>
<li>如果一个程序的代码块仅仅通过<strong>顺序、选择和循环</strong>这3 种基本控制结构进行连接，并且<strong>每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</strong></li>
</ul>
<p>下图中（a）为顺序结构，（b）为 IF-THEN-ELSE选择（分支）结构，（c）为 DO-WHILE 型循环结构。</p>
<img src="https://article.biliimg.com/bfs/article/4679a39979aaf136e2b8188981027f3900606127.png" alt="image-20230204202851564" style="zoom: 80%;">
<p>图（a）为 DO - UNTIL型循环结构，（b）多分支结构。</p>
<img src="https://article.biliimg.com/bfs/article/0125ed0548599e728d1937614426eec124c7d68f.png" alt="image-20230204202907613" style="zoom:50%;">
<h2> 2.人机界面设计</h2>
<p>人机界面设计是接口设计的重要组成部分。对于交互式系统来说，人机界面设计和数据设计、体系结构设计及过程设计一样重要。（可参考概要设计）。</p>
<h3> 2.1 设计问题</h3>
<p>设计人机界面过程中会遇到的4 个问题：系统响应时间、用户帮助设施、出错信息处理、命令交互。</p>
<p><strong>① 系统响应时间。</strong></p>
<p>系统响应时间指从用户完成某个控制动作(例如，按回车键或单击鼠标)，到软件给出预期的响应(输出信息或做动作)之间的这段时间。</p>
<p>系统响应时间有两个重要属性，分别是长度和易变性。</p>
<p>1）长度：时间过长，用户就会感到紧张，过短，加快用</p>
<p>户操作节奏，可能会犯错误</p>
<p>2）易变性：系统响应时间相对于平均响应时间的偏差</p>
<p>即使系统响应时间较长，响应时间易变性低也有助于用</p>
<p>户建立起稳定的工作节奏。</p>
<p><strong>② 用户帮助设施。</strong></p>
<p>常见的帮助设施可分为集成的和附加的两类。</p>
<p>具体设计帮助设施时，必须解决下述的一系列问题。</p>
<p>(1)在用户与系统交互期间，是否在任何时候都能获得关于系统任何功能的帮助信息?有两种选择：提供部分功能的帮助信息和提供全部功能的帮助信息。</p>
<p>(2)用户怎样请求帮助?有3种选择：帮助菜单，特殊功能键和HELP命令。</p>
<p>(3)怎样显示帮助信息?有3种选择：在独立的窗口中，指出参考某个文档(不理想)和在屏幕固定位置显示简短提示。</p>
<p>(4)用户怎样返回到正常的交互方式中?有两种选择：屏幕上的返回按钮和功能键。</p>
<p>(5)怎样组织帮助信息?有3种选择：平面结构，信息的层次结构和超文本结构。</p>
<p><strong>③ 出错信息处理。</strong></p>
<p>出错信息和警告信息，是出现问题时交互式系统给出的“坏消息”。一般说来，交互式系统给出的出错信息或警告信息，具有下述属性。</p>
<p>(1) 用用户可以理解的术语描述问题。</p>
<p>(2) 提供有助于从错误中恢复的建设性意见。</p>
<p>(3) 指出错误可能导致哪些负面后果(例如，破坏数据文件)，以便用户检查是否出现了这些问题，并在确实出现问题时及时解决。</p>
<p>(4) 伴随着听觉上或视觉上的提示</p>
<p>(5) 不能带有指责色彩，不能责怪用户。</p>
<p><strong>④ 命令交互。</strong></p>
<p>许多高级用户仍然偏爱面向命令行的交互方式</p>
<p>在提供命令交互方式时，必须考虑下列设计问题。</p>
<p>(1) 是否每个菜单选项都有对应的命令?</p>
<p>(2) 采用何种命令形式?有3种选择：控制序列(例如，Ctrl+P)，功能键和输入命令。</p>
<p>(3) 学习和记忆命令的难度有多大?忘记了命令怎么办?</p>
<p>(4) 用户是否可以定制或缩写命令?</p>
<p>在越来越多的应用软件中，人机界面设计者都提供了“命令宏机制”。</p>
<p>在理想的情况下，所有应用软件都有一致的命令使用方法。</p>
<h3> 2.2 设计过程</h3>
<p>用户界面设计是一个迭代的过程，通常先创建设计模型，再用原型实现这个设计模型，并由用户试用和评估，然后根据用户意见进行修改。</p>
<p>建立起用户界面的原型，就必须对它进行评估，评估可以是非正式的也可以使正式的。</p>
<img src="https://article.biliimg.com/bfs/article/5a0223d7999f895a524c1a630bc28e862d5b8bc7.png" alt="image-20230204203236964" style="zoom:67%;">
<p>创建了用户界面的设计模型之后，可以运用下述评估标准对设计进行早期复审。</p>
<p>(1) 系统及其界面的规格说明书的长度和复杂程度，预示了用户学习使用该系统所需要的工作量。</p>
<p>(2) 命令或动作的数量、命令的平均参数个数或动作中单个操作的个数，预示了系统的交互时间和总体效率。</p>
<p>(3) 设计模型中包含的动作、命令和系统状态的数量，预示了用户学习使用该系统时需要记忆的内容的多少。</p>
<p>(4) 界面风格、帮助设施和出错处理协议，预示了界面的复杂程度及用户接受该界面的程度。</p>
<h3> 2.3 人机界面设计指南</h3>
<p><strong>①  一般交互指南</strong>：涉及信息显示、数据输入和系统整体控制</p>
<p>(1)保持一致性。</p>
<p>(2)提供有意义的反馈。</p>
<p>(3)在执行有较大破坏性的动作之前要求用户确认。</p>
<p>(4)允许取消绝大多数操作。</p>
<p>(5)减少在两次操作之间必须记忆的信息量。</p>
<p>(6)提高对话、移动和思考的效率。</p>
<p>(7)允许犯错误。</p>
<p>(8)按功能对动作分类，并据此设计屏幕布局。</p>
<p>(9)提供对用户工作内容敏感的帮助设施</p>
<p>(10)用简单动词或动词短语作为命令名。</p>
<p>创建了用户界面的设计模型之后，可以运用下述评估标准对设计进行早期复审。</p>
<p>(1) 系统及其界面的规格说明书的长度和复杂程度，预示了用户学习使用该系统所需要的工作量。</p>
<p>(2) 命令或动作的数量、命令的平均参数个数或动作中单个操作的个数，预示了系统的交互时间和总体效率。</p>
<p>(3) 设计模型中包含的动作、命令和系统状态的数量，预示了用户学习使用该系统时需要记忆的内容的多少。</p>
<p>(4) 界面风格、帮助设施和出错处理协议，预示了界面的复杂程度及用户接受该界面的程度。</p>
<p><strong>② 信息显示指南</strong>：多种不同方式“显示”信息：用文字、图形和声音；按位置、移动和大小；使用颜色、分辨率和省略。</p>
<p>(1)只显示与当前工作内容有关的信息。</p>
<p>(2)不要用数据淹没用户，应该用便于用户迅速吸取信息的方式来表示数据。</p>
<p>(3)使用一致的标记、标准的缩写和可预知的颜色。</p>
<p>(4)允许用户保持可视化的语境。</p>
<p>(5)产生有意义的出错信息。</p>
<p>(6)使用大小写、缩进和文本分组以帮助理解。</p>
<p>(7)使用窗口分隔不同类型的信息。</p>
<p>(8)使用“模拟”显示方式表示信息，以使信息更容易被用户提取。</p>
<p>(9) 高效率地使用显示屏。</p>
<p><strong>③ 数据输入指南</strong>：用户的大部分时间用在选择命令、输入数据和向系统提供输入。</p>
<p>(1)尽量减少用户的输入动作。</p>
<p>(2)保持信息显示和数据输入之间的一致性。</p>
<p>(3)允许用户自定义输入。</p>
<p>(4)交互应该是灵活的，并且可调整成用户最喜欢的输入方式。</p>
<p>(5)使在当前动作语境中不适用的命令不起作用。</p>
<p>(6)让用户控制交互流。</p>
<p>(7)对所有输入动作都提供帮助。</p>
<p>(8)消除冗余的输入。</p>
<p>(9) 高效率地使用显示屏。</p>
<h2> 3.详细设计工具</h2>
<table>
<thead>
<tr>
<th>工具名</th>
<th>主要优点</th>
<th>主要缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序流程图</td>
<td>简单直观</td>
<td>不考虑全局；不易表示数据结构</td>
</tr>
<tr>
<td>盒图(N-S图)</td>
<td>考虑全局；作用域明确</td>
<td>不易绘制和修改</td>
</tr>
<tr>
<td>PAD图</td>
<td>清晰表现逻辑结构、数据结构；有直接转换工具</td>
<td>~</td>
</tr>
<tr>
<td>判定表</td>
<td>清晰表现动作关系</td>
<td>含义复杂；不够简洁</td>
</tr>
<tr>
<td>判定树</td>
<td>形式简单</td>
<td>简洁性比判定表还要差</td>
</tr>
<tr>
<td>过程设计语言PDL</td>
<td>便于保持文档和程序一致性；便于数据结构说明</td>
<td>不直观</td>
</tr>
</tbody>
</table>
<h3> 3.1 程序流程图</h3>
<p><strong>程序流程图又称为程序框图</strong>，它是使用最广泛的描述过程设计的方法。程序流程图中使用的符号(a) 选择(分支)； (b) 注释； (c) 预先定义的处理； (d) 多分支； (e) 开始或停止； (f) 准备； (g) 循环上界限； (h) 循环下界限； (i) 虚线； (j) 省略符； (k) 并行方式； (l) 处理； (m) 输入输出； (n) 连接； (o) 换页连接； (p) 控制流</p>
<img src="https://article.biliimg.com/bfs/article/31dd27f9fd95c17d350e81a749591a4b0b0d89ab.png" alt="image-20230204203735474" style="zoom: 67%;">
<p>总的趋势是越来越多的人不再使用程序流程图了。</p>
<p>程序流程图的主要缺点如下。</p>
<p>(1) 程序流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。</p>
<p>(2) 程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。</p>
<p>(3) 程序流程图不易表示数据结构。</p>
<h3> 3.2 盒图(N-S图）</h3>
<p>出于要有一种不允许违背结构程序设计精神的图形工具的考虑，Nassi和Shneiderman提出了盒图，又称为N-S图。它有下述特点。</p>
<p>(1) 功能域(即一个特定控制结构的作用域)明确，可以从盒图上一眼就看出来。</p>
<p>(2) 不可能任意转移控制。</p>
<p>(3) 很容易确定局部和全程数据的作用域。</p>
<p>(4) 很容易表现嵌套关系，也可以表示模块的层次结构。</p>
<p>图给出了结构化控制结构的盒图表示，也给出了调用子程序的盒图表示方法。其中</p>
<p>基本符号：(a) 顺序； (b) IF_THEN_ELSE型分支； (c) CASE型多分支； (d) 循环； (e) 调用子程序A</p>
<img src="https://article.biliimg.com/bfs/article/ea929a0fed215d23441ba625a079237f383e7c18.png" alt="image-20230204204704318" style="zoom:50%;">
<h3> 3.3 PAD图</h3>
<p>PAD是问题分析图(problem analysis diagram)的英文缩写，用二维树形结构的图来表示程序的控制流。</p>
<p>基本符号</p>
<p>(a) 顺序(先执行P1后执行P2)；</p>
<p>(b) 选择(IF C THEN P1 ELSE P2);</p>
<p>(c) CASE型多分支；</p>
<p>(d) WHILE型循环(WHILE C DO P);</p>
<p>(e) UNTIL型循环(REPEAT P UNTIL C)；</p>
<p>(f) 语句标号；</p>
<p>(g) 定义</p>
<figure><img src="https://article.biliimg.com/bfs/article/99ab14e9437efd42d67b4113e8e53ca15402a018.png" alt="image-20230204204838150" tabindex="0" loading="lazy"><figcaption>image-20230204204838150</figcaption></figure>
<p>PAD图的主要优点如下：</p>
<p>(1) 使用表示结构化控制结构的PAD符号所设计出来的程序必然是结构化程序。</p>
<p>(2) PAD图所描绘的程序结构十分清晰。</p>
<p>(3) 用PAD图表现程序逻辑，易读、易懂、易记。</p>
<p>(4) 容易将PAD图转换成高级语言源程序，这种转换可 用软</p>
<p>件工具自动完成，从而可省去人工编码的工作，有利于提高</p>
<p>软件可靠性和软件生产率。</p>
<p>(5) 即可用于表示程序逻辑，也可用于描绘数据结构。</p>
<p>(6) PAD图的符号支持自顶向下、逐步求精方法的使用。</p>
<h3> 3.4 判定表</h3>
<p>判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p>
<p>判定表由4部分组成</p>
<ul>
<li>左上部列出所有条件</li>
<li>左下部是所有可能做的动作</li>
<li>右上部是表示各种条件组合的一个矩阵</li>
<li>右下部是和每种条件组合相对应的动作</li>
</ul>
<p>判定表右半部的每一列实质上是一条规则，规定了与特定的条件组合相对应的动作。</p>
<blockquote>
<p>优点： 能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p>
<p>缺点： 1.含义无法一眼看出，需要有一个简短的学习过程。 2.当数据元素的值多于两个时，判定表的简洁程度也将下降。</p>
</blockquote>
<h3> 3.5 判定树</h3>
<p>判定树是判定表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。多年来判定树一直受到人们的重视，是一种比较常用的系统分析和设计的工具。</p>
<blockquote>
<p>优点： 它的形式简单，一眼就可以看出其含义，因此易于掌握和使用。</p>
<p>缺点： 简洁性不如判定表，数据元素的同一个值往往要重复写多遍，而且越接近树的叶端重复次数越多。</p>
</blockquote>
<p>画判定树时分枝的次序可能对最终画出的判定树的简洁程度有较大影响。</p>
<img src="https://article.biliimg.com/bfs/article/f6e4611cd547950f824ef7de947161eb673e04dc.png" alt="image-20230204205144308" style="zoom:50%;">
<p>利用判定表：</p>
<img src="https://article.biliimg.com/bfs/article/032f906938f95bd13dce97b48d420de9607efc18.png" alt="image-20230204205204841" style="zoom: 67%;">
<p>利用判定树：</p>
<img src="https://article.biliimg.com/bfs/article/8fd22aa4fab6a5ed782c41c291b18e3ff30219e1.png" alt="image-20230204205919544" style="zoom: 67%;">
<h3> 3.6 过程设计语言</h3>
<p>过程设计语言（PDL）也称为伪码。是用正文形式表示数据和处理过程的设计工具。</p>
<p>PDL有下述特点：</p>
<p>(1)关键字的固定语法，它提供了结构化控制结构、数据说明和模块化的特点。如，if…fi(或endif)等</p>
<p>(2) 自然语言的自由语法，它描述处理特点。</p>
<p>(3) 数据说明的手段。应该既包括简单的数据结构(例如纯量和数组)，又包括复杂的数据结构(例如，链表或层次的数据结构)。</p>
<p>(4) 模块定义和调用的技术，应该提供各种接口描述模式。</p>
<p>PDL有下述优点：</p>
<p>(1) 可以作为注释直接插在源程序中间。</p>
<p>(2) 可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的书写和编辑工作。</p>
<p>(3) 已经有自动处理PDL的程序存在，而且可以自动由PDL生成程序代码。</p>
<p>PDL的缺点是不如图形工具形象直观，描述复杂的条件组合与动作间的对应关系时，不如判定表清晰简单。</p>
<h2> 4.程序复杂程度的定量度量</h2>
<p>定量度量程序复杂程度的方法很有价值：</p>
<p>a) 把程序的复杂程度乘以适当常数即可估算出软件中错误的数量以及软件开发需要用的工作量，</p>
<p>b) 定量度量的结果可以用来比较两个不同的设计或两个不同算法的优劣；</p>
<p>c) 程序的定量的复杂程度可以作为模块规模的精确限度。</p>
<h3> 4.1 McCabe方法</h3>
<p>① <strong>流图</strong></p>
<p>McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，这样度量出的结果称为程序的环形复杂度。</p>
<p>流图实质上是“退化了的”程序流程图，描绘程序的控制流程，不表现对数据的具体操作以及分支或循环的具体条件。</p>
<p>一个圆代表一条或多条语句；一个顺序结构可以合并一个结点；流图中的箭头线称为边，代表控制流；在流图中一条边必须终止于一个结点</p>
<img src="https://article.biliimg.com/bfs/article/f8608faff5ad45e15868571bb4b7e50f25fbd6ff.png" alt="image-20230204210400846" style="zoom:80%;">
<p>由PDL翻译成的流图</p>
<img src="https://article.biliimg.com/bfs/article/2e19829ba41eaff1d880289e22e70de619de4d40.png" alt="image-20230204210526633" style="zoom:67%;">
<p>复合条件，就是在条件中包含了一个或多个布尔运算符(逻辑OR，AND，NAND，NOR)</p>
<img src="https://article.biliimg.com/bfs/article/d5d84502c96d105b018d3e8344a71e5bdf73e720.png" alt="image-20230204210550876" style="zoom:67%;">
<p>② <strong>计算环形复杂度的方法</strong></p>
<p>(1) 流图中线性无关的区域数等于环形复杂度。</p>
<p>(2) 流图G的环形复杂度V(G)=E-N+2,其中，E是流图中边的条数，N是结点数。</p>
<p>(3) 流图G的环形复杂度V(G)=P+1，其中，P是流图中判定结点的数目。</p>
<p>图6.17流图的环形复杂度为4。</p>
<p>③ <strong>环形复杂度的用途</strong></p>
<p>对测试难度的一种定量度量，也能对软件最终的可靠性给出某种预测。</p>
<p>实践表明，模块规模以V(G)≤10为宜</p>
<h3> 4.2 Halstead方法</h3>
<p>根据程序中运算符和操作数的总数来度量程序的复杂程度。     令N1为程序中运算符出现的总次数，N2为操作数出现的总次数，程序长度N定义为：</p>
<p>​                N=N1+N2</p>
<p>​    程序中使用的不同运算符(包括关键字)的个数n1，以及不同操作数(变量和常数)的个数n2。Halstead给出预测程序长度的公式如下：</p>
<p>​                 H=n1 log2 n1+n2 log2n2</p>
<p>多次验证都表明，预测的长度H与实际长度N非常接近。</p>
<p>Halstead还给出了预测程序中包含错误的个数的公式如下：E=N log2 (n1+n2)/3000</p>
<h2> 5.本章小结</h2>
<p>1.结构程序设计技术是进行详细设计的逻辑基础。</p>
<p>2.人机界面设计必须重视。</p>
<p>3.过程设计是详细设计阶段完成的主要工作。</p>
<p>4.在开发有清楚的层次结构时可采用面向数据结构的设计方法完成设计过程设计。</p>
<p>5.使用环形复杂度可以定量度量程序的复杂程度。</p>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">06 【软件测试】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/06.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/06.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 06 【软件测试】</h1>
<h2> 1.软件测试基础</h2>
<h3> 1.1 软件测试的目标</h3>
<p>G.Myers给出的关于测试的一些规则如下：</p>
<p>测试是为了发现程序中的错误而执行程序的过程。</p>
<p>好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。</p>
<p>成功的测试是发现了至今为止尚未发现的错误的测试。</p>
<p><strong>测试</strong>的正确定义是“为了发现程序中的错误而执行程序的过程”。应该认识到测试决不能证明程序是正确的。即使经过了最严格的测试之后，仍然可能还有没被发现的错误潜藏在程序中。另外，在综合测试阶段通常由其他人员组成测试小组来完成测试工作。</p>]]></summary>
    <content type="html"><![CDATA[<h1> 06 【软件测试】</h1>
<h2> 1.软件测试基础</h2>
<h3> 1.1 软件测试的目标</h3>
<p>G.Myers给出的关于测试的一些规则如下：</p>
<p>测试是为了发现程序中的错误而执行程序的过程。</p>
<p>好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。</p>
<p>成功的测试是发现了至今为止尚未发现的错误的测试。</p>
<p><strong>测试</strong>的正确定义是“为了发现程序中的错误而执行程序的过程”。应该认识到测试决不能证明程序是正确的。即使经过了最严格的测试之后，仍然可能还有没被发现的错误潜藏在程序中。另外，在综合测试阶段通常由其他人员组成测试小组来完成测试工作。</p>
<h3> 1.2  软件测试准则</h3>
<p>主要的软件测试准则如下：</p>
<p>所有测试都应该能追溯到用户需求；</p>
<p>应该远在测试开始之前就制定出测试计划；</p>
<p>把Pareto原理应用到软件测试中**；**</p>
<p>应该从“小规模”测试开始，并逐步进行“大规模”测试；</p>
<p>穷举测试是不可能的；</p>
<p>为了达到最佳的测试效果，应该由独立的第三方从事测试工作。</p>
<h3> 1.3 测试方法</h3>
<ul>
<li><strong>黑盒测试</strong>（又称功能测试）把程序看作一个黑盒子，完全不考虑程序的内部结构和处理过程。黑盒测试是在程序接口进行的测试，只检查程序功能是否能按照规格说明书的规定正常使用，程序是否能适当地接收输入数据并产生正确的输出信息，程序运行过程中能否保持外部信息（例如数据库或文件）的完整性。</li>
<li><strong>白盒测试</strong>（又称结构测试）是把程序看成装在一个透明的白盒子里，测试者完全知道程序的结构和处理算法。这种方法按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能按预定要求正确工作。</li>
</ul>
<h3> 1.4 测试步骤</h3>
<p>根据第4条测试准则，测试过程也必须分步骤进行，后一个步骤在逻辑上是前一个步骤的继续。
大型软件系统通常由若干个子系统组成，每个子系统又由许多模块组成，因此，大型软件系统的测试过程基本上由模块测试、子系统测试、系统测试、验收测试和平行运行等五个步骤组成。</p>
<ol>
<li>
<p>模块测试
在设计得好的软件系统中，每个模块完成一个清晰定义的子功能，而且这个子功能和同级其他模块的功能之间没有相互依赖关系。因此，有可能把每个模块作为一个单独的实体来测试，而且通常比较容易设计检验模块正确性的测试方案。
模块测试的目的是保证每个模块作为一个单元能正确运行，所以模块测试通常又称为<strong>单元测试</strong>。在这个测试步骤中所发现的往往是编码和详细设计的错误。</p>
</li>
<li>
<p>子系统测试
子系统测试是把经过单元测试的模块放在一起形成一个子系统来测试。模块相互间的协调和通信是这个测试过程中的主要问题，因此，<strong>这个步骤着重测试模块的接口</strong>。</p>
</li>
<li>
<p>系统测试
系统测试是把经过测试的子系统装配成一个完整的系统来测试。在这个过程中不仅应该发现设计和编码的错误，还应该验证系统确实能提供需求说明书中指定的功能，而且系统的动态特性也符合预定要求。在这个测试步骤中发现的往往是软件设计中的错误，也可能发现需求说明中的错误。</p>
<p>子系统测试和系统测试，都兼有检测和组装两重含义，通常称为<strong>集成测试</strong>。</p>
</li>
<li>
<p>验收测试</p>
<p>验收测试把软件系统作为单一的实体进行测试，测试内容与系统测试基本类似，但是它是在<strong>用户</strong>积极参与下进行的，而且可能主要使用实际数据(系统将来要处理的信息)进行测试。</p>
<p>验收测试的目的是验证系统确实能够满足用户的需要，<strong>在这个测试步骤中发现的往往是系统需求说明书中的错误</strong>。验收测试也称为<strong>确认测试</strong>。</p>
</li>
<li>
<p>平行运行</p>
<p>所谓<strong>平行运行</strong>就是同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。这样做的具体目的有如下几点。</p>
<p>(1) 可以在准生产环境中运行新系统而又不冒风险。</p>
<p>(2) 用户能有一段熟悉新系统的时间。</p>
<p>(3) 可以验证用户指南和使用手册之类的文档。</p>
<p>(4) 能够以准生产模式对新系统进行全负荷测试，可以用测试结果验证性能指标。</p>
</li>
</ol>
<h3> 1.5 测试阶段的信息流</h3>
<img src="https://article.biliimg.com/bfs/article/b0988c36e27a324924fac89e18555b90edc9435c.png" alt="image-20230205233615124" style="zoom:50%;">
<p>上图描绘了测试阶段的信息流，这个阶段的输入信息有两类： (1)软件配置，包括需求说明书、设计说明书和源程序清单等； (2)测试配置，包括测试计划和测试方案。</p>
<p><strong>测试方案</strong>不仅仅是测试时使用的输入数据(称为测试用例)，还应该包括每组输入数据预定要检验的功能，以及每组输入数据预期应该得到的正确输出。</p>
<p>测试配置是软件配置的一个子集，最终交出的软件配置应该包括上述测试配置以及测试的实际结果和调试的记录。</p>
<p>比较测试得出的实际结果和预期的结果，如果两者不一致则很可能是程序中有错误。</p>
<p>如果经常出现要求修改设计的严重错误，那么软件的质量和可靠性是值得怀疑的，应该进一步仔细测试。</p>
<p>如果看起来软件功能完成得很正常，遇到的错误也很容易改正，则仍然应该考虑两种可能：(1)软件的可靠性是可以接受的；(2)所进行的测试尚不足以发现严重的错误。</p>
<p>如果经过测试，一个错误也没有被发现，则很可能是因为对测试配置思考不充分，以致不能暴露软件中潜藏的错误。</p>
<p><strong>软件可靠性模型</strong>使用错误率数据估计将来出现错误的情况，并进而对软件可靠性进行预测。</p>
<h2> 2.单元测试</h2>
<p>单元测试集中检测软件设计的最小单元——模块。</p>
<p>单元测试和编码属于软件过程的同一个阶段。</p>
<p>在源程序代码通过编译程序的语法检查后，可以用详细设计描述作指南，对重要的执行通路进行测试，以便发现模块内部的错误。</p>
<p>可以应用人工测试和计算机测试这样两种不同类型的测试方法，完成单元测试工作。</p>
<p>单元测试主要使用白盒测试技术，而且对多个模块的测试可以并行地进行。</p>
<h3> 2.1 测试重点</h3>
<p>在单元测试期间着重从以下5个方面对模块进行测试。</p>
<p><strong>1.模块接口</strong></p>
<p>对模块接口进行测试时主要检查以下几个方面：</p>
<ul>
<li>参数的数目、次序、属性或单位系统与变元是否一致；</li>
<li>是否修改了只作输入用的变元；</li>
<li>全局变量的定义和用法在各个模块中是否一致。</li>
</ul>
<p><strong>2.局部数据结构</strong></p>
<p>对于模块来说，局部数据结构是常见的错误来源。应该仔细设计测试方案，以便发现局部数据说明、初始化、默认值等方面的错误。</p>
<p><strong>3.重要的执行通路</strong></p>
<p>由于通常不可能进行穷尽测试，因此，在单元测试期间选择最有代表性、最可能发现错误的执行通路进行测试是十分关键的。应该设计测试方案用来发现由于错误的计算、不正确的比较或不适当的控制流而造成的错误。</p>
<p><strong>4.出错处理通路</strong></p>
<p>好的设计应该能预见出现错误的条件，并且设置适当的处理错误的通路。不仅应该在程序中包含出错处理通路，而且应该认真测试这种通路。评价出错处理通路应该着重测试下述一些可能发生的错误。</p>
<p>(1) 对错误的描述是难以理解的；</p>
<p>(2) 记下的错误与实际遇到的错误不同；</p>
<p>(3) 在对错误进行处理之前，错误条件已经引起系统干预；</p>
<p>(4) 对错误的处理不正确；</p>
<p>(5) 描述错误的信息不足以帮助确定造成错误的位置。</p>
<p><strong>5.边界条件</strong></p>
<p>边界测试是单元测试中最后的也可能是最重要的任务。</p>
<p>软件常常在它的边界上失效，例如，处理n元数组的第n个元素时，或做到i次循环中的第i次重复时，往往会发生错误。</p>
<p>使用刚好小于、刚好等于和刚好大于最大值或最小值的数据结构、控制量和数据值的测试方案，非常可能发现软件中的错误。</p>
<h3> 2.2 代码审查</h3>
<p><strong>代码检查</strong>是指由审查小组正式对源程序进行人工测试。它是一种非常有效的程序验证技术，对于典型的程序来说，可以查出30%～70%的逻辑设计错误和编码错误。审查小组最好由下述4人组成。</p>
<p>(1) 组长，应该是一个很有能力的程序员，而且没有直接参与这项工程；</p>
<p>(2) 程序的设计者；</p>
<p>(3) 程序的编写者；</p>
<p>(4) 程序的测试者。</p>
<p>在审查会上由程序的编写者解释他是怎样用程序代码实现设计的，通常是逐个语句地讲述程序的逻辑，小组其他成员仔细倾听他的讲解，并力图发现其中的错误。</p>
<p>审查会上需要对照程序设计常见错误清单，分析审查这个程序。当发现错误时由组长记录下来，审查会继续进行(<strong>审查小组的任务是发现错误而不是改正错误</strong>)。</p>
<p>审查会另外一种常见的进行方法，称为<strong>预排</strong>：由一个人扮演“测试者”，其他人扮演“计算机”。会前测试者准备好测试方案，会上由扮演计算机的成员模拟计算机执行被测试的程序。</p>
<p>测试方案在代码审查中起一种促进思考引起讨论的作用。在大多数情况下，通过向程序员提出关于他的程序的逻辑和他编写程序时所做的假设的疑问，可以发现的错误比由测试方案直接发现的错误还多。</p>
<p>代码审查比计算机测试优越的是：一次审查会上可以发现许多错误；用计算机测试的方法发现错误之后，通常需要先改正这个错误才能继续测试，即：采用代码审查的方法可以减少系统验证的总工作量。</p>
<p>人工测试和计算机测试是互相补充，相辅相成的，缺少其中任何一种方法都会使查找错误的效率降低。</p>
<h3> 2.3 计算机测试</h3>
<p>模块不是一个独立的程序，因此必须为每个单元测试开发驱动软件和(或)存根软件。</p>
<p>驱动程序是一个“主程序”，它接收测试数据，把这些数据传送给被测试的模块，并且印出有关的结果。</p>
<p>存根程序代替被测试的模块所调用的模块，它使用被它代替的模块的接口，可能做最少量的数据操作，印出对入口的检验或操作结果，并且把控制归还给调用它的模块。</p>
<p>​    右图是一个正文加工系统的部分层次图，假定要测试编号为3.0的关键模块——正文编辑模块。正文编辑模块不是一个独立的程序，需要有一个测试驱动程序来调用它。这个驱动程序说明必要的变量，接收测试数据——字符串，设置正文编辑模块的编辑功能。并且需要有存根程序简化地模拟正文编辑模块的下层模块来完成具体的编辑功能。</p>
<img src="https://article.biliimg.com/bfs/article/f4cfdae7bd733e435817a8422eecbbf7513a5f51.png" alt="image-20230206221801286" style="zoom: 50%;">
<h2> 3.集成测试</h2>
<p>集成测试是测试和组装软件的系统化技术。</p>
<p>由模块组装成程序时有两种方法。<strong>一种方法</strong>是先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，这种方法称为<strong>非渐增式测试方法</strong>；另一种方法是把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为<strong>渐增式测试</strong>，这种方法实际上同时完成单元测试和集成测试。</p>
<p><strong>非渐增式测试</strong>把所有模块放在一起，作为一个整体来测试。测试时会遇到许多的错误，改正错误非常困难，因为在庞大的程序中想要诊断定位一个错误非常困难，而且改正一个错误之后，马上又会遇到新的错误，这个过程会继续下去，没有尽头。</p>
<p><strong>渐增式测试</strong>与“一步到位”的非渐增式测试相反，它把程序划分成小段来构造和测试，在这个过程中比较容易定位和改正错误；对接口可以进行更彻底的测试；可以使用系统化的测试方法。因此，目前在进行集成测试时普遍采用渐增式测试方法。</p>
<p>当使用渐增方式把模块结合到程序中去时，有<strong>自顶向下</strong>和 <strong>自底向上</strong>两种集成策略。</p>
<h3> 3.1 自顶向下集成</h3>
<p><strong>自顶向下集成方法</strong>是从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来。在把附属于（及最终附属于）主控制模块的那些模块组装到程序结构中去时，或者使用深度优先的策略，或者使用宽度优先的策略。</p>
<p><strong>深度优先的结合方法</strong>先组装在软件结构的一条主控制通路上的所有模块。选择一条主控制通路取决于应用的特点，并且有很大任意性。</p>
<p><strong>宽度优先的结合方法</strong>是沿软件结构水平地移动，把处于同一个控制层次上的所有模块组装起来。</p>
<p>如右图，<strong>使用深度优先的结合方法</strong>，选取左通路，首先结合模块M1,M2和M5；其次，M8或M6(如果为了使M2具有适当功能需要M6)将被结合进来。然后构造中央的和右侧的控制通路。<strong>使用宽度优先的结合方法</strong>，首先结合模块M2,M3和M4(代替存根程序S4)，然后结合下一个控制层次中的模块M5,M6和M7；如此继续进行下去，直到所有模块都被结合进来为止。</p>
<img src="https://article.biliimg.com/bfs/article/3acac6e558887ae293f8203d373b871a4cd892e5.png" alt="image-20230206223359539" style="zoom:50%;">
<p>模块结合进软件结构的具体过程由下述4个步骤完成：</p>
<p><strong>①</strong> 对主控制模块进行测试，测试时用存根程序代替所有直接附属于主控制模块的模块；</p>
<p><strong>②</strong> 根据选定的结合策略(深度优先或宽度优先)，每次用一个实际模块代换一个存根程序(新结合进来的模块往往又需要新的存根程序)；</p>
<p><strong>③</strong> 在结合进一个模块的同时进行测试；</p>
<p><strong>④</strong> 为了保证加入模块没有引进新的错误，可能需要进行回归测试(即全部或部分地重复以前做过的测试)。</p>
<p>从<strong>②</strong>开始不断地重复进行上述过程，直到构造起完整的软件结构为止。</p>
<p><strong>自顶向下</strong>的结合策略能够在测试的早期对主要的控制或关键的抉择进行检验。在一个分解得好的软件结构中，关键的抉择位于层次系统的较上层，因此首先碰到。</p>
<p>如果选择<strong>深度优先</strong>的结合方法，可以在早期实现软件的一个完整的功能并且验证这个功能。</p>
<p>在自顶向下测试的初期，存根程序代替了低层次的模块，因此，在软件结构中没有重要的数据自下往上流。为了解决这个问题，测试人员有两种选择：①把许多测试推迟到用真实模块代替了存根程序以后再进行；②从层次系统的底部向上组装软件。</p>
<h3> 3.2 自底向上集成</h3>
<p><strong>自底向上测试</strong>从“原子”模块(即在软件结构最低层的模块)开始组装和测试。因为是从底部向上结合模块，总能得到所需的下层模块处理功能，所以不需要存根程序。</p>
<p>用下述步骤可以实现自底向上的结合策略。</p>
<p><strong>①</strong> 把低层模块组合成实现某个特定的软件子功能的族；</p>
<p><strong>②</strong> 写一个驱动程序(用于测试的控制程序)，协调测试数据的输入和输出；</p>
<p><strong>③</strong> 对由模块组成的子功能族进行测试；</p>
<p><strong>④</strong> 去掉驱动程序，沿软件结构自下向上移动，把子功能族组合起来形成更大的子功能族。</p>
<p>上述第<strong>②～④</strong>步实质上构成了一个循环。</p>
<p>右图描绘了自底向上的结合过程。首先把模块组合成族1、族2和族3，使用驱动程序(图中用虚线方框表示)对每个子功能族进行测试。族1和族2中的模块附属于模块Ma,去掉驱动程序D1和D2，把这两个族直接同Ma连接起来。类似地，在和模块Mb结合之前去掉族3的驱动程序D3。最终Ma和Mb这两个模块都与模块Mc结合起来。随着结合向上移动，对测试驱动程序的需要减少了。</p>
<img src="https://article.biliimg.com/bfs/article/3bee25a2a1c576f676281803741abdf1f65b7e86.png" alt="image-20230206223642135" style="zoom:50%;">
<h3> 3.3 不同集成测试策略的比较</h3>
<ul>
<li>
<p><strong>自顶向下测试方法</strong>的<strong>主要优点</strong>是不需要测试驱动程序，能够在测试阶段的早期实现并验证系统的主要功能，而且能在早期发现上层模块的接口错误。</p>
</li>
<li>
<p><strong>自顶向下</strong>测试方法<strong>的</strong>主要缺点<strong>是需要存根程序，可能遇到与此相联系的测试困难，低层关键模块中的错误发现较晚，而且用这种方法在早期不能充分展开人力。</strong></p>
</li>
<li>
<p>自底向上测试方法的优缺点与上述自顶向下测试方法的优缺点刚好相反。</p>
<p>一般说来，纯粹自顶向下或纯粹自底向上的策略可能都不实用，人们在实践中创造出许多混合策略。</p>
<p>(1) <strong>改进的自顶向下测试方法</strong>。基本上使用自顶向下的测试方法，但是在早期使用自底向上的方法测试软件中的少数关键模块。一般的自顶向下方法所具有的优点在这种方法中也都有，而且能在测试的早期发现关键模块中的错误；但是，它的缺点也比自顶向下方法多一条，即测试关键模块时需要驱动程序。</p>
<p>(2) <strong>混合法</strong>。对软件结构中较上层使用的自顶向下方法与对软件结构中较下层使用的自底向上方法相结合。这种方法兼有两种方法的优点和缺点，当被测试的软件中关键模块比较多时，这种混合法可能是最好的折衷方法。</p>
</li>
</ul>
<h3> 3.4 回归测试</h3>
<ul>
<li>
<p>在集成测试过程中，每当一个新模块结合进来时，程序就发生了变化：建立了新的数据流路径，可能出现了新的I/O操作，激活了新的控制逻辑。在集成测试的范畴中，<strong>回归测试</strong>是指重新执行已经做过的测试的某个子集，以保证上述这些变化没有带来非预期的副作用。</p>
</li>
<li>
<p><strong>回归测试</strong>就是用于保证由于调试或其他原因引起的变化，不会导致非预期的软件行为或额外错误的测试活动。</p>
</li>
<li>
<p><strong>回归测试</strong>可以通过人工地进行，也可以使用自动化的捕获回放工具自动进行。利用捕获回放工具，软件工程师能够捕获测试用例和实际运行结果，然后可以回放（即重新执行测试用例），并且比较软件变化前后所得到的运行结果。</p>
<p>回归测试集（已执行过的测试用例的子集）包括下述3类不同的测试用例。</p>
<p><strong>(1)</strong> 检测软件全部功能的代表性测试用例。</p>
<p><strong>(2)</strong> 专门针对可能受修改影响的软件功能的附加测试。</p>
<p><strong>(3)</strong> 针对被修改过的软件成分的测试。</p>
<p>在集成测试过程中，回归测试用例的数量可能变得非常大。因此，应该把回归测试集设计成只包括可以检测程序每个主要功能中的一类或多类错误的那样一些测试用例。</p>
</li>
</ul>
<h2> 4.确认测试</h2>
<ul>
<li><strong>确认测试</strong>也称为验收测试，它的目标是<strong>验证</strong>软件的有效性。</li>
<li>通常，<strong>验证</strong>指的是保证软件正确地实现了某个特定要求的一系列活动；<strong>确认</strong>指的是为了保证软件确实满足了用户需求而进行的一系列活动。</li>
<li><strong>软件有效性</strong>的一个简单定义是：如果软件的功能和性能如同用户所合理期待的那样，软件就是有效的。</li>
<li>需求分析阶段产生的软件需求规格说明书，准确地描述了用户对软件的合理期望，因此是软件有效性的标准，也是进行确认测试的基础。</li>
</ul>
<h3> 4.1 确认测试的范围</h3>
<p>确认测试必须有用户积极参与，或以用户为主进行。用户应该参与设计测试方案，使用用户界面输入测试数据并且分析评价测试的输出结果。</p>
<p>确认测试通常使用黑盒测试法。应该仔细设计测试计划和测试过程，测试计划包括要进行的测试的种类及进度安排，测试过程规定了用来检测软件是否与需求一致的测试方案。</p>
<p>通过测试和调试要保证软件能满足所有功能要求，能达到每个性能要求，文档资料是准确而完整的，此外，还应该保证软件能满足其他预定的要求（例如安全性、可移植性、兼容性和可维护性等）。</p>
<p>确认测试有下述两种可能的结果:</p>
<p>(1) 功能和性能与用户要求一致，软件是可以接受的。</p>
<p>(2) 功能和性能与用户要求有差距。</p>
<h3> 4.2 软件配置复查</h3>
<p><strong>软件配置复查</strong>是确认测试的一个重要内容。复查的目的是保证软件配置的所有成分都齐全，质量符合要求，文档与程序完全一致，具有完成软件维护所必须的细节，而且已经编好目录。</p>
<p>除了按合同规定的内容和要求，由人工审查软件配置之外，在确认测试过程中还应该严格遵循用户指南及其他操作程序，以便检验这些使用手册的完整性和正确性。必须仔细记录发现的遗漏或错误，并且适当地补充和改正。</p>
<h3> 4.3 Alpha和Beta测试</h3>
<p>如果一个软件是为许多客户开发的（例如，向大众公开出售的盒装软件产品），那么绝大多数软件开发商都使用被称为<strong>Alpha测试</strong>和<strong>Beta测试</strong>的过程，来发现那些看起来只有最终用户才能发现的错误。</p>
<ul>
<li><strong>Alpha测试</strong>由用户在开发者的场所进行，并且在开发者对用户的“指导”下进行测试。开发者负责记录发现的错误和使用中遇到的问题。</li>
<li><strong>Alpha测试</strong>是在受控的环境中进行的。</li>
<li><strong>Beta测试</strong>由软件的最终用户们在一个或多个客户场所进行。与Alpha测试不同，开发者通常不在Beta测试的现场。</li>
<li><strong>Beta测试</strong>是软件在开发者不能控制的环境中的“真实”应用。</li>
</ul>
<h2> 5.白盒测试技术</h2>
<ul>
<li>通常把测试数据和预期的输出结果称为<strong>测试用例</strong>。</li>
<li>不同的测试数据发现程序错误的能力差别很大，为了提高测试效率降低测试成本，应该选用高效的测试数据。因为不可能进行穷尽的测试，所以选用少量“最有效的”测试数据，做到尽可能完备的测试就更重要了。</li>
<li>设计测试方案的基本目标是，确定一组最可能发现某个错误或某类错误的测试数据。已经研究出许多设计测试数据的技术，这些技术各有优缺点；同一种技术在不同的应用场合效果可能相差很大，因此，通常需要联合使用多种设计测试数据的技术。</li>
</ul>
<h3> 5.1 逻辑覆盖</h3>
<p>逻辑覆盖是对一系列测试过程的总称，这组测试过程逐渐进行越来越完整的通路测试。</p>
<h4> 语句覆盖</h4>
<p>​    语句覆盖的含义是，选择足够多的测试数据，使被测程序中每个语句至少执行一次。</p>
<p>右图为被测试模块的流程图为了使每个语句都执行一次，程序的执行路径应该是sacbed,为此只需要输入下面的测试数据(实际上X可以是任意实数)：A=2，B=0，X=4。</p>
<img src="https://article.biliimg.com/bfs/article/33250072f4aa4fea5ba555a094906139bec8cc51.png" alt="image-20230207172557197" style="zoom: 67%;">
<p>语句覆盖对程序的逻辑覆盖很少，在上面例子中两个判定条件都只测试了条件为真的情况，如果条件为假时处理有错误，显然不能发现。</p>
<p>语句覆盖只关心判定表达式的值，而没有分别测试判定表达式中每个条件取不同值时的情况。为了执行sacbed路径，以测试每个语句，只需两个判定表达式(A&gt;1)AND(B=0)和(A=2)OR(X&gt;1)都取真值，因此使用上述一组测试数据就够了。但是，如果程序中把第一个判定表达式中的逻辑运算符AND错写成OR，或把第二个判定表达式中的条件X&gt;1误写成X&lt;1，使用上面的测试数据并不能查出这些错误。</p>
<p>综上所述，可以看出语句覆盖是很弱的逻辑覆盖标准。</p>
<h4> 判定覆盖</h4>
<p><strong>判定覆盖</strong>又叫分支覆盖，它的含义是，不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次，也就是每个判定的每个分支都至少执行一次。</p>
<p>对于上述例子来说，能够分别覆盖路径sacbed和sabd的两组测试数据，或者可以分别覆盖路径sacbd和sabed的两组测试数据，都满足判定覆盖标准。例如，以下两组测试数据就可做到判定覆盖：</p>
<p>① A=3，B=0，X=3 (覆盖sacbd)</p>
<p>② A=2，B=1，X=1 (覆盖sabed)</p>
<p>判定覆盖比语句覆盖强，但是对程序逻辑的覆盖程度仍然不高，例如，上面的测试数据只覆盖了程序全部路径的一半。</p>
<h4> 条件覆盖</h4>
<p><strong>条件覆盖</strong>的含义是，不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取到各种可能的结果。</p>
<p>上例中共有两个判定表达式，每个表达式中有两个条件，为了做到条件覆盖，应该选取测试数据满足下面的要求。</p>
<p>在a点有下述各种结果出现：</p>
<p>A&gt;1,A≤1,B=0,B≠0；</p>
<p>在b点有下述各种结果出现：</p>
<p>A=2,A≠2,X&gt;1,X≤1；</p>
<img src="https://article.biliimg.com/bfs/article/b2d80639c0374d5da0f2eb3dc9da335478e98a53.png" alt="image-20230207174557909" style="zoom: 67%;">
<p>只需要使用下面两组测试数据就可以达到上述覆盖标准：</p>
<p>① A=2,B=0,X=4(满足A&gt;1,B=0,A=2和X&gt;1，执行路径sacbed)</p>
<p>② A=1,B=1,X=1(满足A≤1,B≠0,A≠2和X≤1，执行路径sabd)</p>
<p>条件覆盖通常比判定覆盖强，但满足条件覆盖的测试数据不一定满足判定覆盖。例如，上面两组测试数据也同时满足判定覆盖标准。但是，如果使用下面两组测试数据，则只满足条件覆盖标准并不满足判定覆盖标准(第二个判定表达式的值总为真)：</p>
<p>① A=2,B=0,X=1(满足A&gt;1,B=0,A=2和X≤1，执行路径sacbed)</p>
<p>② A=1,B=1,X=2(满足A≤1,B≠0,A≠2和X&gt;1，执行路径sabed)</p>
<h4> 判定/条件覆盖</h4>
<p><strong>判定/条件覆盖</strong>是一种能同时满足判定覆盖和条件覆盖的逻辑覆盖，它的含义是，选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果。
对于上例而言，下述两组测试数据满足判定/条件覆盖标准：
① A=2,B=0,X=4
② A=1,B=1,X=1
但是，这两组测试数据也就是为了满足条件覆盖标准最初选取的两组数据，因此，有时判定/条件覆盖也并不比条件覆盖更强。</p>
<h4> 条件组合覆盖</h4>
<p>​    <strong>条件</strong>组合覆盖是更强的逻辑覆盖标准，它要求选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。</p>
<p>对于上例，共有8种可能的条件组合，它们分别是：</p>
<p>(1) A&gt;1,B=0   (2) A&gt;1,B≠0</p>
<p>(3) A≤1,B=0  (4) A≤1,B≠0</p>
<p>(5) A=2,X&gt;1   (6) A=2,X≤1</p>
<p>(7) A≠2,X&gt;1  (8) A≠2,X≤1</p>
<img src="https://article.biliimg.com/bfs/article/b2d80639c0374d5da0f2eb3dc9da335478e98a53.png" alt="image-20230207205952862" style="zoom:67%;">
<p>下面的4组测试数据使上面列出的8种条件组合每种至少出现一次：</p>
<p>① A=2,B=0,X=4(针对（1）和（5），执行路径sacbed)</p>
<p>② A=2,B=1,X=1(针对（2）和（6），执行路径sabed)</p>
<p>③ A=1,B=0,X=2(针对（3）和（7），执行路径sabed)</p>
<p>④ A=1,B=1,X=1(针对（4）和（8），执行路径sabd)</p>
<p>显然，满足条件组合覆盖标准的测试数据，也一定满足判定覆盖、条件覆盖和判定/条件覆盖标准。因此，条件组合覆盖是前述几种覆盖标准中最强的。但是，满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到，例如，上述4组测试数据都没有测试到路径sacbd。</p>
<h4> 点覆盖</h4>
<p>​    从对程序路径的覆盖程度分析，能够提出下述一些主要的逻辑覆盖标准。</p>
<p>图论中<strong>点覆盖</strong>的定义如下：如果连通图G的子图G′是连通的，而且包含G的所有结点，则称G′是G的点覆盖。</p>
<p>在正常情况下流图是连通的有向图。满足点覆盖标准要求选取足够多的测试数据，使得程序执行路径至少经过流图的每个结点一次，由于流图的每个结点与一条或多条语句相对应，显然，<strong>点覆盖标准和语句覆盖标准是相同的</strong>。</p>
<h4> 边覆盖和路径覆盖</h4>
<p>​    图论中<strong>边覆盖</strong>的定义是：如果连通图G的子图G″是连通的，而且包含G的所有边，则称G″是G的边覆盖。为了满足边覆盖的测试标准，要求选取足够多测试数据，使得程序执行路径至少经过流图中每条边一次。<strong>通常边覆盖和判定覆盖是一致的。</strong></p>
<p><strong>路径覆盖</strong>的含义是，选取足够多测试数据，使程序的每条可能路径都至少执行一次(如果程序图中有环，则要求每个环至少经过一次)。</p>
<h3> 5.2 控制结构测试</h3>
<p><strong>基本路径测试</strong>是Tom McCabe提出的一种白盒测试技术。使用基本路径测试设计测试用例时，首先计算程序的环形复杂度，并用该复杂度为指南定义执行路径的基本集合，从该基本集合导出的测试用例可以保证程序中的每条语句至少执行一次，而且每个条件在执行时都将分别取真、假两种值。</p>
<p>使用基本路径测试技术设计测试用例的步骤如下。</p>
<p><strong>①</strong> <strong>根据过程设计结果画出相应的流图。</strong></p>
<p>例如，为了用基本路径测试技术测试下列的用PDL描述的求平均值过程，首先画出下图所示的流图。注意，为了正确地画出流图，这里把被映射为流图结点的PDL语句编了序号。</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 基本路径测试</h4>
<img src="https://article.biliimg.com/bfs/article/3925befe0764257f93a94fda13107811cda1cd32.png" alt="image-20230207210232054" style="zoom:50%;">
<p><strong>②</strong> <strong>计算流图的环形复杂度。</strong></p>
<p>环形复杂度定量度量程序的逻辑复杂性。使用第6.5.1小节讲述的3种方法之一计算环形复杂度。经计算，流图的环形复杂度为6。</p>
<p><strong>③</strong> <strong>确定线性独立路径的基本集合。</strong></p>
<p>独立路径是指至少引入程序的一个新处理语句集合或一个新条件的路径，即独立路径至少包含一条在定义该路径之前不曾用过的边。</p>
<p>程序的环形复杂度决定了程序中独立路径的数量，而且这个数是确保程序中所有语句至少被执行一次所需的测试数量的上界。</p>
<p>上述程序的环形复杂度为6，因此共有6条独立路径。</p>
<p>路径1： 1-2-10-11-13    路径2： 1-2-10-12-13</p>
<p>路径3： 1-2-3-10-11-13    路径4： 1-2-3-4-5-8-9-2-…</p>
<p>路径5： 1-2-3-4-5-6-8-9-2-…</p>
<p>路径6： 1-2-3-4-5-6-7-8-9-2-…</p>
<p><strong>④</strong> <strong>设计可强制执行基本集合中每条路径的测试用例。</strong></p>
<p>应该选取测试数据使得在测试每条路径时都适当地设置好各个判定结点的条件。测试第③步得出的基本集合的测试用例如下。</p>
<p><strong>路径1</strong>的测试用例：</p>
<p>value［k］=有效输入值，其中k&lt;i(i的定义在下面)</p>
<p>value［i］=-999,其中2≤i≤100</p>
<p>预期结果：基于k的正确平均值和总数</p>
<p>注意，路径1无法独立测试，必须作为路径4或5或6的一部分来测试。</p>
<p><strong>路径2</strong>的测试用例：</p>
<p>value［1］=-999</p>
<p>预期结果： average=-999,其他都保持初始值</p>
<p><strong>路径****3</strong>的测试用例：</p>
<p>试图处理101个或更多个值</p>
<p>前100个数值应该是有效输入值</p>
<p>预期结果：前100个数的平均值，总数为100</p>
<p><strong>注意</strong>，路径3无法独立测试，必须作为路径4或5或6的一部分来测试。</p>
<p><strong>路径4</strong>的测试用例：</p>
<p>value［i］=有效输入值，其中i&lt;100</p>
<p>value［k］&lt;minimum,其中k&lt;i</p>
<p>预期结果：基于k的正确平均值和总数</p>
<p><strong>路径5</strong>的测试用例：</p>
<p>value［i］=有效输入值，其中i&lt;100</p>
<p>value［k］&gt;maximum，其中k&lt;i</p>
<p>预期结果：基于k的正确平均值和总数</p>
<p><strong>路径6</strong>的测试用例：</p>
<p>value［i］=有效输入值，其中i&lt;100</p>
<p>预期结果：正确的平均值和总数</p>
<p>在测试过程中，执行每个测试用例并把实际输出结果与预期结果相比较。一旦执行完所有测试用例，就可以确保程序中所有语句都至少被执行了一次，而且每个条件都分别取过true值和false值。</p>
<p><strong>注意</strong>，某些独立路径（例如，本例中的路径1和路径3）不能以独立的方式测试，例如，为了执行本例中的路径1，需要满足条件total.valid&gt;0。在这种情况下，这些路径必须作为另一个路径的一部分来测试。</p>
<h4> 条件测试</h4>
<p>用<strong>条件测试技术</strong>设计出的测试用例，能够检查程序模块中包含的逻辑条件。一个简单条件是一个布尔变量或一个关系表达式，在布尔变量或关系表达式之前还可能有一个NOT（┐)算符。关系表达式的形式如下：</p>
<p><strong>E1&lt;关系算符&gt;E2</strong></p>
<p>其中，E1和E2是算术表达式，而&lt;关系算符&gt;是下列算符之一：&lt;，≤，=，≠，&gt;或≥。布尔算符有OR(|)，AND(&amp;)和NOT( ┐)。不包含关系表达式的条件称为布尔表达式。</p>
<p>因此，条件成分的类型包括布尔算符、布尔变量、布尔括弧（括住简单条件或复合条件）、关系算符及算术表达式。</p>
<p>如果条件不正确，则至少条件的一个成分不正确。因此，条件错误的类型有：布尔算符错、布尔变量错、布尔括弧错、关系算符错、算术表达式错。</p>
<p>​    条件测试方法着重测试程序中的每个条件。条件测试策略有两个优点： ①容易度量条件的测试覆盖率； ②程序内条件的测试覆盖率可指导附加测试的设计。</p>
<p>条件测试的目的不仅是检测程序条件中的错误，而且是检测程序中的其他错误。如果程序P的测试集能有效地检测P中条件的错误，则它很可能也可以有效地检测P中的其他错误。</p>
<p>在分支测试、域测试等条件测试技术的基础上，K.C.Tai提出了一种被称为<strong>BRO(branch and relational operator)测试的条件测试策略</strong>。如果在条件中所有布尔变量和关系算符都只出现一次而且没有公共变量，则BRO测试保证能发现该条件中的分支错和关系算符错。</p>
<p>BRO测试利用条件C的条件约束来设计测试用例。包含n个简单条件的条件C的条件约束定义为（D1，D2，…，Dn），其中Di(0&lt;i≤n)表示条件C中第i个简单条件的输出约束。如果在条件C的一次执行过程中，C中每个简单条件的输出都满足D中对应的约束，则称C的这次执行覆盖了C的条件约束D。</p>
<p>对于布尔变量B来说，B的输出约束指出，B必须是真(t)或假(f)。类似地，对于关系表达式来说，用符号&gt;,=和&lt;指定表达式的输出约束。</p>
<p>​      <strong>作为第一个例子，考虑下列条件: C1：B1 &amp; B2</strong></p>
<p>其中，B1和B2是布尔变量。C1的条件约束形式为（D1，D2），其中D1和D2中的每一个都是t或f。值（t,f）是C1的一个条件约束，并由使B1值为真B2值为假的测试所覆盖。BRO测试策略要求，约束集{(t,t),(f,t),</p>
<p>(t,f)}被C1的执行所覆盖。如果C1因布尔算符错误而不正确，则至少上述约束集中的一个约束将迫使C1失败。</p>
<p><strong>作为</strong>第二个例子，考虑下列条件**
C2：B1 &amp; (E3=E4)**</p>
<p>其中，B1是布尔变量，E3和E4是算术表达式。C2的条件约束形式为（D1，D2）,其中D1是t或f，D2是&gt;,=或&lt;。除了C2的第二个简单条件是关系表达式之外，C2和C1相同，因此，可以通过修改C1的约束集{(t,t),(f,t),(t,f)}得出C2的约束集。</p>
<p>注意，对于（E3=E4）来说，t意味=，而f意味着&lt;或&gt;，因此，分别用（t,=）和（f,=）替换(t,t)和(f,t)，并用(t,&lt;)和(t,&gt;)替换(t,f)，就得到C2的约束集{(t,=),(f,=),(t,&lt;),(t,&gt;)}。覆盖上述条件约束集的测试，保证可以发现C2中布尔算符和关系算符的错误。</p>
<p><strong>作为第三个例子，考虑下列条件</strong></p>
<p><strong>C3：（E1&gt;E2）&amp;(E3=E4)</strong>
其中，E1、E2、E3和E4是算术表达式。C3的条件约束形式为（D1，D2），而D1和D2的每一个都是&gt;,=或&lt;。除了C3的第一个简单条件是关系表达式之外，C3和C2相同，因此，可以通过修改C2的约束集得到C3的约束集，结果为：{(&gt;,=),(=,=),(&lt;,=),(&gt;,&lt;),(&gt;,&gt;)}覆盖上述条件约束集的测试，保证可以发现C3中关系算符的错误。</p>
<h4> 循环测试</h4>
<p><strong>循环测试</strong>是一种白盒测试技术，它专注于测试循环结构的有效性。在结构化的程序中通常只有3种循环，即简单循环、串接循环和嵌套循环。</p>
<img src="https://article.biliimg.com/bfs/article/0a5c98083a6c53675cebeea6dd9502123b567f89.png" alt="image-20230207211028033" style="zoom:50%;">
<p><strong>(1) 简单循环</strong></p>
<p>应该使用下列测试集来测试简单循环，其中n是允许通过循环的最大次数。</p>
<p>跳过循环。</p>
<p>只通过循环一次。</p>
<p>通过循环两次。</p>
<p>通过循环m次，其中m&lt;n-1。</p>
<p>通过循环n-1,n,n+1次。</p>
<p><strong>(2)</strong> <strong>嵌套循环</strong></p>
<p>如果把简单循环的测试方法直接应用到嵌套循环，测试数就会随嵌套层数的增加按几何级数增长，B.Beizer提出了一种能减少测试数的方法。跳过循环。</p>
<p>从最内层循环开始测试，把所有其他循环都设置为最小值。</p>
<p>对最内层循环使用简单循环测试方法，而使外层循环的迭代参数（例如，循环计数器）取最小值，并为越界值或非法值增加一些额外的测试。</p>
<p>由内向外，对下一个循环进行测试，但保持所有其他外层循环为最小值，其他嵌套循环为“典型”值。</p>
<p>继续进行下去，直到测试完所有循环。</p>
<p><strong>(3)</strong> <strong>串接循环</strong></p>
<p>如果串接循环的各个循环都彼此独立，则可以使用前述的测试简单循环的方法来测试串接循环。但是，如果两个循环串接，而且第一个循环的循环计数器值是第二个循环的初始值，则这两个循环并不是独立的。当循环不独立时，建议使用测试嵌套循环的方法来测试串接循环。</p>
<h2> 6.黑盒测试技术</h2>
<p>​     **黑盒测试着重测试软件功能。**黑盒测试并不能取代白盒测试，它是与白盒测试互补的测试方法，它很可能发现白盒测试不易发现的其他类型的错误。</p>
<p>黑盒测试力图发现下述类型的错误：</p>
<p>(1) 功能不正确或遗漏了功能；</p>
<p>(2) 界面错误；</p>
<p>(3) 数据结构错误或外部数据库访问错误；</p>
<p>(4) 性能错误；</p>
<p>(5) 初始化和终止错误。</p>
<p>​     白盒测试在测试过程的早期阶段进行，而黑盒测试主要用于测试过程的后期。设计黑盒测试方案时，应该考虑下述问题。</p>
<p>（1）怎样测试功能的有效性？</p>
<p>（2）哪些类型的输入可构成好测试用例？</p>
<p>（3）系统是否对特定的输入值特别敏感？</p>
<p>（4）怎样划定数据类的边界？</p>
<p>（5）系统能够承受什么样的数据率和数据量？</p>
<p>（6）数据的特定组合将对系统运行产生什么影响？</p>
<p>应用黑盒测试技术，能设计出满足下述标准的测试用例集。</p>
<p>（1）所设计出的测试用例能够减少为达到合理测试所需要设计的测试用例的总数。</p>
<p>（2）所设计出的测试用例能够告诉人们，是否存在某些类型的错误，而不是仅仅指出与特定测试相关的错误是否存在。</p>
<h3> 6.1 等价划分</h3>
<p>​    <strong>等价划分</strong>把程序的输入域划分成若干个数据类，据此导出测试用例。等价划分法力图设计出能发现若干类程序错误的测试用例，从而减少必须设计的测试用例的数目。</p>
<p>如果把所有可能的输入数据(有效的和无效的)划分成若干个等价类，则可以合理地做出下述假定：每类中的一个典型值在测试中的作用与这一类中所有其他值的作用相同。因此，可以从每个等价类中只取一组数据作为测试数据。这样选取的测试数据最有代表性，最可能发现程序中的错误。</p>
<p>使用等价划分法设计测试方案首先需要划分输入数据的等价类，为此需要研究程序的功能说明，从而确定输入数据的有效等价类和无效等价类。</p>
<p>​    划分等价类需要经验，下述的启发式规则可能有助于等价类划分。</p>
<p>(1) 如果规定了输入值的范围，则可划分出一个有效的等价类(输入值在此范围内)，两个无效的等价类(输入值小于最小值或大于最大值)。</p>
<p>(2) 如果规定了输入数据的个数，则类似地也可以划分出一个有效的等价类和两个无效的等价类。</p>
<p>(3) 如果规定了输入数据的一组值，而且程序对不同输入值做不同处理，则每个允许的输入值是一个有效的等价类，此外还有一个无效的等价类(任一个不允许的输入值)。</p>
<p>​    (4) 如果规定了输入数据必须遵循的规则，则可以划分出一个有效等价类(符合规则)和若干个无效等价类(从各种不同角度违反规则)。</p>
<p>(5) 如果规定了输入数据为整型，则可以划分出正整数、零和负整数3个有效类。</p>
<p>(6) 如果程序的处理对象是表格，则应该使用空表，以及含一项或多项的表。</p>
<p>划分出等价类以后，根据等价类设计测试方案时主要使用下面两个步骤。</p>
<p>(1) 设计一个新的测试方案以尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖为止。</p>
<p>(2) 设计一个新的测试方案，使它覆盖一个而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止。</p>
<p><strong>注意</strong>，通常程序发现一类错误后就不再检查是否还有其他错误，因此，应该使每个测试方案只覆盖一个无效的等价类。</p>
<h3> 6.2 边界值分析</h3>
<p>​    经验表明，<strong>处理边界情况时程序最容易发生错误</strong>。例如，许多程序错误出现在下标、纯量、数据结构和循环等等的边界附近。因此，设计使程序运行在边界情况附近的测试方案，暴露出程序错误的可能性更大一些。</p>
<p>使用<strong>边界值分析方法</strong>设计测试方案首先应该确定边界情况，通常输入等价类和输出等价类的边界。选取的测试数据应该刚好等于、刚刚小于和刚刚大于边界值。</p>
<p><strong>通常设计测试方案时总是联合使用等价划分和边界值分析两种技术</strong>。</p>
<h3> 6.3 错误推测</h3>
<p>​    <strong>错误推测法</strong>在很大程度上靠直觉和经验进行。它的基本想法是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</p>
<p>应该仔细分析程序规格说明书，注意找出其中遗漏或省略的部分，以便设计相应的测试方案，检测程序员对这些部分的处理是否正确。</p>
<p>经验表明，在一段程序中已经发现的错误数目往往和尚未发现的错误数成正比。例如，在IBM OS/370操作系统中，用户发现的全部错误的47%只与该系统4%的模块有关。因此，在进一步测试时要着重测试那些已发现了较多错误的程序段。</p>
<p>等价划分法和边界值分析法都只孤立地考虑各个输入数据的测试功效，而没有考虑多个输入数据的组合效应，可能会遗漏了输入数据易于出错的组合情况。</p>
<p><strong>选择输入组合</strong>的一个有效途径是利用判定表或判定树为工具，列出输入数据各种组合与程序应作的动作(及相应的输出结果)之间的对应关系，然后为判定表的每一列至少设计一个测试用例。</p>
<p><strong>选择输入组合</strong>的另一个有效途径是把计算机测试和人工检查代码结合起来。</p>
<h2> 7.调试</h2>
<p><strong>调试</strong>（也称为纠错）作为成功测试的后果出现，即调试是在测试发现错误之后排除错误的过程。</p>
<p>软件错误的外部表现和它的内在原因之间可能并没有明显的联系。<strong>调试</strong>就是把症状和原因联系起来的尚未被人深入认识的智力过程。</p>
<h3> 7.1 调试过程</h3>
<p>调试不是测试。</p>
<p>调试过程从执行一个测试用例开始，评估测试结果，如果发现实际结果与预期结果不一致，则这种不一致就是一个症状，它表明在软件中存在着隐藏的问题。调试过程试图找出产生症状的原因，以便改正错误。</p>
<p>​    调试过程总会有以下两种结果之一： ①找到了问题的原因并把问题改正和排除掉了； ②没找出问题的原因。在后一种情况下，调试人员可以猜想一个原因，并设计测试用例来验证这个假设，重复此过程直至找到原因并改正了错误。</p>
<img src="https://article.biliimg.com/bfs/article/ee7413c256d77cf76c80afd84fe5a4c2d12a3df1.png" alt="image-20230207211656481" style="zoom:50%;">
<p>调试工作如此困难，软件错误的下述特征也是相当重要的原因。</p>
<p>(1) 症状和产生症状的原因可能在程序中相距甚远，也就是说，症状可能出现在程序的一个部分，而实际的原因可能在与之相距很远的另一部分。紧耦合的程序结构更加剧了这种情况。</p>
<p>(2) 当改正了另一个错误之后，症状可能暂时消失了。</p>
<p>(3) 症状可能实际上并不是由错误引起的（例如，舍入误差）。</p>
<p>(4) 症状可能是由不易跟踪的人为错误引起的。</p>
<p>(5) 症状可能是由定时问题而不是由处理问题引起的。</p>
<p>(6) 可能很难重新产生完全一样的输入条件（例如，输入顺序不确 定的实时应用系统）。</p>
<p>(7) 症状可能时有时无，这种情况在硬件和软件紧密地耦合在一起的嵌入式系统中特别常见。</p>
<p>(8) 症状可能是由分布在许多任务中的原因引起的，这些任务运行在不同的处理机上。</p>
<h3> 7.2 调试途径</h3>
<p><strong>1.蛮干法</strong></p>
<p><strong>蛮干</strong>法**可能是寻找软件错误原因的最低效的方法。仅当所有其他方法都失败了的情况下，才应该使用这种方法。</p>
<p><strong>蛮干法</strong>按照“让计算机自己寻找错误”的策略，这种方法印出内存的内容，激活对运行过程的跟踪，并在程序中到处都写上WRITE（输出）语句，希望在这样生成的信息海洋的某个地方发现错误原因的线索。</p>
<p>在更多情况下这样做只会浪费时间和精力。在使用任何一种调试方法之前，必须首先进行周密的思考，必须有明确的目的，应该尽量减少无关信息的数量。</p>
<p><strong>2.回溯法</strong></p>
<p>l回溯是一种相当常用的调试方法，当调试小程序时这种方法是有效的。具体做法：从发现症状的地方开始，人工沿程序的控制流往回追踪分析源程序代码，直到找出错误原因为止。</p>
<p>l随着程序规模的扩大，应该回溯的路径数目变得越来越大，回溯法不适用于这种规模的程序。</p>
<p><strong>3.原因排错法</strong></p>
<p>对分查找法、归纳法和演绎法都属于原因排除法。</p>
<p><strong>对分查找法</strong>的基本思路是，如果已经知道每个变量在程序内若干个关键点的正确值，则可以用赋值语句或输入语句在程序中点附近“注入”这些变量的正确值，然后运行程序并检查所得到的输出。</p>
<p><strong>归纳法</strong>是从个别现象推断出一般性结论的思维方法。使用这种方法调试程序时，首先把和错误有关的数据组织起来进行分析，以便发现可能的错误原因。然后导出对错误原因的一个或多个假设，并利用已有的数据来证明或排除这些假设。</p>
<p><strong>演绎法</strong>从一般原理或前提出发，经过排除和精化的过程推导出结论。采用这种方法调试程序时，首先设想出所有可能的出错原因，然后试图用测试来排除每一个假设的原因。</p>
<h2> 8.软件可靠性</h2>
<h3> 8.1 基本概念</h3>
<p><strong>软件可靠性</strong>是程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。软件可靠性随着给定的时间间隔的加大而减少。</p>
<p>一般说来，对于任何其故障是可以修复的系统，都应该同时使用可靠性和可用性衡量它的优劣程度。</p>
<p><strong>软件可用性</strong>是程序在给定的时间点，按照规格说明书的规定，成功地运行的概率。</p>
<p><strong>可靠性和可用性之间的主要差别</strong>是，可靠性意味着在0到t这段时间间隔内系统没有失效，而可用性只意味着在时刻t，系统是正常运行的。</p>
<h2> 9.本章小结</h2>
<ol>
<li>
<p>实现包括编码和测试两个阶段。</p>
</li>
<li>
<p>高级程序设计语言较汇编语言有很多优点。</p>
</li>
<li>
<p>通常软件测试至少分为单元测试、集成测试和验收测试3个基本阶段。</p>
</li>
<li>
<p>软件测试不仅仅指利用计算机进行的测试，还包括人工进行的测试(例如，代码审查)。</p>
</li>
<li>
<p>白盒测试和黑盒测试是软件测试的两类基本方法，设计白盒测试方案的技术主要有，逻辑覆盖和控制结构测试；设计黑盒测试方案的技术主要有，等价划分、边界值分析和错误推测。</p>
</li>
<li>
<p>及时改正测试过程中发现的软件错误就是调试的任务。</p>
</li>
<li>
<p>程序中潜藏的错误的数目，直接决定了软件的可靠性。通过测试可以估算出程序中剩余的错误数。</p>
</li>
</ol>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">07 【面向对象方法学引论】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/07.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/07.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 07 【面向对象方法学引论】</h1>
<p>​     面向对象技术强调在软件开发过程中面向客观世界或问题域中的事物，采用人类在认识客观世界的过程中普遍运用的思维方法，直观、自然地描述客观世界中的有关事物。</p>
<p>面向对象的分析方法是利用面向对象的信息建模概念，如实体、关系、属性等，同时运用封装、继承、多态等机制来构造模拟现实系统的方法。</p>
<p>传统的结构化设计方法的基本点是面向过程，系统被分解成若干个过程。而面向对象的方法是采用构造模型的观点，在系统的开发过程中，各个步骤的共同的目标是建造一个问题域的模型。在面向对象的设计中，初始元素是对象，然后将具有共同特征的对象归纳成类，组织类之间的等级关系，构造类库。在应用时，在类库中选择相应的类。</p>]]></summary>
    <content type="html"><![CDATA[<h1> 07 【面向对象方法学引论】</h1>
<p>​     面向对象技术强调在软件开发过程中面向客观世界或问题域中的事物，采用人类在认识客观世界的过程中普遍运用的思维方法，直观、自然地描述客观世界中的有关事物。</p>
<p>面向对象的分析方法是利用面向对象的信息建模概念，如实体、关系、属性等，同时运用封装、继承、多态等机制来构造模拟现实系统的方法。</p>
<p>传统的结构化设计方法的基本点是面向过程，系统被分解成若干个过程。而面向对象的方法是采用构造模型的观点，在系统的开发过程中，各个步骤的共同的目标是建造一个问题域的模型。在面向对象的设计中，初始元素是对象，然后将具有共同特征的对象归纳成类，组织类之间的等级关系，构造类库。在应用时，在类库中选择相应的类。</p>
<h2> 1.面向对象方法学概述</h2>
<h3> 1.1 面向对象方法学的要点</h3>
<p><strong>面向对象方法学</strong>的要点面向对象方法学的出发点和基本原则，是尽可能模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程，也就是使描述问题的问题空间(也称为问题域)与实现解法的解空间(也称为求解域)在结构上尽可能一致。</p>
<p><strong>面向对象方法</strong>把对象作为由数据及可以施加在这些数据上的操作所构成的统一体。对象与传统的数据有本质区别，它不是被动地等待外界对它施加操作，相反，它是进行处理的主体。必须发消息请求对象主动地执行它的某些操作，处理它的私有数据，而不能从外界直接对它的私有数据进行操作。</p>
<p>面向对象方法具有下述4个要点：</p>
<p>(1) 面向对象的软件系统是由对象组成的，软件中的任何元素都是对象，复杂的软件对象由比较简单的对象组合而成。</p>
<p>(2) 把所有对象都划分成各种对象类(简称为类,class)，每个对象类都定义了一组数据和一组方法。数据用于表示对象的静态属性，是对象的状态信息。</p>
<p>(3) 按照子类(或称为派生类)与父类(或称为基类)的关系，把若干个对象类组成一个层次结构的系统(也称为类等级)。</p>
<p>(4) 对象彼此之间仅能通过传递消息互相联系。</p>
<h3> 1.2 面向对象方法学的优点</h3>
<p><strong>1.与人类习惯的思维方法一致</strong></p>
<p>面向对象的软件技术以对象为核心，用这种技术开发出的软件系统由对象组成。对象是由描述内部状态表示静态属性的数据，以及可以对这些数据施加的操作(对象的动态行为)，封装在一起所构成的统一体。</p>
<p>面向对象的设计方法基本原理是，使用现实世界的概念抽象地思考问题从而自然地解决问题。</p>
<p>面向对象方法学的基本原则是按照人类习惯的思维方法建立问题域的模型，开发出尽可能直观、自然地表现求解方法的软件系统。面向对象的软件系统中使用的对象，是对客观世界中实体的抽象。</p>
<p><strong>2.稳定性好</strong></p>
<p>面向对象的软件系统的结构是根据问题领域的模型建立起来的，而不是基于对系统应完成的功能的分解，所以，当对系统的功能需求变化时并不会引起软件结构的整体变化，往往仅需要作一些局部性的修改。由于现实世界中的实体是相对稳定的，因此，以对象为中心构造的软件系统也是比较<strong>稳定</strong>的。</p>
<p><strong>3.可重用性好</strong></p>
<p>对象固有的封装性和信息隐藏机制，使得对象的内部实现与外界隔离，具有较强的独立性。对象是比较理想的模块和可重用的软件成分。</p>
<p>面向对象的软件技术在利用可重用的软件成分构造新的软件系统时，有很大的灵活性。有两种方法可以重复使用一个对象类：一种方法是创建该类的实例，从而直接使用它；另一种方法是从它派生出一个满足当前需要的新类。</p>
<p><strong>4.较易开发大型软件产品</strong></p>
<p>​    用面向对象方法学开发软件时，构成软件系统的每个对象就像一个微型程序，有自己的数据、操作、功能和用途，因此，可以把一个大型软件产品分解成一系列本质上相互独立的小产品来处理，这就不仅降低了开发的技术难度，而且也使得对开发工作的管理比较容易。</p>
<p><strong>5.可维护性好</strong></p>
<p>(1) 面向对象的软件稳定性比较好。</p>
<p>(2) 面向对象的软件比较容易修改。</p>
<p>(3) 面向对象的软件比较容易理解。</p>
<p>(4) 易于测试和调试。</p>
<h2> 2.面向对象的概念</h2>
<h3> 2.1 对象</h3>
<p>​    面向对象方法学中的<strong>对象</strong>是由描述该对象属性的数据以及可以对这些数据施加的所有操作封装在一起构成的统一体。对象可以作的操作表示它的动态行为，在面向对象分析和面向对象设计中，通常把对象的操作称为服务或方法。</p>
<p><strong>1.对象的形象表示</strong></p>
<p>右图为对象的形象表示，形象地描绘了具有3个操作的对象。</p>
<img src="https://article.biliimg.com/bfs/article/7624c45c4faaceb0870bbaa8a97aaffff5713275.png" alt="image-20230209225418250" style="zoom: 67%;">
<p>一个对象很像一台录音机。实现对象操作的代码和数据是隐藏在对象内部的，一个对象好像是一个黑盒子，表示它内部状态的数据和实现各个操作的代码及局部数据，都被封装在这个黑盒子内部，在外面是看不见的，更不能从外面去访问或修改这些数据或代码。</p>
<p>使用对象时只需知道它向外界提供的接口形式而无须知道它的内部实现算法，不仅使得对象的使用变得非常简单、方便，而且具有很高的安全性和可靠性。</p>
<p>对象内部的数据只能通过对象的公有方法(如C++的公有成员函数)来访问或处理，这就保证了对这些数据的访问或处理，在任何时候都是使用统一的方法进行的。</p>
<p><strong>2.对象的定义</strong></p>
<p>​    人们从不同角度给出对象的不同定义如下:(含义相同)</p>
<p>(1) 定义1： 对象是具有相同状态的一组操作的集合。</p>
<p>这个定义主要是从面向对象程序设计的角度看“对象”。</p>
<p>(2) 定义2： 对象是对问题域中某个东西的抽象，这种抽象反映了系统保存有关这个东西的信息或与它交互的能力。也就是说，对象是对属性值和操作的封装。</p>
<p>这个定义着重从信息模拟的角度看待“对象”。</p>
<p>(3) 定义3： 对象∷=〈ID,MS,DS,MI〉。其中，ID是对象的标识或名字，MS是对象中的操作集合，DS是对象的数据结构，MI是对象受理的消息名集合(即对外接口)。</p>
<p>对象是封装了数据结构及可以施加在这些数据结构上的操作的封装体，这个封装体有可以唯一地标识它的名字，而且向外界提供一组服务(即公有的操作)。对象中的数据表示对象的状态，一个对象的状态只能由该对象的操作来改变。</p>
<p><strong>3.对象的特点</strong></p>
<p>对象有如下一些基本特点。
(1) <strong>以数据为中心</strong>。操作围绕对其数据所需要做的处理来设置，不设置与这些数据无关的操作，而且操作的结果往往与当时所处的状态(数据的值)有关。
(2) <strong>对象是主动的</strong>。它是进行处理的主体。不能从外部直接加工它的私有数据，必须通过它的公有接口向对象发消息，请求它执行它的某个操作，处理它的私有数据。
(3) <strong>实现了数据封装</strong>。对象好像是一只黑盒子，它的私有数据完全被封装在盒子内部，对外是隐藏的、不可见的，对私有数据的访问或处理只能通过公有的操作进行。</p>
<p>**(4) 本质上具有并行性。**对象是描述其内部状态的数据及可以对这些数据施加的全部操作的集合。不同对象各自独立地处理自身的数据，彼此通过发消息传递信息完成通信。</p>
<p>**(5) 模块独立性好。**对象内部各种元素彼此结合得很紧密，内聚性相当强。由于完成对象功能所需要的元素(数据和方法)基本上都被封装在对象内部，它与外界的联系自然就比较少，因此，对象之间的耦合通常比较松。</p>
<h3> 2.2 其他概念</h3>
<p><strong>1.类（class）</strong>
在面向对象的软件技术中，“<strong>类</strong>”就是对具有相同数据和相同操作的一组相似对象的定义，也就是说，类是对具有相同属性和行为的一个或多个对象的描述，通常在这种描述中也包括对怎样创建该类的新对象的说明。</p>
<p><strong>2.实例（instance）</strong>
<strong>实例</strong>就是由某个特定的类所描述的一个具体的对象。
“对象” 既可以指一个具体的对象，也可以泛指一般的对象，但是，“实例”必然是指一个具体的对象。</p>
<p><strong>3.消息（massage）</strong>
<strong>消息</strong>就是要求某个对象执行在定义它的那个类中所定义的某个操作的规格说明。通常，一个消息由接收消息的对象、消息选择符(也称为消息名) 、 零个或多个变元3部分组成。</p>
<p>例如，MyCircle是一个半径为4cm、圆心位于(100，200)的Circle类的对象，也就是Circle类的一个<strong>实例</strong>，当要求它以绿颜色在屏幕上显示自己时，在C++语言中应该向它发下列<strong>消息</strong>：</p>
<p>​       MyCircle.Show(GREEN)；</p>
<p>其中，MyCircle是接收消息的对象的名字,Show是消息选择符(即消息名)，圆括号内的GREEN是消息的变元。当MyCircle接收到这个消息后，将执行在Circle类中所定义的Show操作。</p>
<p><strong>4.方法（method）</strong>
<strong>方法</strong>就是对象所能执行的操作，也就是类中所定义的服务。方法描述了对象执行操作的算法，响应消息的方法。在C++语言中把方法称为成员函数。</p>
<p><strong>5.属性（attribute）</strong>
<strong>属性</strong>就是类中所定义的数据，它是对客观世界实体所具有的性质的抽象。类的每个实例都有自己特有的属性值。在C++语言中把属性称为数据成员。
例如，Circle类中定义的代表圆心坐标、半径、颜色等的数据成员，就是圆的属性。</p>
<p><strong>6.封装（encapsulation）</strong>
在面向对象的程序中，封装是指把数据和实现操作的代码集中起来放在对象内部。
对象具有封装性的条件如下：
(1) <strong>有一个清晰的边界</strong>。所有私有数据和实现操作的代码都被封装在这个边界内，从外面看不见更不能直接访问。
(2) <strong>有确定的接口（即协议）</strong>。这些接口就是对象可以接受的消息，只能通过向对象发送消息来使用它。
(3) <strong>受保护的内部实现</strong>。实现对象功能的细节（私有数据和代码）不能在定义该对象的类的范围外访问。
封装就是信息隐藏，通过封装对外界隐藏对象的实现细节。</p>
<p><strong>7.继承（inheritance）</strong>
在面向对象的软件技术中，继承是子类自动地共享基类中定义的数据和方法的机制。
面向对象软件技术把类组成一个层次结构的系统(类等级)：一个类的上层可以有父类，下层可以有子类。这种层次结构系统的一个重要性质是继承性，一个类直接继承其父类的全部描述(数据和操作)。</p>
<p>​    右图为实现继承机制的原理，图中以A、B两个类为例，其中B类是从A类派生出来的子类，它除了具有自己定义的特性(数据和操作)之外，还从父类A继承特性。</p>
<img src="https://article.biliimg.com/bfs/article/8fe06cfb80d74e00b10bca607e4b9b05604c74cf.png" alt="image-20230209231108834" style="zoom: 67%;">
<p>继承具有传递性，即一个类实际上继承了它所在的类等级中在它上层的全部基类的所有描述。</p>
<p>当类等级为树形结构时，类的继承是单继承；当允许一个类有多个父类时，类的继承是多重继承。多重继承的类可以组合多个父类的性质构成所需的性质，使用多重继承时要注意避免二义性。</p>
<p>当需要扩充原有的功能时，派生类的方法可以调用其基类的方法，并在此基础上增加必要的程序代码；当需要完全改变原有操作的算法时，可以在派生类中实现一个与基类方法同名而算法不同的方法；当需要增加新的功能时，可以在派生类中实现一个新的方法。</p>
<p>有了继承性可以用把已有的一般性的解加以具体化的办法，来达到软件重用的目的。</p>
<p><strong>8.多态性（polymorphism）</strong>
在面向对象的软件技术中，多态性是指子类对象可以像父类对象那样使用，同样的消息既可以发送给父类对象也可以发送给子类对象。即，在类等级的不同层次中可以共享(公用)一个行为(方法)的名字，然而不同层次中的每个类却各自按自己的需要来实现这个行为。
多态性机制不仅增加了面向对象软件系统的灵活性，进一步减少了信息冗余，而且显著提高了软件的可重用性和可扩充性。</p>
<p><strong>9.重载（overloading）</strong>
有两种重载：函数重载是指在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名字；运算符重载是指同一个运算符可以施加于不同类型的操作数上面。
重载进一步提高了面向对象系统的灵活性和可读性。</p>
<h2> 3.面向对象模型</h2>
<p>所谓<strong>模型</strong>，就是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义的书面描述。通常，模型由一组图示符号和组织这些符号的规则组成，利用它们来定义和描述问题域中的术语和概念。</p>
<p>模型可以帮助人们思考问题、定义术语、在选择术语时作出适当的假设，并且有助于保持定义和假设的一致性。</p>
<p>对于因过分复杂而不能直接理解的系统，特别需要建立模型，建模的目的主要是为了减少复杂性。</p>
<p>面向对象方法最基本的原则，是按照人们习惯的思维方式，用面向对象观点建立问题域的模型，开发出尽可能自然地表现求解方法的软件。</p>
<p>用面向对象方法开发软件，通常需要建立3种形式的模型，它们分别是描述系统数据结构的<strong>对象模型</strong>，描述系统控制结构的<strong>动态模型</strong>和描述系统功能的<strong>功能模型</strong>。</p>
<p>一个典型的软件系统使用数据结构(对象模型)，执行操作(动态模型)，并且完成数据值的变化(功能模型)。</p>
<p>对任何大系统来说，上述3种模型都是必不可少的。用面向对象方法开发软件，在任何情况下，对象模型始终都是最重要、最基本、最核心的。</p>
<p>在面向对象分析过程中，构造出完全独立于实现的应用域模型；在面向对象设计过程中，把求解域的结构逐渐加入到模型中；在实现阶段，把应用域和求解域的结构都编成程序代码并进行严格的测试验证。</p>
<h2> 4.对象模型</h2>
<p>对象模型表示静态的、结构化的系统的“数据”性质。它是对模拟客观世界实体的对象以及对象彼此间的关系的映射，描述了系统的静态结构。</p>
<p>对象模型为建立动态模型和功能模型，提供了实质性的框架。</p>
<p>建立对象模型，需要用适当的建模语言来表达模型，建模语言由记号（即模型中使用的符号）和使用记号的规则（语法、语义和语用）组成。</p>
<p>1997年11月，国际对象管理组织OMG批准把UML 1.1作为基于面向对象技术的标准建模语言。</p>
<p>通常，使用UML提供的类图来建立对象模型。</p>
<h3> 4.1 类图的基本符号</h3>
<p>​    类图描述类及类与类之间的静态关系。类图是一种静态模型，它是创建其他UML图的基础。一个系统可以由多张类图来描述，一个类也可以出现在几张类图中。</p>
<p><strong>1.定义类</strong></p>
<p>为类命名时应该遵守以下几条准则：</p>
<ul>
<li>使用标准术语；</li>
<li>使用具有确切含义的名词；</li>
<li>必要时用名词短语作名字。</li>
</ul>
<p>右图表示类的图形符号。</p>
<img src="https://article.biliimg.com/bfs/article/b4c5b8965235e25c17f6252c161a4225c8851852.png" alt="image-20230210163813044" style="zoom:50%;">
<p><strong>2.定义属性</strong></p>
<p>UML描述属性的语法格式如下：</p>
<p><strong>可见性属性名： 类型名=初值{性质串}</strong></p>
<p>属性的可见性（即可访问性）通常有下述3种：公有的(public)、私有的(private)和保护的(protected)，分别用加号(+)、减号(-)和井号(#)表示。<strong>注意，没有默认的可见性。</strong></p>
<p>属性名和类型名之间用冒号(:)分隔。类型名表示该属性的数据类型，它可以是基本数据类型，也可以是用户自定义的类型。</p>
<p>在创建类的实例时应给其属性赋值，如果给某个属性定义了初值，则该初值可作为创建实例时这个属性的默认值。类型名和初值之间用等号（=）隔开。</p>
<p>l用花括号括起来的性质串明确地列出该属性所有可能的取值。枚举类型的属性往往用性质串列出可以选用的枚举值，不同枚举值之间用逗号分隔。也可以用性质串说明属性的其他性质，例如，约束说明{只读}表明该属性是只读属性。</p>
<p>例如，“发货单”类的属性“管理员”，在UML类图中如下面描述：</p>
<p>-管理员：String=“未定”</p>
<p>类的属性中还可以有一种能被该类所有对象共享的属性，称为类的作用域属性，也称为类变量。类变量在类图中表示为带下划线的属性。</p>
<p>例如，发货单类的类变量“货单数”，用来统计发货单的总数，在该类所有对象中这个属性的值都是一样的，下面是对这个属性的描述：-货单数： Integer</p>
<p><strong>3.定义服务</strong></p>
<p>服务也就是操作，UML描述操作的语法格式如下：</p>
<p>​    <strong>可见性操作名（参数表）： 返回值类型{性质串}</strong></p>
<p>操作可见性的定义方法与属性相同（见(2)定义属性）。</p>
<p>参数表是用逗号分隔的形式参数的序列。描述一个参数的语法如下：</p>
<p>​	<strong>参数名： 类型名=默认值</strong></p>
<p>当操作的调用者未提供实在参数时，该参数就使用默认值。</p>
<p>与属性类似，在类中可定义类作用域操作，在类图中表示为带下划线的操作。这种操作只能存取本类的类作用域属性。</p>
<h3> 4.2 表示关系的符号</h3>
<p>类与类之间通常有关联、泛化(继承)、依赖和细化4种关系。</p>
<h4> 关联</h4>
<p><strong>关联</strong>表示两个类的对象之间存在某种语义上的联系。</p>
<p><strong>(1)</strong> <strong>普通关联</strong></p>
<p>​    只要在类与类之间存在连接关系就可以用普通关联表示。普通关联的图示符号是连接两个类之间的直线，如下图所示。</p>
<img src="https://article.biliimg.com/bfs/article/a14559ac5e6e35c6fb306211c4261f727a941e4b.png" alt="image-20230210164336539" style="zoom:80%;">
<p>​    关联是双向的，可在每一个方向上为关联起一个名字(也可不起名字)。为避免混淆，在名字前面（或后面）加一个表示关联方向的黑三角。</p>
<p>​    在表示关联的直线两端可以写上重数（multiplicity），它表示该类有多少个对象与对方的一个对象连接。重数的表示方法通常有：</p>
<p>​    如果图中未明确标出关联的重数，则默认重数是1。</p>
<p>上图表示，一个作家可以使用1到多台计算机，一台计算机可被0至多个作家使用。</p>
<img src="https://article.biliimg.com/bfs/article/924978e30bae55390e9b5ea79503410e3e6a17f5.png" alt="image-20230210164437762" style="zoom: 80%;">
<p><strong>(2)</strong> <strong>关联的角色</strong></p>
<p>在任何关联中都会涉及参与此关联的对象所扮演的角色（即起的作用），在某些情况下显式标明角色名有助于别人理解类图。</p>
<p>​    右图是一个递归关联（即一个类与它本身有关联关系）的例子。一个人与另一个人结婚，必然一个人扮演丈夫的角色，另一个人扮演妻子的角色。如果没有显式标出角色名，则意味着用类名作为角色名。</p>
<img src="https://article.biliimg.com/bfs/article/b8b69ca04ba626722766c244e940ea39aef4f225.png" alt="image-20230210164700975" style="zoom:50%;">
<p><strong>(3)</strong> <strong>限定关联</strong></p>
<p>​    <strong>限定关联</strong>通常用在一对多或多对多的关联关系中，可以把模型中的重数从一对多变成一对一，或从多对多简化成多对一。在类图中把限定词放在关联关系末端的一个小方框内。</p>
<img src="https://article.biliimg.com/bfs/article/6518928c4408cbf9e4a912d0bc7636d55a4daa16.png" alt="image-20230210164728099" style="zoom:67%;">
<p>​     上图利用限定词“文件名”表示了目录与文件之间的关系，可见，利用限定词把一对多关系简化成了一对一关系。</p>
<p>​    上图一个受限的关联限定提高了语义精确性，增强了查询能力。限定的语法表明，文件名在其目录内是唯一的。</p>
<p><strong>(4)</strong> <strong>关联类</strong></p>
<p>为了说明关联的性质，引入一个关联类来记录附加信息。关联中的每个连接与关联类的一个对象相联系。关联类通过一条虚线与关联连接。</p>
<p>关联类与一般的类一样，也有属性、操作和关联。</p>
<p>​    右图是一个电梯系统的类模型，队列就是电梯控制器类与电梯类的关联关系上的关联类。</p>
<p>一个电梯控制器控制着4台电梯，控制器和电梯之间的实际连接就有4个，每个连接都对应一个队列（对象），每个队列（对象）存储着来自控制器和电梯内部按钮的请求服务信息。</p>
<img src="https://article.biliimg.com/bfs/article/e25aa9462da6e339bbc7794b49c275a839c017f8.png" alt="image-20230210165317755" style="zoom:50%;">
<h4> 聚集</h4>
<p><strong>聚集</strong>也称为聚合，是关联的特例。聚集表示类与类之间的关系是整体与部分的关系。使用的“包含”、“组成”、“分为……部分”等字句，意味着存在聚集关系。有<strong>共享聚集</strong>和<strong>组合聚集</strong>两种特殊的聚集关系。</p>
<p><strong>(1)</strong> <strong>共享聚集</strong></p>
<p>如果在聚集关系中处于部分方的对象可同时参与多个处于整体方对象的构成，则该聚集称为<strong>共享聚集</strong>。下图中，一个课题组包含许多成员，每个成员又可以是另一个课题组的成员，则课题组和成员之间是共享聚集关系。一般聚集和共享聚集的关联关系用空心菱形表示。</p>
<img src="https://article.biliimg.com/bfs/article/9e7c23d8f28d78d6435cec21fd73023911635fb1.png" alt="image-20230210165404149">
<p><strong>(2)</strong> <strong>组合聚集</strong></p>
<p>如果部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也会随之消失（或失去存在价值了），则该聚集称为<strong>组合聚集</strong>（简称为组成）。</p>
<p>​    在屏幕上打开一个窗口，它就由文本框、列表框、按钮和菜单组成，一旦关闭了窗口，各个组成部分也同时消失，窗口和它的组成部分之间存在着组合聚集关系。右图是窗口的组成，组合聚集的组成关系用实心菱形表示。</p>
<img src="https://article.biliimg.com/bfs/article/510ab11c83290f3f1e1c984ab32517a2182ad4df.png" alt="image-20230210165421665" style="zoom: 67%;">
<h4> 泛化</h4>
<p><strong>(1)</strong> <strong>普通泛化</strong></p>
<p>​     右图下方的两个折角矩形是模型元素“笔记”的符号，其中的文字是注释，分别说明两个子类的操作drive的功能。</p>
<p>抽象类通常都具有抽象操作。抽象操作仅用来指定该类的所有子类应具有哪些行为。抽象操作的图示方法与抽象类相似，在操作标记后面跟随一个性质串{abstract}。</p>
<img src="https://article.biliimg.com/bfs/article/002643b6ae90d5834b4cc7839d148107187bef80.png" alt="image-20230210165448131" style="zoom: 67%;">
<p>与抽象类相反的类是具体类，具体类有自己的对象，并且该类的操作都有具体的实现方法。</p>
<p>​    当客户要求画一幅蓝图时，系统便通过蓝图与图形之间的关联（聚集）关系，由图形来完成画图工作，但是图形是抽象类，因此当涉及某种具体图形（如直线、圆等）时，便使用其相应子类中具体实现的draw功能完成绘图工作。</p>
<figure><img src="https://article.biliimg.com/bfs/article/deda18da3524ff4b05e4bf1dc7bca4498695702f.png" alt="image-20230210165759226" tabindex="0" loading="lazy"><figcaption>image-20230210165759226</figcaption></figure>
<p><strong>(2)</strong> <strong>受限泛化</strong></p>
<p>给泛化关系附加约束条件，以进一步说明该泛化关系的使用方法或扩充方法，这样的泛化关系称为受限泛化。预定义的约束有4种：<strong>多重</strong>、<strong>不相交</strong>、<strong>完全</strong>和<strong>不完全</strong>。这些约束都是语义约束。</p>
<p><strong>多重继承</strong>指的是，一个子类可以同时多次继承同一个上层基类，右图中的水陆两用类继承了两次交通工具类。</p>
<img src="https://article.biliimg.com/bfs/article/9c20038af9d06fe15e4acaf71f9b8744b3432912.png" alt="image-20230210165826165" style="zoom: 67%;">
<p><strong>(2)</strong> <strong>受限泛化</strong></p>
<p>与多重继承相反的是<strong>不相交继承</strong>，即一个子类不能多次继承同一个基类（这样的基类相当于C++语言中的虚基类）。如果图中没有指定{多重}约束，则是不相交继承，一般的继承都是不相交继承。</p>
<p><strong>完全继承</strong>指的是父类的所有子类都已在类图中穷举出来了，图示符号是指定{完全}约束。</p>
<p><strong>不完全继承</strong>与完全继承恰好相反，父类的子类并没有都穷举出来，随着对问题理解的深入，可不断补充和维护，这为日后系统的扩充和维护带来很大方便。不完全继承是一般情况下默认的继承关系。</p>
<h4> 依赖和细化</h4>
<p><strong>依赖关系</strong>描述两个模型元素（类、用例等）之间的语义连接关系： 其中一个模型元素是独立的，另一个模型元素不是独立的，它依赖于独立的模型元素，如果独立的模型元素改变了，将影响依赖于它的模型元素。</p>
<p>在UML的类图中，用带箭头的虚线连接有依赖关系的两个类，箭头指向独立的类。在虚线上可以带一个版类标签，具体说明依赖的种类。</p>
<figure><img src="https://article.biliimg.com/bfs/article/210e98b3061415ce2fa72f1d9fbf10c803392d95.png" alt="image-20230210165911834" tabindex="0" loading="lazy"><figcaption>image-20230210165911834</figcaption></figure>
<p>上图表示一个友元依赖关系，该关系使得B类的操作可以使用A类中私有的或保护的成员。</p>
<p><strong>(2)</strong> <strong>细化关系</strong></p>
<p>当对同一个事物在不同抽象层次上描述时，这些描述之间具有<strong>细化关系</strong>。</p>
<p>假设两个模型元素A和B描述同一个事物，它们的区别是抽象层次不同，如果B是在A的基础上的更详细的描述，则称B细化了A，或称A细化成了B。细化的图示符号为由元素B指向元素A的、一端为空心三角形的虚线（<strong>注意</strong>，不是实线），如下图所示。细化用来协调不同阶段模型之间的关系，表示各个开发阶段不同抽象层次的模型之间的相关性，常常用于跟踪模型的演变。</p>
<figure><img src="https://article.biliimg.com/bfs/article/fef1879614af1e7f90b62553d031dbea4b62f483.png" alt="image-20230210165932288" tabindex="0" loading="lazy"><figcaption>image-20230210165932288</figcaption></figure>
<h2> 5.动态模型</h2>
<p><strong>动态模型</strong>表示瞬时的、行为化的系统的“控制”性质，它规定了对象模型中的对象的合法变化序列。</p>
<p>所有对象都具有自己的生命周期（或称为运行周期）。生命周期中的阶段就是对象的状态。<strong>状态</strong>是对对象属性值的一种抽象。各对象之间相互触发（即作用）就形成了一系列的状态变化。人们把一个触发行为称作一个事件。对象对事件的响应，取决于接受该触发的对象当时所处的状态，响应包括改变自己的状态或者又形成一个新的触发行为。</p>
<p>状态有持续性，它占用一段时间间隔。状态与事件密不可分，一个事件分开两个状态，一个状态隔开两个事件。事件表示时刻，状态代表时间间隔。</p>
<p>通常，用UML提供的状态图来描绘对象的状态、触发状态转换的事件以及对象的行为（对事件的响应）。</p>
<p>每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件合并起来，从而构成系统的动态模型。也就是说，动态模型是基于事件共享而互相关联的一组状态图的集合。</p>
<h2> 6.功能模型</h2>
<p><strong>功能模型</strong>表示变化的系统的“功能”性质，它指明系统应该“做什么”，因此更直接地反映了用户对目标系统的需求。</p>
<p><strong>功能模型</strong>由一组数据流图组成。建立功能模型有助于软件开发人员更深入地理解问题域，改进和完善自己的设计。</p>
<p>UML提供的用例图是进行需求分析和建立功能模型的强有力工具。在UML中把用用例图建立起来的系统模型称为<strong>用例模型</strong>。</p>
<p>使用<strong>用例模型</strong>代替传统的功能说明，往往能够更好地获取用户需求，它所回答的问题是“系统应该为每个（或每类）用户做什么”。</p>
<p><strong>用例模型</strong>描述的是外部行为者(actor）所理解的系统功能。用例模型的建立是系统开发者和用户反复讨论的结果，它描述了开发者和用户对需求规格所达成的共识。</p>
<h3> 6.1 用例图</h3>
<p>一幅<strong>用例图</strong>包含的模型元素有系统、行为者、用例及用例之间的关系。右图是自动售货机系统的用例图。图中的方框代表系统，椭圆代表用例（售货、供货和取货款是自动售货机系统的典型用例），线条人代表行为者，它们之间的连线表示关系。</p>
<img src="https://article.biliimg.com/bfs/article/14a05a540cd39df72eb1dac21af9c1d88f2d4518.png" alt="image-20230210170114938" style="zoom:50%;">
<p><strong>1.系统</strong></p>
<p><strong>系统</strong>被看作是一个提供用例的黑盒子，内部如何工作、用例如何实现对于建立用例模型来说都是不重要的。</p>
<p>代表<strong>系统</strong>的方框的边线表示系统的边界，用于划定系统的功能范围，定义了系统所具有的功能。描述该系统功能的用例置于方框内，代表外部实体的行为者置于方框外。</p>
<p><strong>2.用例</strong></p>
<p>一个<strong>用例</strong>是可以被行为者感受到的、系统的一个完整的功能。在UML中把<strong>用例</strong>定义成系统完成的一系列动作，动作的结果能被特定的行为者察觉到。这些动作除了完成系统内部的计算与工作外，还包括与一些行为者的通信。用例通过<strong>关联</strong>与行为者连接，<strong>关联</strong>指出一个用例与哪些行为者交互，这种交互是双向的。</p>
<p>用例具有下述特征。</p>
<p>​	(1) 用例代表某些用户可见的功能，实现一个具体的用户目标。</p>
<p>​	(2) 用例总是被行为者启动的，并向行为者提供可识别的值。</p>
<p>​	(3) 用例必须是完整的。</p>
<p><strong>注意</strong>，用例是一个类，它代表一类功能而不是使用该功能的某个具体实例。用例的实例是系统的一种实际使用方法，通常把用例的实例称为<strong>脚本</strong>。脚本是系统的一次具体执行过程，例如，在自动售货机系统中，张三投入硬币购买矿泉水，系统收到钱后把矿泉水送出来，上述过程就是一个脚本；李四投币买可乐，但是可乐已卖完了，于是系统给出提示信息并把钱退还给李四，这个过程是另一个脚本。</p>
<p><strong>3.行为者</strong></p>
<p><strong>行为者</strong>是指与系统交互的人或其他系统，它代表外部实体。使用用例并且与系统交互的任何人或物都是行为者。</p>
<p><strong>行为者</strong>代表一种角色，而不是某个具体的人或物。一个具体的人可以充当多种不同角色。</p>
<p>在用例图中用直线连接行为者和用例，表示两者之间交换信息，称为<strong>通信联系</strong>。行为者触发(激活)用例，并与用例交换信息。单个行为者可与多个用例联系；一个用例也可与多个行为者联系。</p>
<p>可以把行为者分成主行为者和副行为者，还可分成主动行为者和被动行为者。</p>
<p><strong>4.用例之间的关系</strong></p>
<p>UML用例之间主要有<strong>扩展</strong>和<strong>使用</strong>两种关系，它们是泛化关系的两种不同形式。</p>
<p>(1) 扩展关系</p>
<p>向一个用例中添加一些动作后构成了另一个用例，这两个用例之间的关系就是扩展关系，后者继承前者的一些行为，通常把后者称为扩展用例。</p>
<p>(2) 使用关系</p>
<p>当一个用例使用另一个用例时，这两个用例之间就构成了使用关系。一般说来，如果在若干个用例中有某些相同的动作，则可以把这些相同的动作提取出来单独构成一个用例（称为抽象用例）。这样，当某个用例使用该抽象用例时，就好像这个用例包含了抽象用例中的所有动作。</p>
<p>右图为含扩展和使用关系的用例图。</p>
<img src="https://article.biliimg.com/bfs/article/fce698e64299d2ee7d0224c1347751c17f295c8c.png" alt="image-20230210171437946" style="zoom:50%;">
<p>​    <strong>注意扩展与使用之间的异同</strong>： 这两种关系都意味着从几个用例中抽取那些公共的行为并放入一个单独的用例中。通常在描述一般行为的变化时采用扩展关系；在两个或多个用例中出现重复描述又想避免这种重复时，可以采用使用关系。</p>
<h3> 6.2 用例建模</h3>
<p>​    一个<strong>用例模型</strong>由若干幅用例图组成。创建用例模型的工作包括：定义系统，寻找行为者和用例，描述用例，定义用例之间的关系，确认模型。其中，寻找行为者和用例是关键。</p>
<p><strong>1.寻找行为者</strong></p>
<p>​    为获取用例首先要找出系统的行为者，可通过请系统的用户回答一些问题来发现行为者。下述问题有助于发现行为者。</p>
<p>谁将使用系统的主要功能（主行为者）？</p>
<p>谁需要借助系统的支持来完成日常工作？</p>
<p>谁来维护和管理系统（副行为者）？</p>
<p>系统控制哪些硬件设备？</p>
<p>系统需要与哪些其他系统交互？</p>
<p>哪些人或系统对本系统产生的结果（值）感兴趣？</p>
<p><strong>2.寻找用例</strong></p>
<p>一旦找到了行为者，就可以通过请每个行为者回答下述问题来获取用例。</p>
<p>​	行为者需要系统提供哪些功能？行为者自身需要做什么？</p>
<p>​	行为者是否需要读取、创建、删除、修改或存储系统中的某类信息？</p>
<p>​	系统中发生的事件需要通知行为者吗？行为者需要通知系统某些事情吗？从功能观点看，这些事件能做什么？</p>
<p>​	行为者的日常工作是否因为系统的新功能而被简化或提高了效率？</p>
<p>还有一些不是针对具体行为者而是针对整个系统的问题，也能帮助建模者发现用例，例如：</p>
<p>​	系统需要哪些输入输出？输入来自何处？输出到哪里去？</p>
<p>​	当前使用的系统（可能是人工系统）存在的主要问题是什么？</p>
<p>注意，最后这两个问题并不意味着没有行为者也可以有用例，只是在获取用例时还不知道行为者是谁。事实上，<strong>一个用例必须至少与一个行为者相关联</strong>**。**</p>
<h2> 7.种模型之间的关系</h2>
<p><strong>功能模型</strong>指明了系统应该“做什么”；<strong>动态模型</strong>明确规定了什么时候(即在何种状态下接受了什么事件的触发)做；<strong>对象模型</strong>则定义了做事情的实体。</p>
<p>在面向对象方法学中，对象模型是最基本最重要的，它为其他两种模型奠定了基础，人们依靠对象模型完成3种模型的集成。下面扼要地叙述3种模型之间的关系。</p>
<p>​	针对每个类建立的动态模型，描述了类实例的生命周期或运行周期。</p>
<p>​	状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在用例图中被映射成用例，它们同时与类图中的服务相对应。</p>
<p>​	功能模型中的处理（或用例）对应于对象模型中的类所提供的服务。通常，复杂的处理（或用例）对应于复杂对象提供的服务，简单的处理（或用例）对应于更基本的对象提供的服务。有时一个处理（或用例）对应多个服务，也有一个服务对应多个处理（或用例）的时候。</p>
<p>​	数据流图中的数据存储，以及数据的源点/终点，通常是对象模型中的对象。</p>
<p>​	数据流图中的数据流，往往是对象模型中对象的属性值，也可能是整个对象。</p>
<p>​	用例图中的行为者，可能是对象模型中的对象。</p>
<p>​	功能模型中的处理（或用例）可能产生动态模型中的事件。</p>
<p>​	对象模型描述了数据流图中的数据流、数据存储以及数据源点/终点的结构。</p>
<h2> 8.本章小结</h2>
<ol>
<li>
<p>面向对象范型明显优于结构化范型，使用面向对象范型能够开发出稳定性好、可重用性好和可维护性好的软件。</p>
</li>
<li>
<p>面向对象方法学比较自然地模拟了人类认识客观世界的思维方式，在结构上尽可能一致。</p>
</li>
<li>
<p>系统中每个对象都属于一个特定的对象类。类是对具有相同属性和行为的一组相似对象的定义。按照子类、父类的关系，把众多的类进一步组织成一个层次系统，处于下一层次上的类可以自动继承位于上一层次的类的属性和行为。</p>
</li>
<li>
<p>用面向对象观点建立系统的模型，分别是描述系统静态结构的对象模型、描述系统控制结构的动态模型以及描述系统计算结构的功能模型。其中，对象模型是最基本、最核心、最重要的。</p>
</li>
<li>
<p>统一建模语言UML是国际对象管理组织OMG批准的基于面向对象技术的标准建模语言。使用UML的类图来建立对象模型，使用UML的状态图来建立动态模型，使用数据流图或UML的用例图来建立功能模型。在UML中把用用例图建立起来的系统模型称为用例模型。</p>
</li>
</ol>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">08 【面向对象分析】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/08.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/08.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 08 【面向对象分析】</h1>
<p>在面向对象分析中，主要由对象模型、动态模型和功能模型组成。</p>
<p>面向对象分析(OOA)的关键是识别出问题域内的类与对象，并分析它们相互间的关系，最终建立起问题域的简洁、精确、可理解的正确模型。在用面向对象观点建立起的3种模型中，对象模型是最基本、最重要、最核心的。</p>
<h2> 1.面向对象分析的基本过程</h2>
<h3> 1.1 概述</h3>
<p>​    面向对象分析，就是抽取和整理用户需求并建立问题域精确模型的过程。</p>
<p>​	面向对象分析过程从分析陈述用户需求的文件开始。</p>
<p>​	接下来，系统分析员应该深入理解用户需求，抽象出目标系统的本质属性，并用模型准确地表示出来。</p>]]></summary>
    <content type="html"><![CDATA[<h1> 08 【面向对象分析】</h1>
<p>在面向对象分析中，主要由对象模型、动态模型和功能模型组成。</p>
<p>面向对象分析(OOA)的关键是识别出问题域内的类与对象，并分析它们相互间的关系，最终建立起问题域的简洁、精确、可理解的正确模型。在用面向对象观点建立起的3种模型中，对象模型是最基本、最重要、最核心的。</p>
<h2> 1.面向对象分析的基本过程</h2>
<h3> 1.1 概述</h3>
<p>​    面向对象分析，就是抽取和整理用户需求并建立问题域精确模型的过程。</p>
<p>​	面向对象分析过程从分析陈述用户需求的文件开始。</p>
<p>​	接下来，系统分析员应该深入理解用户需求，抽象出目标系统的本质属性，并用模型准确地表示出来。</p>
<p>​	在面向对象建模的过程中，系统分析员必须认真向领域专家学习。</p>
<p>​	在面向对象建模的过程中，还应该仔细研究以前针对相同的或类似的问题域进行面向对象分析所得到的结果（可重用）。</p>
<h3> 1.2 3个模型与5个层次</h3>
<p>在面向对象分析中，主要由对象模型、动态模型和功能模型组成。对象模型是最基本、最重要、最核心的。</p>
<p>面向对象建模得到的模型包含系统的3个要素，即静态结构(对象模型)、交互次序(动态模型)和数据变换(功能模型)。解决的问题不同，这3个子模型的重要程度也不同。</p>
<p>复杂问题（大型系统）的对象模型通常由下述5个层次组成：</p>
<img src="https://article.biliimg.com/bfs/article/18fcb0490f0aef5a540b7bbb0bfb526809f01c6d.png" alt="image-20230210224235300" style="zoom: 50%;">
<p>现在再简要地介绍一下主题的概念。</p>
<p>主题是指导读者理解大型、复杂模型的一种机制。也就是说，通过划分主题把一个大型、复杂的对象模型分解成几个不同的概念范畴。</p>
<p>“读者”泛指所有需要读懂系统模型的人</p>
<img src="https://article.biliimg.com/bfs/article/3107d454684fb8c8b6f9594b53f5d3032295cb17.png" alt="image-20230210224309857" style="zoom:50%;">
<p>心理研究表明，人类的短期记忆能力一般限于一次记忆5～9个对象，这就是著名的7±2原则。面向对象分析从下述两个方面来体现这条原则：控制可见性和指导读者的注意力。</p>
<p>首先，面向对象分析通过控制读者能见到的层次数目来控制可见性。</p>
<p>其次，面向对象分析增加了一个主题层，它可以从一个相当高的层次描述总体模型，并对读者的注意力加以指导。</p>
<p>在概念上可以认为，面向对象分析大体上按照下列顺序进行：</p>
<p>寻找类与对象，识别结构，识别主题，定义属性，</p>
<p>建立动态模型，建立功能模型，定义服务。</p>
<p>但是，分析不可能严格地按照预定顺序进行，大型、复杂系统的模型需要反复构造多遍才能建成。</p>
<p>分析也不是一个机械的过程。系统分析员必须与领域专家及用户反复交流，以便澄清二义性，改正错误的概念，补足缺少的信息。</p>
<h2> 2.需求陈述</h2>
<h3> 2.1 书写要点</h3>
<p>需求陈述应该阐明“做什么”而不是“怎样做”！</p>
<p>​	应该描述用户的需求而不是提出解决问题的方法。</p>
<p>​	应该指出哪些是系统必要的性质，哪些是任选的性质。</p>
<p>​	应该避免对设计策略施加过多的约束，也不要描述系统的内部结构，因为这样做将限制实现的灵活性。</p>
<p>​	对系统性能及系统与外界环境交互协议进行描述。</p>
<p>​	对采用的软件工程标准、模块构造准则、将来可能做的扩充以及可维护性要求等方面进行描述。</p>
<p>​	书写需求陈述时，要尽力做到语法正确，而且应该慎重选用名词、动词、形容词和同义词。</p>
<p>​	系统分析员必须把需求与实现策略区分开。</p>
<p>​	应该看到，需求陈述仅仅是理解用户需求的出发点，它并不是一成不变的文档。</p>
<p>​	系统分析员必须与用户及领域专家密切配合协同工作，共同提炼和整理用户需求。</p>
<h3> 2.2 例子</h3>
<figure><img src="https://article.biliimg.com/bfs/article/62216c02b26544733cfd5eae5eb2d46665381e54.png" alt="image-20230210224851359" tabindex="0" loading="lazy"><figcaption>image-20230210224851359</figcaption></figure>
<p><strong>1.储户和柜员交互</strong></p>
<p>银行柜员使用柜员终端处理储户提交的储蓄事务。</p>
<p>​	储户可以用现金或支票向自己拥有的某个账户内存款或开新账户，也可以从自己的账户中取款。</p>
<p>​	柜员负责把储户提交的存款或取款事务输进柜员终端。</p>
<p>​	柜员终端与相应的分行计算机通信，分行计算机具体处理针对某个账户的事务并且维护账户。</p>
<p>​	接收储户交来的现金或支票，或付给储户现金。</p>
<p><strong>2.储户和ATM交互</strong></p>
<p>首先，ATM要求用户输入密码。</p>
<p>接下来ATM把从这张卡上读到的信息以及用户输入的密码传给中央计算机，请求中央计算机核对这些信息并处理这次事务。</p>
<p>中央计算机根据卡上的分行代码确定这次事务与分行的对应关系，并且委托相应的分行计算机验证用户密码。</p>
<p>用户输入的密码是正确的，ATM就要求用户选择事务类型(取款、查询等)。当用户选择取款时，ATM请求用户输入取款额。</p>
<p>最后，ATM从现金出口吐出现金，并且打印出账单交给用户。</p>
<h2> 3.建立对象模型</h2>
<p><strong>面向对象分析首要的工作，是建立问题域的对象模型。</strong></p>
<p>这个模型描述了现实世界中的“类与对象”以及它们之间的关系，表示了目标系统的静态数据结构。静态数据结构对应用细节依赖较少，比较容易确定。因此，用面向对象方法开发绝大多数软件时，都首先建立对象模型，然后再建立另外两个子模型。</p>
<p>需求陈述、应用领域的专业知识以及关于客观世界的常识，是建立对象模型时的主要信息来源。</p>
<p>对象模型通常有5个层次。典型的工作步骤是：</p>
<p>​	首先确定对象类和关联(因为它们影响系统整体结构和解决问题的方法)，对于大型复杂问题还要进一步划分出若干个主题；</p>
<p>​	然后给类和关联增添属性，以进一步描述它们；</p>
<p>​	接下来利用适当的继承关系进一步合并和组织类。</p>
<p>​	而对类中操作的最后确定，则需等到建立了动态模型和功能模型之后，因为这两个子模型更准确地描述了对类中提供的服务的需求。</p>
<h3> 3.1 确定类与对象</h3>
<p>类与对象是在问题域中客观存在的，系统分析员的主要任务就是通过分析找出这些类与对象。</p>
<p>​	首先找出所有候选的类与对象；</p>
<p>​	然后从候选的类与对象中筛选掉不正确的或不必要的。</p>
<p><strong>1. 找出候选的类与对象</strong></p>
<p>​    对象是对问题域中有意义的事物的抽象，它们既可能是物理实体，也可能是抽象概念。具体地说，大多数客观事物可分为下述5类。</p>
<p>(1) 可感知的物理实体，例如，飞机、汽车、书、房屋等。</p>
<p>(2) 人或组织的角色，例如，医生、教师、雇主、雇员、计算</p>
<p>机系、财务处等。</p>
<p>(3) 应该记忆的事件，例如，飞行、演出、访问、交通事故等。</p>
<p>(4) 两个或多个对象的相互作用，通常具有交易或接触的性质，</p>
<p>例如，购买、纳税、结婚等。</p>
<p>(5) 需要说明的概念，例如，政策、保险政策、版权法等。</p>
<p>另一种更简单的分析方法，是所谓的非正式分析。</p>
<p>​	用自然语言书写的需求陈述为依据，</p>
<p>​	把陈述中的名词作为类与对象的候选者，</p>
<p>​	用形容词作为确定属性的线索，</p>
<p>​	把动词作为服务(操作)的候选者。</p>
<p>当然，用这种简单方法确定的候选者是非常不准确的，其中往往包含大量不正确的或不必要的事物，还必须经过更进一步的严格筛选。通常，非正式分析是更详细、更精确的正式的面向对象分析的一个很好的开端。</p>
<p><strong>2.</strong> <strong>筛选出正确的类与对象</strong></p>
<p>​    显然，仅通过一个简单、机械的过程不可能正确地完成分析工作。非正式分析仅仅帮助人们找到一些候选的类与对象，接下来应该严格考察每个候选对象，从中去掉不正确的或不必要的，仅保留确实应该记录其信息或需要其提供服务的那些对象。</p>
<p>筛选时主要依据下列标准，删除不正确或不必要的类与对象。</p>
<p><strong>（1）冗余</strong></p>
<p>​    如果两个类表达了同样的信息，则应该保留在此问题域中最富于描述力的名称。</p>
<p>例如ATM系统，其中储户与用户，现金兑换卡与磁卡及副本分别描述了相同的两类信息，因此，应该去掉“用户”、“磁卡”、“副本”等冗余的类，仅保留“储户”和“现金兑换卡”这两个类。</p>
<p><strong>（2）无关</strong></p>
<p>​    现实世界中存在许多对象，不能把它们都纳入到系统中去，仅需要把与本问题密切相关的类与对象放进目标系统中。有些类在其他问题中可能很重要，但与当前要解决的问题无关，同样也应该把它们删掉。</p>
<p>以ATM系统为例，这个系统并不处理分摊软件开发成本的问题，而且ATM和柜员终端放置的地点与本软件的关系也不大。因此，应该去掉候选类“成本”、“市”、“街道”、“营业厅”和“储蓄所”。</p>
<p><strong>（3）笼统</strong></p>
<p>​    在需求陈述中常常使用一些笼统的、泛指的名词，虽然在初步分析时把它们作为候选的类与对象列出来了，但是，要么系统无须记忆有关它们的信息，要么在需求陈述中有更明确更具体的名词对应它们所暗示的事务，因此，通常把这些笼统的或模糊的类去掉。</p>
<p>以ATM系统为例，“银行”实际指总行或分行，“访问”在这里实际指事务，“信息”的具体内容在需求陈述中随后就指明了。总之，在本例中应该去掉“银行”、“网络”、“系统”、“软件”、“信息”、“访问”等候选类。</p>
<p><strong>（4）属性</strong></p>
<p>在需求陈述中有些名词实际上描述的是其他对象的属性，应该把这些名词从候选类与对象中去掉。当然，如果某个性质具有很强的独立性，则应把它作为类而不是作为属性。</p>
<p>以ATM系统为例，“现金”、“支票”、“取款额”、“账单”、“余额”、“分行代码”、“卡号”、“密码”、“类型”等，实际上都应该作为属性对待。</p>
<p><strong>（5）操作</strong></p>
<p>在需求陈述中有时可能使用一些既可作为名词，又可作为动词的词，应该慎重考虑它们在本问题中的含义，以便正确地决定把它们作为类还是作为类中定义的操作。</p>
<p>例如，谈到电话时通常把“拨号”当作动词，当构造电话模型时确实应该把它作为一个操作，而不是一个类。但是，在开发电话的自动记账系统时，“拨号”需要有自己的属性(例如日期、时间、受话地点等)，因此应该把它作为一个类。</p>
<p><strong>（6）实现</strong></p>
<p>​    在分析阶段不应该过早地考虑怎样实现目标系统。因此，应该去掉仅和实现有关的候选的类与对象。在设计和实现阶段，这些类与对象可能是重要的，但在分析阶段过早地考虑它们反而会分散人们的注意力。</p>
<p>​    在ATM系统的例子中，“事务日志”无非是对一系列事务的记录，它的确切表示方式是面向对象设计的议题；“通信链路”在逻辑上是一种联系，在系统实现时它是关联类的物理实现。总之，应该暂时去掉 “事务日志”和“通信链路”这两个类，在设计或实现时再考虑它们。</p>
<h3> 3.2 确定关联</h3>
<p>​    两个或多个对象之间的相互依赖、相互作用的关系就是关联。</p>
<p>​    分析确定关联，能促使分析员考虑问题域的边缘情况，有助于发现那些尚未被发现的类与对象。</p>
<p>​    在分析确定关联的过程中，不必花过多的精力去区分关联和聚集。事实上，聚集不过是一种特殊的关联，是关联的一个特例。</p>
<p><strong>1.</strong> <strong>初步确定关联</strong></p>
<p>在需求陈述中使用的描述性动词或动词词组，通常表示关联关系。</p>
<p>​	在初步确定关联时，大多数关联可以通过直接提取需求陈述中的动词词组而得出。</p>
<p>​	通过分析需求陈述，还能发现一些在陈述中隐含的关联。</p>
<p>​	最后，分析员还应该与用户及领域专家讨论问题域实体间的相互依赖、相互作用关系，根据领域知识再进一步补充一些关联。</p>
<p><strong>2.</strong> <strong>筛选</strong></p>
<p>​    经初步分析得出的关联只能作为候选的关联，还需经过进一步筛选，以去掉不正确的或不必要的关联。</p>
<p><strong>筛选时主要根据下述标准删除候选的关联。</strong></p>
<p><strong>(1) 已删去的类之间的关联</strong></p>
<p>如果在分析确定类与对象的过程中已经删掉了某个候选类，则与这个类有关的关联也应该删去，或用其他类重新表达这个关联。</p>
<p><strong>(2) 与问题无关的或应在实现阶段考虑的关联</strong></p>
<p>应该把处在本问题域之外的关联或与实现密切相关的关联删去。</p>
<p><strong>(3) 瞬时事件</strong></p>
<p>关联应该描述问题域的静态结构，而不应该是一个瞬时事件。</p>
<p><strong>(4) 三元关联</strong></p>
<p>三个或三个以上对象之间的关联，大多可以分解为二元关联或用词组描述成限定的关联。</p>
<p><strong>(5) 派生关联</strong></p>
<p>应该去掉那些可以用其他关联定义的冗余关联。</p>
<p><strong>3.</strong> <strong>进一步完善</strong></p>
<p>应该进一步完善经筛选后余下的关联。</p>
<p><strong>通常从下述几个方面进行改进</strong></p>
<p><strong>(1)</strong> <strong>正名</strong></p>
<p>好的名字是帮助读者理解的关键因素之一。因此，应该仔细选择含义更明确的名字作为关联名。</p>
<p><strong>(2) 分解</strong></p>
<p>为了能够适用于不同的关联，必要时应该分解以前确定的类与对象。</p>
<p><strong>(3) 补充</strong></p>
<p>发现了遗漏的关联就应该及时补上。</p>
<p><strong>(4) 表明重数</strong></p>
<p>应该初步判定各个关联的类型，并粗略地确定关联的重数。但是，无须为此花费过多精力，因为在分析过程中随着认识的逐渐深入，重数也会经常改动。</p>
<h3> 3.3 划分主题</h3>
<p>在开发大型、复杂系统的过程中，为了降低复杂程度，人们习惯于把系统再进一步划分成几个不同的主题，也就是在概念上把系统包含的内容分解成若干个范畴。</p>
<p>​	在开发很小的系统时，可能根本无须引入主题层；</p>
<p>​	对于含有较多对象的系统，则往往先识别出类与对象和关联，然后划分主题，并用它作为指导开发者和用户观察整个模型的一种机制；</p>
<p>​	对于规模极大的系统，则首先由高级分析员粗略地识别对象和关联，然后初步划分主题，经进一步分析，对系统结构有更深入的了解之后，再进一步修改和精炼主题。</p>
<p>​    应该按问题领域而不是用功能分解方法来确定主题。此外，应该按照使不同主题内的对象相互间依赖和交互最少的原则来确定主题。</p>
<h3> 3.4 确定属性</h3>
<p>属性是对象的性质，藉助于属性人们能对类与对象和结构有更深入更具体的认识。注意，在分析阶段不要用属性来表示对象间的关系，使用关联能够表示两个对象间的任何关系，而且把关系表示得更清晰、更醒目。</p>
<p>一般说来，确定属性的过程包括分析和选择两个步骤。</p>
<p><strong>1.分析</strong></p>
<p>​	通常，在需求陈述中用名词词组表示属性，例如，“汽车的颜色”或“光标的位置”。</p>
<p>​	往往用形容词表示可枚举的具体属性，例如，“红色的”、“打开的”。</p>
<p>但是，不可能在需求陈述中找到所有属性，分析员还必须藉助于领域知识和常识才能分析得出需要的属性。幸运的是，属性对问题域的基本结构影响很小。随着时间的推移，问题域中的类始终保持稳定，属性却可能改变了，相应地，类中方法的复杂程度也将改变。</p>
<p>​    属性的确定既与问题域有关，也和目标系统的任务有关。应该仅考虑与具体应用直接相关的属性，不要考虑那些超出所要解决的问题范围的属性。在分析过程中应该首先找出最重要的属性，以后再逐渐把其余属性增添进去。在分析阶段不要考虑那些纯粹用于实现的属性。</p>
<p><strong>2.选择</strong></p>
<p>认真考察经初步分析而确定下来的那些属性，从中删掉不正确的或不必要的属性。通常有以下几种常见情况:</p>
<p><strong>(1)</strong> <strong>误把对象当作属性</strong></p>
<p>如果某个实体的独立存在比它的值更重要，则应把它作为一个对象而不是对象的属性。在具体应用领域中具有自身性质的实体，必然是对象。同一个实体在不同应用领域中，到底应该作为对象还是属性，需要具体分析才能确定。例如，在邮政目录中，“城市”是一个属性，而在人口普查中却应该把“城市”当作对象。</p>
<p><strong>(2) 误把关联类的属性当作一般对象的属性</strong></p>
<p>如果某个性质依赖于某个关联链的存在，则该性质是关联类的属性，在分析阶段不应该把它作为一般对象的属性。特别是在多对多关联中，关联类属性很明显，即使在以后的开发阶段中，也不能把它归并成相互关联的两个对象中任一个的属性。</p>
<p><strong>(3) 把限定误当成属性</strong></p>
<p>正如9.4.2节所述，正确使用限定词往往可以减少关联的重数。如果把某个属性值固定下来以后能减少关联的重数，则应该考虑把这个属性重新表述成一个限定词。在ATM系统的例子中，“分行代码”、“账号”、“雇员号”、“站号”等都是限定词。</p>
<p><strong>(4) 误把内部状态当成了属性</strong></p>
<p>如果某个性质是对象的非公开的内部状态，则应该从对象模型中删掉这个属性。</p>
<p><strong>(5) 过于细化</strong></p>
<p>在分析阶段应该忽略那些对大多数操作都没有影响的属性。</p>
<p><strong>(6) 存在不一致的属性</strong></p>
<p>类应该是简单而且一致的。如果得出一些看起来与其他属性毫不相关的属性，则应该考虑把该类分解成两个不同的类。</p>
<h3> 3.5 识别继承关系</h3>
<p>​    确定了类中应该定义的属性之后，就可以利用继承机制共享公共性质，并对系统中众多的类加以组织。正如以前曾经强调指出过的，继承关系的建立实质上是知识抽取过程，它应该反映出一定深度的领域知识，因此必须有领域专家密切配合才能完成。通常，许多归纳关系都是根据客观世界现有的分类模式建立起来的，只要可能，就应该使用现有的概念。</p>
<p>一般说来，可以使用两种方式建立继承(即泛化)关系。</p>
<p><strong>(1)</strong> <strong>自底向上：</strong></p>
<p>​    抽象出现有类的共同性质泛化出父类，这个过程实质上模拟了人类归纳思维过程。</p>
<p><strong>(2) 自顶向下：</strong></p>
<p>​    把现有类细化成更具体的子类，这模拟了人类的演绎思维过程。从应用域中常常能明显看出应该做的自顶向下的具体化工作。</p>
<h3> 3.6 反复修改</h3>
<p>​    仅仅经过一次建模过程很难得到完全正确的对象模型。事实上，软件开发过程就是一个多次反复修改、逐步完善的过程。在建模的任何一个步骤中，如果发现了模型的缺陷，都必须返回到前期阶段进行修改。</p>
<p>​    由于面向对象的概念和符号在整个开发过程中都是一致的，因此远比使用结构分析、设计技术更容易实现反复修改、逐步完善的过程。</p>
<p>​    实际上，有些细化工作(例如定义服务)是在建立了动态模型和功能模型之后才进行的。</p>
<h2> 4.建立动态模型</h2>
<p>第一步，是编写典型交互行为的脚本。虽然脚本中不可能包括每个偶然事件，但是，至少必须保证不遗漏常见的交互行为。</p>
<p>第二步，从脚本中提取出事件，确定触发每个事件的动作对象以及接受事件的目标对象。</p>
<p>第三步，排列事件发生的次序，确定每个对象可能有的状态及状态间的转换关系，并用状态图描绘它们。</p>
<p>最后，比较各个对象的状态图，检查它们之间的一致性，确保事件之间的匹配。</p>
<h3> 4.1 编写脚本</h3>
<p>​    在建立动态模型的过程中，脚本是指系统在某一执行期间内出现的一系列事件。脚本描述用户(或其他外部设备)与目标系统之间的一个或多个典型的交互过程（事件序列），以便对目标系统的行为有更具体的认识。</p>
<p>​    目的保证不遗漏重要的交互步骤，有助于确保整个交互过程的正确性和清晰性。</p>
<p>​    脚本描写的范围并不是固定的，既可以包括系统中发生的全部事件，也可以只包括由某些特定对象触发的事件。脚本描写的范围主要由编写脚本的具体目的决定。</p>
<p>​    即使在需求陈述中已经描写了完整的交互过程，也还需要花很大精力构思交互的形式。</p>
<p>​    因此，编写脚本的过程，实质上就是分析用户对系统交互行为的要求的过程。在编写脚本的过程中，需要与用户充分交换意见，编写后还应该经过他们审查与修改。</p>
<p>编写脚本时，</p>
<p>​	首先编写正常情况的脚本。</p>
<p>​	然后，考虑特殊情况，例如输入或输出的数据为最大值(或最小值)。</p>
<p>​	最后，考虑出错情况，例如，输入的值为非法值或响应失败。对大多数交互式系统来说，出错处理都是最难实现的部分。如果可能，应该允许用户“异常中止”一个操作或“取消”一个操作。</p>
<p>​	此外，还应该提供诸如“帮助”和状态查询之类的在基本交互行为之上的“通用”交互行为。</p>
<h3> 4.2 设想用户界面</h3>
<p>​    大多数交互行为都可以分为应用逻辑和用户界面两部分。通常，系统分析员首先集中精力考虑系统的信息流和控制流，而不是首先考虑用户界面。</p>
<p>​    事实上，采用不同界面(例如命令行或图形用户界面)，可以实现同样的程序逻辑。应用逻辑是内在的、本质的内容，用户界面是外在的表现形式。动态模型着重表示应用系统的控制逻辑。</p>
<p>​    但是，用户界面的美观程度、方便程度、易学程度以及效率等，是用户使用系统时最先感受到的，用户对系统的“第一印象”往往从界面得来，用户界面的好坏往往对用户是否喜欢、是否接受一个系统起很重要的作用。</p>
<p>​    在分析阶段不能完全忽略用户界面。在这个阶段用户界面的细节并不太重要，重要的是在这种界面下的信息交换方式。软件开发人员的目的是确保能够完成全部必要的信息交换，而不会丢失重要的信息。</p>
<p>​    不经过实际使用很难评价一个用户界面的优劣，因此，软件开发人员往往快速地建立起用户界面的原型，供用户试用与评价。</p>
<h3> 4.3 画事件跟踪图</h3>
<p>完整、正确的脚本为建立动态模型奠定了必要的基础。但是，用自然语言书写的脚本往往不够简明，而且有时在阅读时会有二义性。为了有助于建立动态模型，通常在画状态图之前先画出事件跟踪图。为此首先需要进一步明确事件及事件与对象的关系。</p>
<p>1.确定事件</p>
<p>2.画出事件跟踪图</p>
<p><strong>1.</strong> <strong>确定事件</strong></p>
<p>​    事件包括系统与用户(或外部设备)交互的所有信号、输入、输出、中断、动作等。从脚本中容易找出正常事件，但是，应该小心仔细，不要遗漏了异常事件和出错条件。</p>
<p>​    应该把对控制流产生相同效果的那些事件组合在一起作为一类事件，并给它们取一个唯一的名字。</p>
<p>​    但是，应该把对控制流有不同影响的那些事件区分开来，不要误把它们组合在一起。</p>
<p>​    一般说来，不同应用系统对相同事件的响应并不相同，因此，在最终分类所有事件之前，必须先画出状态图。如果从状态图中看出某些事件之间的差异对系统行为并没有影响，则可以忽略这些事件间的差异。</p>
<p>​    经过分析，应该区分出每类事件的发送对象和接受对象。一类事件相对它的发送对象来说是输出事件，但是相对它的接受对象来说则是输入事件。有时一个对象把事件发送给自己，在这种情况下，该事件既是输出事件又是输入事件。</p>
<p><strong>2. 画出事件跟踪图</strong></p>
<p>​    事件跟踪图实质上是扩充的脚本，可以认为事件跟踪图是简化的UML顺序图。</p>
<p>​    在事件跟踪图中，一条竖线代表一个对象，每个事件用一条水平的箭头线表示，箭头方向从事件的发送对象指向接受对象。时间从上向下递增，</p>
<p>​    画在最上面的水平箭头线代表最先发生的事件，画在最下面的水平箭头线所代表的事件最晚发生。箭头线之间的间距并没有具体含义，图中仅用箭头线在垂直方向上的相对位置表示事件发生的先后，并不表示两个事件之间的精确时间差。</p>
<h3> 4.4 画状态图</h3>
<p>​    状态图描绘事件与对象状态的关系。当对象接受了一个事件以后，它的下个状态取决于当前状态及所接受的事件。由事件引起的状态改变称为“转换”。如果一个事件并不引起当前状态发生转换，则可忽略这个事件。</p>
<p>​    通常，用一张状态图描绘一类对象的行为，它确定了由事件序列引出的状态序列。</p>
<p>​    但是，也不是任何一个类都需要有一张状态图描绘它的行为。很多对象仅响应与过去历史无关的那些输入事件，或者把历史作为不影响控制流的参数。对于这类对象来说，状态图是不必要的。系统分析员应该集中精力仅考虑具有重要交互行为的那些类。</p>
<p>​    从一张事件跟踪图出发画状态图时，应该集中精力仅考虑影响一类对象的事件，也就是说，仅考虑事件跟踪图中指向某条竖线的那些箭头线。把这些事件作为状态图中的有向边(即箭头线)，边上标以事件名。</p>
<p>​    两个事件之间的间隔就是一个状态。一般说来，如果同一个对象对相同事件的响应不同，则这个对象处在不同状态。应该尽量给每个状态取个有意义的名字。通常，从事件跟踪图中当前考虑的竖线射出的箭头线，是这条竖线代表的对象达到某个状态时所做的行为(往往是引起另一类对象状态转换的事件)。</p>
<p>​    根据一张事件跟踪图画出状态图之后，再把其他脚本的事件跟踪图合并到已画出的状态图中。为此需在事件跟踪图中找出以前考虑过的脚本的分支点(例如“验证账户”就是一个分支点，因为验证的结果可能是“账户有效”，也可能是“无效账户”)，然后把其他脚本中的事件序列并入已有的状态图中，作为一条可选的路径。</p>
<p><strong>考虑完正常事件之后再考虑边界情况和特殊情况</strong></p>
<p>​    其中包括在不适当时候发生的事件(例如系统正在处理某个事务时，用户要求取消该事务)。有时用户(或外部设备)不能做出快速响应，然而某些资源又必须及时收回，于是在一定间隔后就产生了“超时”事件。对用户出错情况往往需要花费很多精力处理，并且会使原来清晰、紧凑的程序结构变得复杂、繁琐，但是，出错处理是不能省略的。</p>
<p>​    当状态图覆盖了所有脚本，包含了影响某类对象状态的全部事件时，该类的状态图就构造出来了。利用这张状态图可能会发现一些遗漏的情况。测试完整性和出错处理能力的最好方法，是设想各种可能出现的情况，多问几个“如果……，则……”的问题。</p>
<h3> 4.5 审查动态模型</h3>
<p>​    各个类的状态图通过共享事件合并起来，构成了系统的动态模型。在完成了每个具有重要交互行为的类的状态图之后，应该检查系统级的完整性和一致性。</p>
<p>​    一般说来，每个事件都应该既有发送对象又有接受对象，当然，有时发送者和接受者是同一个对象。对于没有前驱或没有后继的状态应该着重审查，如果这个状态既不是交互序列的起点也不是终点，则发现了一个错误。</p>
<p>​    应该审查每个事件，跟踪它对系统中各个对象所产生的效果，以保证它们与每个脚本都匹配。</p>
<h2> 5.建立功能模型</h2>
<p>​    功能模型表明了系统中数据之间的依赖关系，以及有关的数据处理功能，它由一组数据流图组成。其中的处理功能可以用IPO图(或表)、伪码等多种方式进一步描述。</p>
<p>通常在建立了对象模型和动态模型之后再建立功能模型。</p>
<h3> 5.1 画出基本系统模型图</h3>
<p>​    基本系统模型由若干个数据源点/终点，及一个处理框组成，这个处理框代表了系统加工、变换数据的整体功能。</p>
<p>​    基本系统模型指明了目标系统的边界。由数据源点输入的数据和输出到数据终点的数据，是系统与外部世界之间的交互事件的参数。</p>
<h3> 5.2 画出功能级数据流图</h3>
<p>把基本系统模型中单一的处理框分解成若干个处理框，以描述系统加工、变换数据的基本功能，就得到功能级数据流图。右图是ATM系统的功能级数据流图。</p>
<img src="https://article.biliimg.com/bfs/article/0e083171985a467c70ae4d2d1e9ddd3b019ed690.png" alt="image-20230212190702035" style="zoom: 67%;">
<h3> 5.3 描述处理框功能</h3>
<p>把数据流图分解细化到一定程度之后，就应该描述图中各个处理框的功能。应该注意的是，要着重描述每个处理框所代表的功能，而不是实现功能的具体算法。</p>
<p>描述既可以是说明性的，也可以是过程性的。</p>
<p>​	说明性描述规定了输入值和输出值之间的关系，以及输出值应遵循的规律。</p>
<p>​	过程性描述则通过算法说明“做什么”。</p>
<p>一般说来，说明性描述优于过程性描述，因为这类描述中通常不会隐含具体实现方面的考虑。</p>
<h2> 6.定义服务</h2>
<p>“对象”是由描述其属性的数据，及可以对这些数据施加的操作(即服务)，封装在一起构成的独立单元。因此，为建立完整的对象模型，既要确定类中应该定义的属性，又要确定类中应该定义的服务。</p>
<p>​    需要等到建立了动态模型和功能模型之后，才能最终确定类中应有的服务，因为这两个子模型更明确地描述了每个类中应该提供哪些服务。事实上，在确定类中应有的服务时，既要考虑该类实体的常规行为，又要考虑在本系统中特殊需要的服务。</p>
<p><strong>1. 常规行为</strong></p>
<p>在分析阶段可以认为，类中定义的每个属性都是可以访问的，也就是说，假设在每个类中都定义了读、写该类每个属性的操作。但是，通常无须在类图中显式表示这些常规操作。</p>
<p><strong>2.从事件导出的操作</strong></p>
<p>​    状态图中发往对象的事件也就是该对象接收到的消息，因此该对象必须有由消息选择符指定的操作，这个操作修改对象状态(即属性值)并启动相应的服务。</p>
<p>​    可以看出，所启动的这些服务通常就是接受事件的对象在相应状态的行为。</p>
<p><strong>3.</strong> <strong>与数据流图中处理框对应的操作</strong></p>
<p>​    数据流图中的每个处理框都与一个对象(也可能是若干个对象)上的操作相对应。应该仔细对照状态图和数据流图，以便更正确地确定对象应该提供的服务。</p>
<p><strong>4.</strong> <strong>利用继承减少冗余操作</strong></p>
<p>​    应该尽量利用继承机制以减少所需定义的服务数目。只要不违背领域知识和常识，就尽量抽取出相似类的公共属性和操作，以建立这些类的新父类，并在类等级的不同层次中正确地定义各个服务。</p>
<h2> 7.本章小结</h2>
<ol>
<li>
<p>面向对象分析中，主要由对象模型、动态模型和功能模型组成。</p>
</li>
<li>
<p>面向对象分析的关键工作，是分析、确定问题域中的对象及对象间的关系，并建立起问题域的对象模型。</p>
</li>
<li>
<p>大型、复杂系统的对象模型通常由下述5个层次组成：主题层、类与对象层、结构层、属性层和服务层。</p>
</li>
<li>
<p>分析模型是系统分析员同用户及领域专家交流时有效的通信手段。最终的模型必须得到用户和领域专家的确认。在交流和确认的过程中，原型往往能起很大的促进作用。</p>
</li>
</ol>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">09 【面向对象设计】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/09.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/09.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 09 【面向对象设计】</h1>
]]></summary>
    <content type="html"><![CDATA[<h1> 09 【面向对象设计】</h1>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">10 【面向对象实现】</title>
    <id>https://blog.dselegent.icu/professional_knowledge/software_engineer/10.html</id>
    <link href="https://blog.dselegent.icu/professional_knowledge/software_engineer/10.html"/>
    <updated>2023-02-23T02:59:50.000Z</updated>
    <summary type="html"><![CDATA[<h1> 10 【面向对象实现】</h1>
]]></summary>
    <content type="html"><![CDATA[<h1> 10 【面向对象实现】</h1>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.icu</uri>
    </contributor>
    <published>2023-02-23T02:59:50.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
</feed>