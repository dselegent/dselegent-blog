<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://blog.dselegent.cf/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://blog.dselegent.cf/</id>
  <title>dselegent-blog</title>
  <subtitle>开源工具、效率方法的自我提升笔记，记录并输出一切能让自己提升的知识。</subtitle>
  <author>
    <name>dselegent</name>
    <uri>https://blog.dselegent.cf</uri>
  </author>
  <logo>https://blog.dselegent.cf/logo.png</logo>
  <rights>Copyright by dselegent</rights>
  <updated>2023-02-16T06:41:25.452Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://blog.dselegent.cf/atom.xml"/>
  <link rel="alternate" href="https://blog.dselegent.cf/"/>
  <contributor>
    <name>dselegent</name>
    <uri>https://blog.dselegent.cf</uri>
  </contributor>
  <entry>
    <title type="text">01 【Git 提交规范】</title>
    <id>https://blog.dselegent.cf/tool/lint/01.html</id>
    <link href="https://blog.dselegent.cf/tool/lint/01.html"/>
    <updated>2023-02-16T06:38:14.000Z</updated>
    <summary type="html"><![CDATA[<h1> 01 【Git 提交规范】</h1>
<h2> 1.Git提交规范（Commitizen）</h2>
<h3> 1.1 背景</h3>
<p>Git是目前世界上最先进的分布式版本控制系统，在我们平时的项目开发中已经广泛使用。而当我们使用Git提交代码时，都需要写Commit Message提交说明才能够正常提交。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>git commit -m "提交"
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h1> 01 【Git 提交规范】</h1>
<h2> 1.Git提交规范（Commitizen）</h2>
<h3> 1.1 背景</h3>
<p>Git是目前世界上最先进的分布式版本控制系统，在我们平时的项目开发中已经广泛使用。而当我们使用Git提交代码时，都需要写Commit Message提交说明才能够正常提交。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然而，我们平时在编写提交说明时，通常会直接填写如"fix"或"bug"等不规范的说明，不规范的提交说明很难让人明白这次代码提交究竟是为了什么。而在工作中，一份清晰简介规范的Commit Message能让后续代码审查、信息查找、版本回退都更加高效可靠。因此我们需要一些工具来约束开发者编写符合规范的提交说明。</p>
<h3> 1.2 提交规范</h3>
<p>那么，什么样的提交说明才能符合规范的说明呢？不同的团队可以制定不同的规范，当然，我们也可以直接使用目前流行的规范，比如<a href="https://zj-git-guide.readthedocs.io/zh_CN/latest/message/Angular%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener noreferrer">Angular Git Commit Guidelines</a>。接下来将会对目前流行的Angular提交规范进行介绍。</p>
<h4> 提交格式</h4>
<p>符合规范的Commit Message的提交格式如下，包含了页眉（header）、正文（body）和页脚（footer）三部分。其中，header是必须的，body和footer可以忽略。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 页眉设置</h4>
<p>页眉（header）通常只有一行，包括了提交类型（type）、作用域（scope）和主题（subject）。其中，type和subject是必须的，scope是可选的。</p>
<p><strong>提交类型</strong></p>
<p>提交类型（type）用于说明此次提交的类型，需要指定为下面其中一个：</p>
<figure><img src="https://article.biliimg.com/bfs/article/25c25024576908442687ed7bd9ec508b13b6be0c.png" alt="image-20230212220159594" tabindex="0" loading="lazy"><figcaption>image-20230212220159594</figcaption></figure>
<p><strong>作用域</strong></p>
<p>作用域（scope）表示此次提交影响的范围。比如可以取值api，表明只影响了接口。</p>
<p><strong>主题</strong></p>
<p>主题（subject）描述是简短的一句话，简单说明此次提交的内容。</p>
<h4> 正文和页脚</h4>
<p>正文（body）和页眉（footer）这两部分不是必须的。</p>
<p>如果是破坏性的变更，那就必须在提交的正文或脚注加以展示。一个破坏性变更必须包含大写的文本 BREAKING CHANGE，紧跟冒号和空格。脚注必须只包含 BREAKING CHANGE、外部链接、issue 引用和其它元数据信息。例如修改了提交的流程，依赖了一些包，可以在正文写上：BREANKING CHANGE：需要重新npm install，使用npm run cm代替git commit。</p>
<p>下面给出了一个Commit Message例子，该例子中包含了header和body。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，在平时的提交中，我们也可以只包含header，比如我们修改了登录页面的某个功能，那么可以这样写Commit Message。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 1.3 Commitizen</h3>
<p>虽然有了规范，但是还是无法保证每个人都能够遵守相应的规范，因此就需要使用一些工具来保证大家都能够提交符合规范的Commit Message。常用的工具包括了可视化工具和信息交互工具，其中Commitizen是常用的Commitizen工具，接下来将会先介绍Commitizen的使用方法。</p>
<h4> 什么是Commitizen</h4>
<p><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener noreferrer">Commitizen</a>是一个撰写符合上面Commit Message标准的一款工具，可以帮助开发者提交符合规范的Commit Message。</p>
<h4> 安装Commitizen</h4>
<p>可以使用npm安装Commitizen。其中，cz-conventional-changelog是本地适配器。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 配置Commitizen</h4>
<p>安装好Commitizen之后，就需要配置Commitizen，我们需要在package.json中加入以下代码。其中，需要增加一个script，使得我们可以通过执行npm run cm来代替git commit，而path为cz-conventional-changelog包相对于项目根目录的路径。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实这个可以全局安装，这样我们所有地方都可以用</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完成之后，我们就可以通过执行npm run cm来代替git commit，接着只需要安装提示，完成header、body和footer的编写，就能够编写出符合规范的Commit Message。</p>
<figure><img src="https://article.biliimg.com/bfs/article/ee3c890b2c596ad7f0a2bd6d1839e082f9fc1f08.png" alt="image-20230212220930672" tabindex="0" loading="lazy"><figcaption>image-20230212220930672</figcaption></figure>
<h2> 2.Git工作流规范（Husky ）</h2>
<h3> 2.1 背景</h3>
<p>有些同学可能会把ESLint、Stylelint或Commitizen提示的错误忽视不见，直接将代码提交到代码仓库中。这样做的话，那么其他同学在pull代码并diff代码时可能会出现大段代码标红，同时在进行CI时又可能因为代码风格或规范问题被打回重改。</p>
<p>那么，有没有一种方法，让大家在提交代码时需要确保本地的代码或Commit Message已经通过检查才能够push到代码仓库，从而更好的保障代码质量呢？接下来，将会介绍如何使用Husky + Commintlint + Lint-staged打造规范的Git检查工作流，确保我们的代码只有符合规范才能提交到代码仓库。</p>
<h3> 2.2 什么是git hook</h3>
<p>在介绍Husky之前，我们先来看什么是git hook，也就是常说的Git钩子。</p>
<p>和其它版本控制系统一样，Git能在特定的重要动作发生时触发自定义脚本。有两组这样的钩子：客户端的和服务器端的。 客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 你可以随心所欲地运用这些钩子。</p>
<p>其中，客户端钩子我们可能用的比较多，客户端钩子通常包括了提交工作流钩子、电子邮件工作流钩子和其它钩子。这些钩子通常存储在项目的.git/hooks目录下，我们需要关注的主要是提交工作流钩子。提交工作流钩子主要包括了以下四种：</p>
<ul>
<li>
<p>pre-commit：该钩子在键入提交信息前运行。 它用于检查即将提交的快照。如果该钩子以非零值退出，Git 将放弃此次提交，你可以利用该钩子，来检查代码风格是否一致。</p>
</li>
<li>
<p>prepare-commit-msg：该钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。</p>
</li>
<li>
<p>commit-msg：该钩子接收一个参数，此参数存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。</p>
</li>
<li>
<p>post-commit：该钩子一般用于通知之类的事情。</p>
<p>在上面的钩子中，我们需要关注pre-commit和commit-msg钩子。</p>
</li>
</ul>
<h3> 2.3 什么是husky</h3>
<p><a href="https://github.com/typicode/husky" target="_blank" rel="noopener noreferrer">husky</a>是常见的git hook工具，使用husky可以挂载Git钩子，当我们本地进行git commit或git push等操作前，能够执行其它一些操作，比如进行ESLint检查，如果不通过，就不允许commit或push。</p>
<h3> 2.4 安装husky</h3>
<p>安装husky，可以使用npm进行安装。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.5 配置husky</h3>
<p>安装好husky之后，还需要对husky进行配置。不同版本的husky配置方法有些不同。</p>
<ol>
<li>安装 husky git hooks</li>
</ol>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2">
<li>测试 husky 钩子作用，添加 pre-commit 钩子</li>
</ol>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们需要安装配置好ESLint或Stylelint，并且在 <code>pre-commit</code> 中加入以下代码。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，当我们执行git commit时，就会触发pre-commit钩子，并且执行对应命令，这里将会指定目录下的文件进行ESLint检查，如果ESLint检查不通过，是无法进行commit的。</p>
<figure><img src="https://article.biliimg.com/bfs/article/914bd4db9e59aab4cee16b65998131af6d162b99.png" alt="image-20230212221721568" tabindex="0" loading="lazy"><figcaption>image-20230212221721568</figcaption></figure>
<p>如果ESLint检查通过，就可以正常进行commit。</p>
<figure><img src="https://article.biliimg.com/bfs/article/5aaaa1287862843e69b499d50e3ce3b69734cf78.png" alt="image-20230212221733767" tabindex="0" loading="lazy"><figcaption>image-20230212221733767</figcaption></figure>
<p>在安装并配置好husky之后，如果发现在commit时不能触发pre-commit，可以试着重新安装husky，并且重启VSCode。</p>
<h3> 2.6 只使用husky的问题</h3>
<p>使用husky虽然能够帮助我们在commit或push前执行一些指令，但是如果只使用husky，仍然存在下面这些问题：</p>
<ul>
<li>
<p>在某次提交时，我们只修改了某个文件，但是只使用husky会把所有的文件都运行一遍Lint检查，时间成本太高。此外，有些项目会在中途才加上husky，但是在commit时husky也会对其它未修改的历史代码进行检查，可能会一下子报了很多错误，这个时候我们更希望只对当前修改过的文件进行检查，而不是对项目中的代码都进行检查。</p>
</li>
<li>
<p>husky的钩子只能执行一个指令，但是有时候我们希望能够在git commit之前执行多个指令，比如执行ESLint、Stylelint或Commitlint等操作。</p>
<p>为了解决上面的问题，就需要结合Lint-staged一起使用。</p>
</li>
</ul>
<h2> 3.Git工作流规范（Lint-staged）</h2>
<h3> 3.1 什么是Lint-staged</h3>
<p><a href="https://github.com/okonet/lint-staged" target="_blank" rel="noopener noreferrer">Lint-staged</a>可以在git staged阶段的文件上执行Linters，简单说就是当我们运行ESlint或Stylelint命令时，可以通过设置指定只检查我们通过git add添加到暂存区的文件，可以避免我们每次检查都把整个项目的代码都检查一遍，从而提高效率。</p>
<p>其次，Lint-staged允许指定不同类型后缀文件执行不同指令的操作，并且可以按步骤再额外执行一些其它shell指令。</p>
<p>安装Lint-staged，可以使用npm进行安装。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3.2 配置Lint-staged</h3>
<p>安装好了Lint-staged之后，就需要配置Lint-staged。我们可以在package.json中加入以下代码，这里需要先安装配置好husky，ESLint和Stylelint。</p>
<p><code>.lintstagedrc.js</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>package.json</code></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>pre-commit</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们执行git commit时，就会触发husky的pre-commit钩子，调用lint-staged命令。而lint-staged包含了对*.vue，<em>.{js,jsx,ts,tsx}，</em>.{htm,html,css,sss,less,scss,sass}类型文件的操作。以*.vue为例，当匹配到后缀名为.vue的文件时，就会分别执行以下操作：</p>
<ul>
<li>首先会执行eslint --fix命令，对.vue文件执行ESLint检查，并且自动修复一些JS格式问题</li>
<li>接着会执行stylelint --fix命令，对.vue文件的CSS执行Stylelint检查，并且自动修复一些CSS格式问题</li>
<li>最后，若前面的指令都执行通过，那么将加入到本地的git commit中，如果没有执行通过，那么将不能commit</li>
</ul>
<h2> 4.Git工作流规范（Commitlint）</h2>
<p>除了在commit前对JS和CSS执行ESLint和Stylelint检查之外，也可以对Commit Message进行检查。接下来，将会介绍Commitlint的安装和配置方法。</p>
<h3> 4.1 什么是Commitlint</h3>
<p>在使用Git提交代码时，通常都需要填写提交说明，也就是Commit Message。在前面的文章中，已经介绍了如何使用Commitizen或可视化工具编写符合规范的Commit Message。然而有些同学可能还是会使用git commit方式提交一些不符合规范的Commit Message。为了禁止不符合规范的Commit Message的提交，我们就需要采用一些工具，只有当开发者编写了符合规范的Commit Message才能够进行commit。而<a href="https://commitlint.js.org/#/" target="_blank" rel="noopener noreferrer">Commitlint</a>就是这样一种工具，通过结合husky一起使用，可以在开发者进行commit前就对Commit Message进行检查，只有符合规范，才能够进行commit。</p>
<h3> 4.2 安装Commitlint</h3>
<p>使用npm安装Commitlint相关依赖包。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4.3 配置Commitlint</h3>
<p>安装好Commitlint之后，就需要配置Commitlint，可以在根目录创建<code>.commitlintrc.js</code>文件进行配置。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在comminlint.config.js中加入以下代码，表示使用config-conventional规范对提交说明进行检查。具体的规范配置可以查看：<a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener noreferrer">https://github.com/conventional-changelog/commitlint</a></p>
<p>接下来，需要在<code>.husky</code>中加入<code>commit-msg</code>钩子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>配置好了之后，当我们进行git commit时，就会触发commit-msg钩子，执行commintlint命令，并且读取commitlint.config.js中的规则对我们的提交说明进行检查，如果校验不通过，将不能提交。</p>
<h2> 5.cz-git</h2>
<h3> 5.1 介绍</h3>
<p>一款工程性更强，轻量级，高度自定义，标准输出格式的 <a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener noreferrer">commitizen</a> 适配器</p>
<p><strong>特点</strong></p>
<ul>
<li>💪 友好型命令行工具，<strong>“懒字优先”</strong> ！支持在命令行搜索和选择，减少拼写错误。</li>
<li>⚡️ <strong>轻量级</strong>，<strong>高度自定义</strong>, 但输出格式遵循标准的 <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commits" target="_blank" rel="noopener noreferrer">Angular commit</a> 规范。</li>
<li>🔨 <a href="https://cz-git.qbb.sh/zh/recipes/#scopes" target="_blank" rel="noopener noreferrer">更好维护 monorepo 工程化项目</a> 与 <strong>commitlint</strong> 配合给予命令行的相关校验信息。</li>
<li>✅ 支持在 commit 中添加 <strong>emoji</strong> ｜ 更好的与issue链接，尤其 <a href="https://cz-git.qbb.sh/zh/recipes/issue-prefixs.html" target="_blank" rel="noopener noreferrer">gitee</a></li>
</ul>
<p><strong>为什么制作了这款插件</strong></p>
<ul>
<li>
<p><strong>cz-customizable</strong></p>
<ol>
<li>需要额外添加配置文件。</li>
<li>仅支持上下选择是的交互方式。</li>
<li>可支持的习惯型配置项少。</li>
</ol>
</li>
<li>
<p><strong>cz-conventional-changelog</strong></p>
<ol>
<li>
<p>支持的自定义配置项少。</p>
</li>
<li>
<p>交互方式不友好。</p>
</li>
<li>
<p>重复性输入的东西太多。</p>
</li>
</ol>
</li>
</ul>
<h3> 5.2 项目中使用</h3>
<blockquote>
<p>只需要简单的三个步骤:</p>
</blockquote>
<p><a href="https://cz-git.qbb.sh/zh/guide/#%E5%85%A8%E5%B1%80%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener noreferrer">全局安装</a> <code>commitizen</code>,如此一来可以快速使用 <code>cz</code> 或 <code>git cz</code> 命令进行启动。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>步骤 1: 下载依赖</strong></p>
<ul>
<li>NPM</li>
<li>YARN</li>
<li>PNPM</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>步骤 2: 修改 <code>package.json</code> 添加 <code>config</code> 指定使用的适配器</strong></p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>步骤 3: 添加自定义配置(可选，使用默认)</strong></p>
<blockquote>
<p>有两种配置方式</p>
</blockquote>
<p><strong>方式一: (推荐) cz-git 与 <a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener noreferrer">commitlint</a> 进行联动给予校验信息</strong>，所以可以编写于 <a href="https://github.com/conventional-changelog/commitlint#config" target="_blank" rel="noopener noreferrer">commitlint</a> 配置文件之中。
例如: (<a href="https://cz-git.qbb.sh/zh/config/" target="_blank" rel="noopener noreferrer">⇒ 配置模板</a>)</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方式二:</strong> 在 <strong>package.json</strong> 下 config.commitizen 下添加自定义配置，但过量的配置项会导致 package.json 臃肿，适合简单自定义。例如:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5.3 全局使用</h3>
<blockquote>
<p>全局安装的好处在于：在任何项目下都可以利用 <code>cz</code> 或 <code>git cz</code> 命令启动命令行工具，生成标准化 commit message</p>
</blockquote>
<p>只需要简单的三个步骤：</p>
<p><strong>步骤 1: 下载全局依赖</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>步骤 2: 全局配置适配器类型</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>步骤 3: 添加自定义配置(可选，使用默认配置)</strong></p>
<blockquote>
<p>有 两种 配置方式</p>
</blockquote>
<p><strong>方式一:</strong> 编辑 <code>~/.czrc</code> 文件以 json 形式添加配置, 例如:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>方式二: 与 <a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener noreferrer">commitlint</a> 配合</strong>，在 <code>$HOME</code> 路径下创建配置文件
(<a href="https://cz-git.qbb.sh/zh/config/" target="_blank" rel="noopener noreferrer">↓ 配置模板</a>)</p>
<h3> 5.4 我的配置</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://article.biliimg.com/bfs/article/99ead6f04bba10d7799dff1c05aad0d6a3ca63a2.png" alt="image-20230212230104019" tabindex="0" loading="lazy"><figcaption>image-20230212230104019</figcaption></figure>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-02-16T06:38:14.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">01 【计算机网络-概述】</title>
    <id>https://blog.dselegent.cf/professional_knowledge/computer_network/01.html</id>
    <link href="https://blog.dselegent.cf/professional_knowledge/computer_network/01.html"/>
    <updated>2023-02-10T13:52:13.000Z</updated>
    <summary type="html"><![CDATA[<h1> 01 【计算机网络-概述】</h1>
<p><img src="https://i0.hdslb.com/bfs/album/681a357243cc209b37708885ae3b067c40657e9b.png" alt="image-20230122144219777" style="zoom:50%;">代表着主机</p>
<p><img src="https://i0.hdslb.com/bfs/album/9971846161282f85ab6565b63d133fd3d8c8152b.png" alt="image-20201007144130208" style="zoom:50%;"> 代表服务器</p>]]></summary>
    <content type="html"><![CDATA[<h1> 01 【计算机网络-概述】</h1>
<p><img src="https://i0.hdslb.com/bfs/album/681a357243cc209b37708885ae3b067c40657e9b.png" alt="image-20230122144219777" style="zoom:50%;">代表着主机</p>
<p><img src="https://i0.hdslb.com/bfs/album/9971846161282f85ab6565b63d133fd3d8c8152b.png" alt="image-20201007144130208" style="zoom:50%;"> 代表服务器</p>
<p><img src="https://i0.hdslb.com/bfs/album/a650357a51ae1ebd1bd1e58271b4af73a663500e.png" alt="image-20201007143904153" style="zoom:50%;"> 代表着路由器</p>
<p><img src="https://i0.hdslb.com/bfs/album/559a125be2e7d2284e6a4c35479ebc40b3666465.png" alt="image-20201007143936128" style="zoom:50%;">代表着网络</p>
<h2> 1.计算机网络在信息时代的作用</h2>
<h3> 1.1 信息服务基础设施</h3>
<ul>
<li>计算机网络已由一种<strong>通信基础设施</strong>发展成为一种重要的<strong>信息服务基础设施</strong></li>
<li>计算机网络已经像水，电，煤气这些基础设施一样，成为我们<strong>生活中不可或缺</strong>的一部分</li>
</ul>
<h3> 1.2 我国互联网发展状况</h3>
<p><a href="http://www.cnnic.net.cn/" target="_blank" rel="noopener noreferrer">中国互联网络信息中心CNNIC</a>，我们可以在这里查看国内互联网发展状况统计报告。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e6874391c0d9b22f51a28b0505a9b61e677b4ca8.png" alt="image-20201006160618748" tabindex="0" loading="lazy"><figcaption>image-20201006160618748</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/ca4f42cb878833d7360a17b112f0318963f178be.png" alt="image-20201006160645887" tabindex="0" loading="lazy"><figcaption>image-20201006160645887</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/23c66e444240e0bd1fbcfed00fe8966b07669616.png" alt="image-20201006160715764" tabindex="0" loading="lazy"><figcaption>image-20201006160715764</figcaption></figure>
<h2> 2.因特网概述</h2>
<h3> 2.1 网络、互连网（互联网）和因特网</h3>
<ul>
<li>网络：网络（Network）由若干**结点（Node）<strong>和连接这些结点的</strong>链路（Link）**组成。</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/a66783e4c8a28e8ddd3aa881271126ffdf864304.png" alt="image-20230122144907591" style="zoom:50%;">
<ul>
<li>互连网（互联网）：多个网络通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/3d9188fdbd1307610b1042826cee1c86e4c2c52d.png" alt="image-20230122144950012" style="zoom:50%;">
<ul>
<li>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/8c4bacc7da0d9092344f132d112aa7aea7a868f1.png" alt="image-20230122145020223" style="zoom:50%;">
<blockquote>
<p><strong>internet与Internet的区别</strong></p>
<ul>
<li><strong>internet(互联网或互连网)<strong>是一个通用名词，它泛指</strong>多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</li>
<li><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。</li>
</ul>
<p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</strong></p>
</blockquote>
<h3> 2.2 因特网发展的三个阶段</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/50e47ccec1d47bd7f35aae21b10c54766133f622.png" alt="image-20230122151501944" tabindex="0" loading="lazy"><figcaption>image-20230122151501944</figcaption></figure>
<p><strong>因特网服务提供者<code>ISP</code>(<code>I</code>nternet <code>S</code>ervice <code>P</code>rovider)</strong></p>
<img src="https://i0.hdslb.com/bfs/album/0c605725fbeeb3d3a0f6e25fe21842b27c0345be.png" alt="image-20201006165117756" style="zoom:67%;">
<blockquote>
<p>普通用户是如何接入到因特网的呢？</p>
<p>答：<strong>通过ISP接入因特网</strong></p>
<p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p>
<p><strong>因为因特网上的主机都必须有IP地址才能进行通信，这样就可以通过该ISP接入到因特网</strong></p>
</blockquote>
<p><strong>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</strong></p>
<img src="https://i0.hdslb.com/bfs/album/0cba03b8dc0bfd8727408dcb55752e2f74a1a48a.png" alt="image-20201006165738879" style="zoom:67%;">
<p><strong>基于ISP的三层结构的因特网</strong></p>
<img src="https://i0.hdslb.com/bfs/album/b57715c77dde3601cbb1a5fe61735269fde59d09.png" alt="image-20201006170140504" style="zoom:67%;">
<blockquote>
<p>一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p>
</blockquote>
<h3> 2.3 因特网的标准化工作</h3>
<ul>
<li>因特网的标准化工作对因特网的发展起到了非常重要的作用。</li>
<li>因特网在指定其标准上的一个很大的特点是<strong>面向公众。</strong>
<ul>
<li>因特网所有的<strong>RFC</strong>(Request For Comments)技术文档都可从因特网上免费下载；</li>
<li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li>
</ul>
</li>
<li><strong>因特网协会ISOC</strong>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。
<ul>
<li>因特网体系结构委员会IAB，负责管理因特网有关协议的开发；</li>
<li>因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</li>
<li>因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li>
</ul>
</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/123abd079ce7b78370ec91e922976a94e8c806a6.png" alt="image-20201006170959060" style="zoom:67%;">
<ul>
<li>
<p>制订因特网的正式标准要经过一下<strong>4个阶段</strong>：</p>
<p>1、因特网草案（在这个阶段还不是RFC文档）</p>
<p>2、建议标准（从这个阶段开始就成为RFC文档）</p>
<p>3、草案标准</p>
<p>4、因特网标准</p>
</li>
</ul>
<h3> 2.4 因特网的组成</h3>
<ul>
<li>
<p>边缘部分</p>
<p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p>
</li>
<li>
<p>核心部分</p>
<p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p>
</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/b4ffa652d74390cda50159562c842fad1db2b525.png" alt="image-20201006180725282" style="zoom:67%;">
<blockquote>
<p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p>
<p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为<strong>端系统 (end system)</strong>。</p>
<p><strong>端系统在功能上可能有很大的差别：</strong></p>
<ol>
<li>
<p>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</p>
</li>
<li>
<p>大的端系统则可以是一台非常昂贵的大型计算机。</p>
</li>
<li>
<p>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。</p>
</li>
</ol>
</blockquote>
<h3> 2.5 端系统之间通信的含义</h3>
<p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong></p>
<p>端系统之间的通信方式通常可划分为两大类：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/242a6aa9c09046cb404fa5f8e78cde52f9f0ddb1.png" alt="image-20201010234145371" tabindex="0" loading="lazy"><figcaption>image-20201010234145371</figcaption></figure>
<p><strong>客户-服务器方式：</strong></p>
<ul>
<li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li>
<li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li>
<li>客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<blockquote>
<p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p>
</blockquote>
<p><strong>对等连接方式：</strong></p>
<ul>
<li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li>
<li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li>
<li>双方都可以下载对方已经存储在硬盘中的共享文档。</li>
</ul>
<h2> 3.三种交换方式</h2>
<p>网络核心部分是互联网中最复杂的部分。</p>
<p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p>
<p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p>
<p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p>
<h3> 3.1 电路交换（Circuit Switching）</h3>
<img src="https://i0.hdslb.com/bfs/album/8a5a5a392a4b462c74f8350aa6f586cb502c2a63.png" alt="image-20201006182240000" style="zoom:67%;">
<blockquote>
<p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p>
<p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p>
</blockquote>
<img src="https://i0.hdslb.com/bfs/album/27efe605034eadb66cd0ea520592b8f84d7711c1.png" alt="image-20201006182634249" style="zoom:50%;">
<ul>
<li>
<p>电话交换机接通电话线的方式称为电路交换；</p>
</li>
<li>
<p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p>
</li>
<li>
<p>电路交换的三个步骤：</p>
<p>1、建立连接（分配通信资源）</p>
<p>2、通话（一直占用通信资源）</p>
<p>3、释放连接（归还通信资源）</p>
</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/3608543e2f6e1783548bf2f8d0785fc323917d4b.png" alt="image-20201006183020317" style="zoom:67%;">
<blockquote>
<p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p>
<p>这是因为计算机数据是突发式地出现在传输线路上的。</p>
<p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p>
</blockquote>
<h3> 3.2 分组交换（Packet Switching）</h3>
<img src="https://i0.hdslb.com/bfs/album/0163593a7244a039192a577acd1b9050e2623a78.png" alt="image-20201006183312843" style="zoom:67%;">
<blockquote>
<p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p>
<p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p>
<p>首部包含了<strong>分组的目的地址</strong></p>
<p>分组从源主机到目的主机，可走不同的路径。</p>
</blockquote>
<p>发送方</p>
<ul>
<li>构造分组</li>
<li>发送分组</li>
</ul>
<p>路由器</p>
<ul>
<li>缓存分组</li>
<li>转发分组</li>
<li>简称为“分组转发”</li>
</ul>
<blockquote>
<p>在路由器中的输入和输出端口之间没有直接连线。</p>
<p>路由器处理分组的过程是：</p>
<ol>
<li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li>
<li><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</li>
<li>把分组送到适当的端口<strong>转发</strong>出去。</li>
</ol>
</blockquote>
<p>接收方</p>
<ul>
<li>接收分组</li>
<li>还原报文</li>
</ul>
<h3> 3.3 报文交换（Message Switching）</h3>
<p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p>
<h3> 3.4 三种交换方式的对比</h3>
<blockquote>
<p>假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间</p>
</blockquote>
<img src="https://i0.hdslb.com/bfs/album/cb99fc7d83b87ad484dd307ac914a47bd4855836.png" alt="image-20201006184451671" style="zoom:67%;">
<p>分析：</p>
<p>电路交换：</p>
<ul>
<li>
<p>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</p>
</li>
<li>
<p>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</p>
</li>
</ul>
<p>报文交换：</p>
<ul>
<li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li>
<li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li>
</ul>
<p>分组交换：</p>
<ul>
<li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li>
<li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li>
</ul>
<h2> 4.计算机网络的定义和分类</h2>
<h3> 4.1 定义</h3>
<ul>
<li>计算机网络的精确定义并未统一</li>
<li>计算机网络的最简单的定义是：一些<strong>互</strong>相<strong>连</strong>接的、<strong>自治</strong>的计算机的<strong>集合</strong>。
<ul>
<li>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</li>
<li>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li>
<li>集合：是指至少需要两台计算机；</li>
</ul>
</li>
<li>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件（一定包含有中央处理机CPU）互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。
<ul>
<li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li>
<li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li>
</ul>
</li>
</ul>
<h3> 4.2 分类</h3>
<p><strong>按交换技术分类：</strong></p>
<ul>
<li>电路交换网络</li>
<li>报文交换网络</li>
<li>分组交换网络</li>
</ul>
<p><strong>按使用者分类：</strong></p>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<p><strong>按传输介质分类：</strong></p>
<ul>
<li>有线网络</li>
<li>无线网络</li>
</ul>
<p><strong>按覆盖范围分类：</strong></p>
<ul>
<li>广域网WAN（Wide Area Network）</li>
</ul>
<p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p>
<ul>
<li>城域网MAN</li>
</ul>
<p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p>
<ul>
<li>局域网LAN</li>
</ul>
<p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右）</p>
<ul>
<li>个域网PAN</li>
</ul>
<p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p>
<p><strong>按拓扑结构分类：</strong></p>
<ul>
<li>总线型网络</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/b260af259dfa70c820b9205e44a09f80e167bb8d.png" alt="image-20201007005149993" style="zoom: 67%;">
<ul>
<li>星型网络</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/a1de5a0b7d81ef157134585181b6c78c90319ce5.png" alt="image-20201007005203129" style="zoom:67%;">
<ul>
<li>环形网络</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/038cdf72644745334fb08a1f0ccdbf499205a08d.png" alt="image-20201007005212345" style="zoom:67%;">
<ul>
<li>网状型网络</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/c50a02965d215027d72fbc3d7588862732c4219a.png" alt="image-20201007005249137" style="zoom:67%;">
<h2> 5.计算机网络的性能指标</h2>
<h3> 5.1 速率</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/ddfae16607476d7aafc5976a27cca04f4d48298b.png" alt="image-20201007012419698" tabindex="0" loading="lazy"><figcaption>image-20201007012419698</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/47b72b41df1f917708b76984c496a8dd7b8d0dbc.png" alt="image-20201007012439769" tabindex="0" loading="lazy"><figcaption>image-20201007012439769</figcaption></figure>
<h3> 5.2 带宽</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/56489d23cb839cc30cc65938fdc7cb9c43976399.png" alt="image-20201007012943970" tabindex="0" loading="lazy"><figcaption>image-20201007012943970</figcaption></figure>
<h3> 5.3 吞吐量</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/f393e1e0376938f2b940158411bce272b692f337.png" alt="image-20201007013119621" tabindex="0" loading="lazy"><figcaption>image-20201007013119621</figcaption></figure>
<blockquote>
<p>带宽1 Gb/s的以太网，代表其额定速率是1 Gb/s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽1 Gb/s的以太网，可能实际吞吐量只有 700 Mb/s，甚至更低。</p>
<p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p>
</blockquote>
<h3> 5.4 时延</h3>
<p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p>
<p>网络时延由几部分组成：</p>
<ul>
<li>发送时延</li>
</ul>
<p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p>
<ul>
<li>传播时延</li>
</ul>
<p>电磁波在信道中传播一定的距离需要花费的时间。</p>
<ul>
<li>处理时延</li>
</ul>
<p>主机或路由器在收到分组时要花费一定时间进行处理</p>
<ul>
<li>排队时延</li>
</ul>
<p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p>
<blockquote>
<p>有时会把排队时延看成<strong>处理时延 一部分</strong></p>
<p>总时延 = 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/260d57f2e9500d38493f90635d3bb85c8bc50d06.png" alt="image-20201007014139333" tabindex="0" loading="lazy"><figcaption>image-20201007014139333</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/05a6c4425ce413ea5bd711c10c00c47177c15f1c.png" alt="image-20201007015401505" tabindex="0" loading="lazy"><figcaption>image-20201007015401505</figcaption></figure>
<blockquote>
<p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p>
</blockquote>
<h3> 5.5 时延带宽积</h3>
<p>时延带宽积 = 传播时延 * 带宽</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d95f30f2b0951b7ea93e2aa53ff76287ecb72198.png" alt="image-20201007115317347" tabindex="0" loading="lazy"><figcaption>image-20201007115317347</figcaption></figure>
<h3> 5.6 往返时间</h3>
<p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/1353e93a1e7857730dee6dbf2a214f4fc90893d1.png" alt="image-20201007115647631" tabindex="0" loading="lazy"><figcaption>image-20201007115647631</figcaption></figure>
<h3> 5.7 利用率</h3>
<p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/32e1ac4b431d85a3318b674db960a110ffb31bf7.png" alt="image-20201012164544306" tabindex="0" loading="lazy"><figcaption>image-20201012164544306</figcaption></figure>
<h3> 5.8 丢包率</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/6e3aedf50c3cdd1f038093a5757cfdad9f3ca051.png" alt="image-20201007132900210" tabindex="0" loading="lazy"><figcaption>image-20201007132900210</figcaption></figure>
<h2> 6.计算机网络体系结构</h2>
<h3> 6.1 常见的计算机网络体系结构</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/d60aeeda69bec876a247cd69d55733762be45e88.png" alt="image-20201007133848212" tabindex="0" loading="lazy"><figcaption>image-20201007133848212</figcaption></figure>
<blockquote>
<p>如今用的最多的是TCP/IP体系结构，现今规模最大的、覆盖全球的、基于TCP/IP的互联网并未使用OSI标准。</p>
<p>TCP/IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p>
<p>TCP/IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP/IP体系结构的网络层称为网际层</strong></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/6214f2d87b58eef5a3491bd81ee21edb56605c24.png" alt="image-20201007135220030" tabindex="0" loading="lazy"><figcaption>image-20201007135220030</figcaption></figure>
<blockquote>
<p>在用户主机的操作系统中，通常都带有符合TCP/IP体系结构标准的TCP/IP协议族。</p>
<p>而用于网络互连的路由器中，也带有符合TCP/IP体系结构标准的TCP/IP协议族。</p>
<p>只不过路由器一般只包含网络接口层和网际层。</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/bbc0fcc6010902671a15f5d263ee52fed1e8c522.png" alt="image-20201007135518050" tabindex="0" loading="lazy"><figcaption>image-20201007135518050</figcaption></figure>
<blockquote>
<p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p>
<p><strong>网际层</strong>：它的核心协议是IP协议。</p>
<p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p>
<p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p>
</blockquote>
<blockquote>
<p>**IP协议（网际层）<strong>可以将不同的</strong>网络接口（网络接口层）<strong>进行互连，并向其上的</strong>TCP协议和UDP协议（运输层）**提供网络互连服务</p>
<p>而<strong>TCP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p>
<p><strong>UDP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p>
</blockquote>
<blockquote>
<p>TCP/IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/dfa511940c2e5f46ff7b82c780d36add5ce41bfc.png" alt="image-20201007141110338" tabindex="0" loading="lazy"><figcaption>image-20201007141110338</figcaption></figure>
<blockquote>
<p>教学时把TCP/IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p>
</blockquote>
<h3> 6.2 计算机网络体系结构分层的必要性</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/1c57ff2cb837bdd7877de4d2667d1ac362bb3405.png" alt="image-20201007141318411" tabindex="0" loading="lazy"><figcaption>image-20201007141318411</figcaption></figure>
<p><strong>物理层问题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/dc39838e6788df006044cee016ca874f73cf0731.png" alt="image-20201007141806675" tabindex="0" loading="lazy"><figcaption>image-20201007141806675</figcaption></figure>
<blockquote>
<p>这图说明</p>
<ul>
<li>第一，严格来说，传输媒体并不属于物理层</li>
<li>计算机传输的信号，并不是图示的方波信号</li>
</ul>
<p>这样举例只是让初学者容易理解</p>
</blockquote>
<p><strong>数据链路层问题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/508a572a5b90f78452b86adab0d739bfcd643c48.png" alt="image-20201007142049812" tabindex="0" loading="lazy"><figcaption>image-20201007142049812</figcaption></figure>
<p><strong>网络层问题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/ca8c690614aa69b4f36b64d9a246c84818d3d812.png" alt="image-20201007142408792" tabindex="0" loading="lazy"><figcaption>image-20201007142408792</figcaption></figure>
<p><strong>运输层问题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/efcedd202ff6d1815910500971ee96b4c816bb13.png" alt="image-20201007142631029" tabindex="0" loading="lazy"><figcaption>image-20201007142631029</figcaption></figure>
<blockquote>
<p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是QQ进程</p>
</blockquote>
<p><strong>应用层问题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/a188f9700ca7f2bb7c9f1793a3229957d127bd07.png" alt="image-20201007142755720" tabindex="0" loading="lazy"><figcaption>image-20201007142755720</figcaption></figure>
<blockquote>
<p>应用层该用什么方法（应用层协议）去解析数据</p>
</blockquote>
<p><strong>总结</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/bdb92cb4332fb32f01e4bbb5ac41efd1d37b6020.png" alt="image-20201007204006284" tabindex="0" loading="lazy"><figcaption>image-20201007204006284</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/a2f057da54bd6a857c573ab5369cda4e41df3f74.png" alt="image-20201007143138937" tabindex="0" loading="lazy"><figcaption>image-20201007143138937</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/6b4079acda3f7e1474181e06799b13cc3a4ded36.png" alt="image-20201007195641140" tabindex="0" loading="lazy"><figcaption>image-20201007195641140</figcaption></figure>
<h3> 6.3 计算机网络体系结构分层思想举例</h3>
<p>例子：主机的浏览器如何与Web服务器进行通信</p>
<figure><img src="https://i0.hdslb.com/bfs/album/c369d59822a8ba6dde728291b86fd812d1e1ed8d.png" alt="image-20201007144900565" tabindex="0" loading="lazy"><figcaption>image-20201007144900565</figcaption></figure>
<p><strong>解析：</strong></p>
<p>主机和Web服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与Web服务器中的<strong>Web服务器应用进程</strong>之间基于<strong>网络的通信</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/95faa166c7092fd359e045e303279ee5b8a29dd9.png" alt="image-20201007145242020" tabindex="0" loading="lazy"><figcaption>image-20201007145242020</figcaption></figure>
<p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p>
<p><strong>1、发送方发送</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/70d84351961468d66922fd9b65c6ac4b22b7ef01.png" alt="image-20201007145441370" tabindex="0" loading="lazy"><figcaption>image-20201007145441370</figcaption></figure>
<blockquote>
<p>第一步：</p>
<ul>
<li><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></li>
<li>应用层将<strong>HTTP请求报文</strong>交付给<strong>运输层</strong>处理</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/309be4fb8552c2cca03121de7d8579a3d738245d.png" alt="image-20201007145720661" tabindex="0" loading="lazy"><figcaption>image-20201007145720661</figcaption></figure>
<blockquote>
<p>第二步：</p>
<ul>
<li><strong>运输层</strong>给<strong>HTTP请求报文</strong>添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></li>
<li><strong>TCP报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</li>
<li><strong>运输层</strong>将<strong>TCP报文段</strong>交付给<strong>网络层</strong>处理</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/dd2341c9a77d4a948817353a462c7745a3c1e952.png" alt="image-20201007150234909" tabindex="0" loading="lazy"><figcaption>image-20201007150234909</figcaption></figure>
<blockquote>
<p>第三步：</p>
<ul>
<li><strong>网络层</strong>给<strong>TCP报文段</strong>添加一个<strong>IP首部</strong>，使之成为<strong>IP数据报</strong></li>
<li><strong>IP数据报的首部格式</strong>作用是使<strong>IP数据报</strong>可以在互联网传输，也就是被路由器转发</li>
<li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong>处理</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/78c3aaf6003da97d3ee0ea09ee52761b51f68e60.png" alt="image-20201007150723365" tabindex="0" loading="lazy"><figcaption>image-20201007150723365</figcaption></figure>
<blockquote>
<p>第四步：</p>
<ul>
<li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong>     （图示右边为首部，左边为尾部）</li>
<li>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</li>
<li>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</li>
<li><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/8f27b530c6c98e030b8831702e5483154f066a2e.png" alt="image-20201007151342502" tabindex="0" loading="lazy"><figcaption>image-20201007151342502</figcaption></figure>
<blockquote>
<p>第五步：</p>
<ul>
<li><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络N1假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li>
<li><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</li>
<li><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/601714d30daaaec12de6e0b239d193d0eab42f61.png" alt="image-20201007151900254" tabindex="0" loading="lazy"><figcaption>image-20201007151900254</figcaption></figure>
<blockquote>
<p>第六步：</p>
<ul>
<li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li>
</ul>
</blockquote>
<p><strong>2、路由器转发</strong></p>
<img src="https://i0.hdslb.com/bfs/album/2ee951074c539863dbbc538c692a6555cd8ea0f4.png" alt="image-20201007152029458" style="zoom:50%;">
<img src="https://i0.hdslb.com/bfs/album/282fdf40a7bce81af474c1894fe0c9c1f20b2b17.png" alt="image-20201007152138961" style="zoom:50%;">
<img src="https://i0.hdslb.com/bfs/album/13765c490f6d51c911820c5b090f63d212086aeb.png" alt="image-20201007152627778" style="zoom:50%;">
<blockquote>
<p>在路由器中</p>
<ul>
<li><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></li>
<li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></li>
<li><strong>网络层</strong>解析<strong>IP数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></li>
</ul>
</blockquote>
<img src="https://i0.hdslb.com/bfs/album/4e5f180a8bc2d5fc011bc168b2412f2039dc7530.png" alt="image-20201007152650863" style="zoom:50%;">
<img src="https://i0.hdslb.com/bfs/album/95f76d5b9fc49b86ff26aba1425f12b062430b45.png" alt="image-20201007152812431" style="zoom:50%;">
<img src="https://i0.hdslb.com/bfs/album/ab026a29dbbdbe9410722d9082ed264dbd672fc6.png" alt="image-20201007153714840" style="zoom:50%;">
<blockquote>
<p>在路由器中</p>
<ul>
<li>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</li>
<li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong></li>
<li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></li>
<li><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></li>
<li><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li>
<li>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></li>
</ul>
</blockquote>
<p><strong>3、接收方接收</strong></p>
<blockquote>
<p>和发送方（主机）发送过程的封装正好是反着来</p>
<p>在Web 服务器上</p>
<ul>
<li><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li>
<li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></li>
<li><strong>网络层</strong>将<strong>IP数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></li>
<li><strong>运输层</strong>将<strong>TCP报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></li>
<li><strong>应用层</strong>对<strong>HTTP请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></li>
</ul>
<p><strong>发回响应报文的步骤和之前过程类似</strong></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/78f7345d50d6224b6512e10ea56bcb8d0c0231d2.png" alt="image-20201007155051275" tabindex="0" loading="lazy"><figcaption>image-20201007155051275</figcaption></figure>
<h3> 6.4 计算机网络体系结构中的专用术语</h3>
<p>以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP/IP的四层体系结构和五层协议体系结构</p>
<p><strong>实体</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/0e53315c6c6f228722034e4817a669198f7510b3.png" alt="image-20201007155444920" tabindex="0" loading="lazy"><figcaption>image-20201007155444920</figcaption></figure>
<p><strong>协议</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/59a82f21c7235aede29b4fef80bee294395a1c0c.png" alt="image-20201007155545934" tabindex="0" loading="lazy"><figcaption>image-20201007155545934</figcaption></figure>
<blockquote>
<p>协议：控制两个对等实体进行逻辑通信的规则的集合</p>
<p>协议三要素：</p>
<ul>
<li>语法：定义所交换信息的格式</li>
<li>语义：定义收发双方所要完成的操作</li>
<li>同步：定义收发双发的时序关系</li>
</ul>
</blockquote>
<p><strong>服务</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/bdbdc5976e1d8aa98463edf092050aa8ff769f85.png" alt="image-20201007160246561" tabindex="0" loading="lazy"><figcaption>image-20201007160246561</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/35e28e7ed10c54d21c5215691489c1ca21064fb5.png" alt="image-20201016104750288" tabindex="0" loading="lazy"><figcaption>image-20201016104750288</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/04b0538faca2a26ddfd1d17b980a17d443b853a8.png" alt="image-20201007162620250" tabindex="0" loading="lazy"><figcaption>image-20201007162620250</figcaption></figure>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-02-10T13:52:13.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">02 【计算机网络-物理层】</title>
    <id>https://blog.dselegent.cf/professional_knowledge/computer_network/02.html</id>
    <link href="https://blog.dselegent.cf/professional_knowledge/computer_network/02.html"/>
    <updated>2023-02-10T13:52:13.000Z</updated>
    <summary type="html"><![CDATA[<h1> 02 【计算机网络-物理层】</h1>
<h2> 1.物理层的基本概念</h2>
<figure><img src="https://i0.hdslb.com/bfs/album/89c84be25b0ca67655a9df89b183c141a8c82ffe.png" alt="image-20201008130211749" tabindex="0" loading="lazy"><figcaption>image-20201008130211749</figcaption></figure>
<h2> 2.物理层下面的传输媒体</h2>
<p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p>]]></summary>
    <content type="html"><![CDATA[<h1> 02 【计算机网络-物理层】</h1>
<h2> 1.物理层的基本概念</h2>
<figure><img src="https://i0.hdslb.com/bfs/album/89c84be25b0ca67655a9df89b183c141a8c82ffe.png" alt="image-20201008130211749" tabindex="0" loading="lazy"><figcaption>image-20201008130211749</figcaption></figure>
<h2> 2.物理层下面的传输媒体</h2>
<p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p>
<p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p>
<h3> 2.1 导引型传输媒体</h3>
<p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p>
<p><strong>同轴电缆</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/615143d01daac0ff5dc408cd18abb6f25fdd65c9.png" alt="image-20201008132050917" tabindex="0" loading="lazy"><figcaption>image-20201008132050917</figcaption></figure>
<p><strong>双绞线</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/17e997a255e1991023a015da56043bfec0af547e.png" alt="image-20201008132225715" tabindex="0" loading="lazy"><figcaption>image-20201008132225715</figcaption></figure>
<p><strong>光纤</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/73cd04aabfef2af68281ef9a3a2e642d4b290fb1.png" alt="image-20201008132403903" tabindex="0" loading="lazy"><figcaption>image-20201008132403903</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/2844a0b74e8d422b0b99322d5f4aaf6bf69f449e.png" alt="image-20201011001240573" tabindex="0" loading="lazy"><figcaption>image-20201011001240573</figcaption></figure>
<blockquote>
<p><strong>多模光纤</strong></p>
<ul>
<li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li>
</ul>
<p><strong>单模光纤</strong></p>
<ul>
<li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li>
</ul>
</blockquote>
<p><strong>电力线</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/59378d3313f6fc33379f21d174ec7903b21842bb.png" alt="image-20201008132709015" tabindex="0" loading="lazy"><figcaption>image-20201008132709015</figcaption></figure>
<h3> 2.2 非导引型传输媒体</h3>
<p>非导引型传输媒体是指自由空间。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/5210b809ee668d0510dd5cb510276bc8f1c11c79.png" alt="image-20201008132857833" tabindex="0" loading="lazy"><figcaption>image-20201008132857833</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/46c60e6f423f7e0f2e75c1285ef43af172aeaa91.png" alt="image-20201008132943176" tabindex="0" loading="lazy"><figcaption>image-20201008132943176</figcaption></figure>
<p><strong>无线电波</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/c8a059448e0fc5ae358551e844585f80d6b2db0e.png" alt="image-20201008133135659" tabindex="0" loading="lazy"><figcaption>image-20201008133135659</figcaption></figure>
<p><strong>微波</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/d120134ecf49989ac9b54b9c0c1140ee749d2e7d.png" alt="image-20201008133317293" tabindex="0" loading="lazy"><figcaption>image-20201008133317293</figcaption></figure>
<p><strong>红外线</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/5fac2b9c6e021aa2721564c6f00d8b21df0ddf29.png" alt="image-20201008133421986" tabindex="0" loading="lazy"><figcaption>image-20201008133421986</figcaption></figure>
<p><strong>可见光</strong></p>
<p><a href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&amp;fromid=5675729&amp;fr=aladdin" target="_blank" rel="noopener noreferrer">LIFI</a></p>
<figure><img src="https://i0.hdslb.com/bfs/album/69de28b04003ef7d33dd53c044fd2bdcd2ff1599.png" alt="image-20201008133718810" tabindex="0" loading="lazy"><figcaption>image-20201008133718810</figcaption></figure>
<h2> 3.传输方式</h2>
<h3> 3.1 串行传输和并行传输</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/7f4a59c70db113112596ca14878551fe6557f53e.png" alt="image-20201008135603009" tabindex="0" loading="lazy"><figcaption>image-20201008135603009</figcaption></figure>
<blockquote>
<p><strong>串行传输</strong>：</p>
<ul>
<li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li>
</ul>
<p><strong>并行传输</strong>：</p>
<ul>
<li>
<p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p>
</li>
<li>
<p>并行传输的优点是比串行传输的速度n倍，但成本高</p>
</li>
</ul>
<p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p>
</blockquote>
<h3> 3.2 同步传输和异步传输</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/32aa62d789fdb11cd84e01a2dc7ef6c92a342a04.png" alt="image-20201008140209430" tabindex="0" loading="lazy"><figcaption>image-20201008140209430</figcaption></figure>
<blockquote>
<p><strong>同步传输</strong>：</p>
<ul>
<li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li>
<li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li>
<li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li>
</ul>
<p>所以要使收发双发时钟保持同步</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/96d4250a400a9d4d64b559150a09ffe8f472e83b.png" alt="image-20201008140850958" tabindex="0" loading="lazy"><figcaption>image-20201008140850958</figcaption></figure>
<blockquote>
<p><strong>异步传输</strong>：</p>
<ul>
<li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li>
<li>接收端仅在每个字节的起始处对字节内的比特实现同步</li>
<li>通常在每个字节前后分别加上起始位和结束位</li>
</ul>
</blockquote>
<h3> 3.3 单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h3>
<p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p>
<p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p>
<p><strong>单向通信</strong>：</p>
<p>又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型</p>
<figure><img src="https://i0.hdslb.com/bfs/album/bdecda579e158405657724ae7f4f9a2770b12784.png" alt="image-20201008141345239" tabindex="0" loading="lazy"><figcaption>image-20201008141345239</figcaption></figure>
<p><strong>双向交替通信</strong>：</p>
<p>又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来</p>
<figure><img src="https://i0.hdslb.com/bfs/album/4fce36d70120961b7c41faaeb5c9a6fe6bb3a1ff.png" alt="image-20201008141921924" tabindex="0" loading="lazy"><figcaption>image-20201008141921924</figcaption></figure>
<p><strong>双向同时通信</strong>：</p>
<p>又称为<strong>全双工通信</strong>，即通信的双发可以同时发送和接收信息。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e4c67e13c081f971ca0f95ac3f48425cb8d58cab.png" alt="image-20201008142037846" tabindex="0" loading="lazy"><figcaption>image-20201008142037846</figcaption></figure>
<blockquote>
<p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p>
<p><strong>双向同时通信</strong>的传输效率最高</p>
</blockquote>
<h2> 4.编码与调制</h2>
<figure><img src="https://i0.hdslb.com/bfs/album/1387f21c177d7a07124473ff31fbebb3ba6f1484.png" alt="image-20201008144616896" tabindex="0" loading="lazy"><figcaption>image-20201008144616896</figcaption></figure>
<blockquote>
<p><strong>常用术语</strong></p>
<ul>
<li>
<p><strong>数据 (data)</strong> —— 运送消息的实体。</p>
</li>
<li>
<p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。</p>
</li>
<li>
<p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。</p>
</li>
<li>
<p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。</p>
</li>
<li>
<p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p>
</li>
<li>
<p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p>
</li>
<li>
<p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>  (modulation)。</p>
</li>
</ul>
</blockquote>
<p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d53a93f162269372a667d89a5687ca97812e5fc2.png" alt="image-20201008145747263" tabindex="0" loading="lazy"><figcaption>image-20201008145747263</figcaption></figure>
<h3> 4.1 传输媒体与信道的关系</h3>
<blockquote>
<p><strong>信道的几个基本概念</strong></p>
<ul>
<li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li>
<li><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。</li>
</ul>
</blockquote>
<p>严格来说，传输媒体不能和信道划等号</p>
<p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p>
<figure><img src="https://i0.hdslb.com/bfs/album/db80477b58f14f1dd661357459855f67dc048f13.png" alt="image-20201008145304974" tabindex="0" loading="lazy"><figcaption>image-20201008145304974</figcaption></figure>
<p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e05abde38e55f601616ed928ffb3f0c3b6688a16.png" alt="image-20201008145329540" tabindex="0" loading="lazy"><figcaption>image-20201008145329540</figcaption></figure>
<blockquote>
<p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p>
</blockquote>
<h3> 4.2 常用编码</h3>
<p><strong>不归零编码</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/bbf571da318ce5f7232f36bdb4ef72e5549eb39f.png" alt="image-20201008150058039" tabindex="0" loading="lazy"><figcaption>image-20201008150058039</figcaption></figure>
<blockquote>
<ul>
<li>
<p>正电平表示比特1/0</p>
</li>
<li>
<p>负电平表示比特0/1</p>
</li>
</ul>
<p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/8d33fdf576b7b71c31e556a43dc0927bd70480b6.png" alt="image-20201008150528228" tabindex="0" loading="lazy"><figcaption>image-20201008150528228</figcaption></figure>
<blockquote>
<p>这需要发送方的发送与接收方的接收做到严格的同步</p>
<ul>
<li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li>
<li><strong>但是</strong>对于计算机网络，<strong>宁愿利用这根传输线传输数据信号</strong>，而不是传输时钟信号</li>
</ul>
<p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p>
</blockquote>
<p><strong>归零编码</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/8a864afbe3d0e9389e22afc4a8dc0c7657155e75.png" alt="image-20201008195033189" tabindex="0" loading="lazy"><figcaption>image-20201008195033189</figcaption></figure>
<img src="https://i0.hdslb.com/bfs/album/705d506fc2d6fe65aa5c426de458c2c3dd38d4a6.png" alt="image-20201008151347028" style="zoom:67%;">
<blockquote>
<p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p>
</blockquote>
<p><strong>曼彻斯特编码</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/ed7eb5368ba261bb90725230e26a9b7db6f29b52.png" alt="image-20201008195148727" tabindex="0" loading="lazy"><figcaption>image-20201008195148727</figcaption></figure>
<blockquote>
<p>在每个码元时间的中间时刻，信号都会发生跳变</p>
<ul>
<li>负跳变表示比特1/0</li>
<li>正跳变表示比特0/1</li>
<li>码元中间时刻的跳变即表示时钟，又表示数据</li>
</ul>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
<p>传统以太网使用的就是曼切斯特编码</p>
</blockquote>
<p><strong>差分曼彻斯特编码</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/fa7c179a99b52c3f57042a54151fd40402e503e0.png" alt="image-20201008195235561" tabindex="0" loading="lazy"><figcaption>image-20201008195235561</figcaption></figure>
<blockquote>
<p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p>
<ul>
<li><strong>跳变仅表示时钟</strong></li>
<li><strong>码元开始处电平是否变换表示数据</strong>
<ul>
<li>变化表示比特1/0</li>
<li>不变化表示比特0/1</li>
</ul>
</li>
</ul>
<p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p>
<p>比曼彻斯特编码变化少，更适合较高的传输速率</p>
</blockquote>
<p><strong>总结</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/14902e98c6b76ed9a5a3a75a589e7fcc19747351.png" alt="image-20201008153522501" tabindex="0" loading="lazy"><figcaption>image-20201008153522501</figcaption></figure>
<h3> 4.3 调制</h3>
<p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK/直接序列扩频DSSS/正交频分复用OFDM等<strong>调制</strong>方式。</p>
<p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p>
<p><strong>基本调制方法</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/4c85339056008708ddfcda36c8a98768a7936998.png" alt="image-20201008155429044" tabindex="0" loading="lazy"><figcaption>image-20201008155429044</figcaption></figure>
<blockquote>
<ul>
<li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li>
<li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li>
<li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li>
</ul>
<p>但是使用基本调制方法，1个码元只能包含1个比特信息</p>
</blockquote>
<p><strong>混合调制</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/f54564bdd69129f4a75e05f8c2641b4cb9d65cc8.png" alt="image-20201008155804617" tabindex="0" loading="lazy"><figcaption>image-20201008155804617</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/60f917eb61030809703f24c2b8698ae7864cc595.png" alt="image-20201008155835940" tabindex="0" loading="lazy"><figcaption>image-20201008155835940</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/c13076d53a09b655c22c4959c4c126035434bbc4.png" alt="image-20201008155955169" tabindex="0" loading="lazy"><figcaption>image-20201008155955169</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/0c7b6cd16c87e1a184dbd9718fa32e0d23ece1cc.png" alt="image-20201008160133748" tabindex="0" loading="lazy"><figcaption>image-20201008160133748</figcaption></figure>
<blockquote>
<p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/9b924f697d05864ff7e951b04ab273c025cad9c4.png" alt="image-20201008160208060" tabindex="0" loading="lazy"><figcaption>image-20201008160208060</figcaption></figure>
<h3> 4.4 码元</h3>
<p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p>
<h2> 5.信道的极限容量</h2>
<ul>
<li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</li>
<li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/8532c2f7e37d8a96d7129eac4b6c27e3a42ba1dd.png" alt="image-20201010204336400" tabindex="0" loading="lazy"><figcaption>image-20201010204336400</figcaption></figure>
<p>失真的原因：</p>
<ul>
<li>码元传输的速率越高</li>
<li>信号传输的距离越远</li>
<li>噪声干扰越大</li>
<li>传输媒体质量越差</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/14f3460d0c3a0f7a36f6cd1e08f682a72d593b4b.png" alt="image-20201010204818976" tabindex="0" loading="lazy"><figcaption>image-20201010204818976</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/19eebb6417b05f93c404728593acefedb396b015.png" alt="image-20201010204928756" tabindex="0" loading="lazy"><figcaption>image-20201010204928756</figcaption></figure>
<p>奈氏准则和香农公式对比：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/978065c00572f2a2330ca0662ef6b383df7d040d.png" alt="image-20201010205029346" tabindex="0" loading="lazy"><figcaption>image-20201010205029346</figcaption></figure>
<h2> 6.信道复用技术</h2>
<p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p>
<h3> 6.1 频分复用、时分复用和统计时分复用</h3>
<p>复用 (multiplexing) 是通信技术中的基本概念。</p>
<p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/ced33d37746e632aea6635fc64b07cd6263ebd22.png" alt="image-20201011001949479" tabindex="0" loading="lazy"><figcaption>image-20201011001949479</figcaption></figure>
<p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p>
<ul>
<li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li>
<li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/9cc146037bbe87a34df067933bc9b6931e5d6da9.png" alt="image-20201011002236208" tabindex="0" loading="lazy"><figcaption>image-20201011002236208</figcaption></figure>
<p><strong>时分复用TDM (Time Division Multiplexing)</strong></p>
<ul>
<li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li>
<li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li>
<li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/50d1ed255dc48c50445e964bf10ad5cb73a5c56b.png" alt="image-20201011002540041" tabindex="0" loading="lazy"><figcaption>image-20201011002540041</figcaption></figure>
<ul>
<li><strong>时分复用可能会造成线路资源的浪费</strong>
<ul>
<li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li>
</ul>
</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/d4dee79a86494095dace27bb2798983a0c45e331.png" alt="image-20201011002842704" tabindex="0" loading="lazy"><figcaption>image-20201011002842704</figcaption></figure>
<p><strong>统计时分复用 STDM  (Statistic TDM)</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/3a0a006f9044ca34bc31172176ba257f2672a1d9.png" alt="image-20201011002953703" tabindex="0" loading="lazy"><figcaption>image-20201011002953703</figcaption></figure>
<h3> 6.2 波分复用</h3>
<p>波分复用 WDM(Wavelength Division Multiplexing)</p>
<figure><img src="https://i0.hdslb.com/bfs/album/efbdee3e37cb8a3e0f8673eb17fcff3d639c830a.png" alt="image-20201011003214653" tabindex="0" loading="lazy"><figcaption>image-20201011003214653</figcaption></figure>
<h3> 6.3 码分复用</h3>
<p>码分复用 CDM  (Code Division Multiplexing)</p>
<ul>
<li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li>
<li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li>
<li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>
</ul>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-02-10T13:52:13.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">03 【计算机网络-数据链路层】</title>
    <id>https://blog.dselegent.cf/professional_knowledge/computer_network/03.html</id>
    <link href="https://blog.dselegent.cf/professional_knowledge/computer_network/03.html"/>
    <updated>2023-02-10T14:01:44.000Z</updated>
    <summary type="html"><![CDATA[<h1> 03 【计算机网络-数据链路层】</h1>
<h2> 1.数据链路层概述</h2>
<h3> 1.1 概述</h3>
<p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p>
<p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/5acd6abce2b08725ac2a7dd80851f7d8e630bdd4.png" alt="image-20201011102531462" tabindex="0" loading="lazy"><figcaption>image-20201011102531462</figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<h1> 03 【计算机网络-数据链路层】</h1>
<h2> 1.数据链路层概述</h2>
<h3> 1.1 概述</h3>
<p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p>
<p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/5acd6abce2b08725ac2a7dd80851f7d8e630bdd4.png" alt="image-20201011102531462" tabindex="0" loading="lazy"><figcaption>image-20201011102531462</figcaption></figure>
<p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/9115e344ee5bf9733f781c15466cee9eb4e258fb.png" alt="image-20201014004326549" tabindex="0" loading="lazy"><figcaption>image-20201014004326549</figcaption></figure>
<p><strong>从层次上来看数据的流动</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/2bca20982a774262eefe6738984d26531ca55900.png" alt="image-20201011102618878" tabindex="0" loading="lazy"><figcaption>image-20201011102618878</figcaption></figure>
<p><strong>仅从数据链路层观察帧的流动</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/7812d681300380a970b8504a8bffe4d7fa3c3a1d.png" alt="image-20201011102653161" tabindex="0" loading="lazy"><figcaption>image-20201011102653161</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/09daab5f85d465d7436aacfa73466acd0de80f40.png" alt="image-20201011102733584" tabindex="0" loading="lazy"><figcaption>image-20201011102733584</figcaption></figure>
<blockquote>
<p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p>
<p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p>
</blockquote>
<p><strong>数据链路层使用的信道</strong></p>
<p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/258055a8dec44ecfae4cafc621bc7451220d24d1.png" alt="image-20201014004459744" tabindex="0" loading="lazy"><figcaption>image-20201014004459744</figcaption></figure>
<blockquote>
<p><strong>局域网属于数据链路层</strong></p>
<p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p>
<p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p>
</blockquote>
<h3> 1.2 三个重要问题</h3>
<p>数据链路层传送的协议数据单元是<strong>帧</strong></p>
<p><strong>封装成帧</strong></p>
<ul>
<li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li>
<li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/64a59ea04d3af21d86d4331b66ef954ca37189a9.png" alt="image-20201011103650253" tabindex="0" loading="lazy"><figcaption>image-20201011103650253</figcaption></figure>
<p><strong>差错控制</strong></p>
<p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/a08184a9dc35e7abb6d67b906509bdb521627d7c.png" alt="image-20201011103917512" tabindex="0" loading="lazy"><figcaption>image-20201011103917512</figcaption></figure>
<p><strong>可靠传输</strong></p>
<p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p>
<p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p>
<p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/deaac3db7acbd5242c0326abe10f8add1ec98c1d.png" alt="image-20201011105314053" tabindex="0" loading="lazy"><figcaption>image-20201011105314053</figcaption></figure>
<blockquote>
<p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p>
</blockquote>
<p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p>
<p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p>
<figure><img src="https://i0.hdslb.com/bfs/album/64b336f8a3d782b6d1b2c3f1e416561c0026fb80.png" alt="image-20201011105824466" tabindex="0" loading="lazy"><figcaption>image-20201011105824466</figcaption></figure>
<p>可以用编址（地址）的来解决</p>
<p>将帧的目的地址添加在帧中一起传输</p>
<figure><img src="https://i0.hdslb.com/bfs/album/fc1c8d9130f3ae5bc555aa626074f34e31b88a22.png" alt="image-20201011110017415" tabindex="0" loading="lazy"><figcaption>image-20201011110017415</figcaption></figure>
<p>还有数据碰撞问题</p>
<figure><img src="https://i0.hdslb.com/bfs/album/f8929a3b18bf0da1abadf176450bde1e23777cc0.png" alt="image-20201011110129994" tabindex="0" loading="lazy"><figcaption>image-20201011110129994</figcaption></figure>
<blockquote>
<p>随着技术的发展，交换技术的成熟，</p>
<p>在 有线（局域网）领域 使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<s>共享式局域网</s></p>
<p>在无线局域网中仍然使用的是共享信道技术</p>
</blockquote>
<h2> 2.封装成帧</h2>
<h3> 2.1 介绍</h3>
<p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p>
<ul>
<li><strong>帧头和帧尾中包含有重要的控制信息</strong></li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/26929448b98c7d409505de3e8d984f3cd90dae8e.png" alt="image-20201011110851301" tabindex="0" loading="lazy"><figcaption>image-20201011110851301</figcaption></figure>
<p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p>
<p>答：需要帧头和帧尾来做<strong>帧定界</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/c99e0705b3f550958ee4add50ee9f9d078d4083e.png" alt="image-20201011111334052" tabindex="0" loading="lazy"><figcaption>image-20201011111334052</figcaption></figure>
<p>但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p>
<figure><img src="https://i0.hdslb.com/bfs/album/bfb44c1c113effe7e1857b4d25b2f6c63d3fc041.png" alt="image-20201011111729324" tabindex="0" loading="lazy"><figcaption>image-20201011111729324</figcaption></figure>
<blockquote>
<p>前导码</p>
<ul>
<li>前同步码：作用是使接收方的时钟同步</li>
<li>帧开始定界符：表明其后面紧跟着的就是MAC帧</li>
</ul>
</blockquote>
<p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p>
<figure><img src="https://i0.hdslb.com/bfs/album/648a93cbe99ea56ded9973ba634d11f5d18a1164.png" alt="image-20201011112450187" tabindex="0" loading="lazy"><figcaption>image-20201011112450187</figcaption></figure>
<h3> 2.2 透明传输</h3>
<blockquote>
<p><strong>透明</strong></p>
<p>指某一个实际存在的事物看起来却好像不存在一样。</p>
</blockquote>
<p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p>
<p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中，  恰好也包含这个特定数值，接收方就不能正确接收</p>
<figure><img src="https://i0.hdslb.com/bfs/album/128f2e7c81be1eeeb75e9c7410426111396307d4.png" alt="image-20201011113207944" tabindex="0" loading="lazy"><figcaption>image-20201011113207944</figcaption></figure>
<blockquote>
<p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p>
</blockquote>
<p><strong>解决透明传输问题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/ac87ac6c3fc01eb6ed6b42401020a2aeaf650731.png" alt="image-20201011113804721" tabindex="0" loading="lazy"><figcaption>image-20201011113804721</figcaption></figure>
<ul>
<li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li>
<li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li>
<li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li>
</ul>
<p><strong>帧的数据部分长度</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/a68765328d9398e6ce0d74e59e6f71af08ac8a19.png" alt="image-20201011115008209" tabindex="0" loading="lazy"><figcaption>image-20201011115008209</figcaption></figure>
<h3> 2.3 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/d1a29dbf218cd94afd0afb11636a33e6bee2554a.png" alt="image-20201011115049672" tabindex="0" loading="lazy"><figcaption>image-20201011115049672</figcaption></figure>
<h2> 3.差错检测</h2>
<h3> 3.1 介绍</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/f9b3ab2770dbb0b7de73a4fc330f816d7bd647ce.png" alt="image-20201011133757804" tabindex="0" loading="lazy"><figcaption>image-20201011133757804</figcaption></figure>
<h3> 3.2 奇偶校验</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/dca39de867f308ab84ccd6b9407d1fd62d1caf80.png" alt="image-20201011234428217" tabindex="0" loading="lazy"><figcaption>image-20201011234428217</figcaption></figure>
<h3> 3.3 循环冗余校验CRC(Cyclic Redundancy Check)</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/15197f104d72cc63bee36400908fc65932ca890b.png" alt="image-20201011234605045" tabindex="0" loading="lazy"><figcaption>image-20201011234605045</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/324e193b55e43f7d6fc53643d2e4ce2e493aa9b2.png" alt="image-20201011234701845" tabindex="0" loading="lazy"><figcaption>image-20201011234701845</figcaption></figure>
<p><strong>例题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/e06e7e2430ecd906dd224e85cdbe3a2c2f065649.png" alt="image-20201011235128869" tabindex="0" loading="lazy"><figcaption>image-20201011235128869</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/52d321cb2ed160b78ff229353be7bd4ac7f785bf.png" alt="image-20201011235325022" tabindex="0" loading="lazy"><figcaption>image-20201011235325022</figcaption></figure>
<p><strong>总结</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/c8f62293433cdfb476c48a07aa053cc089e47fd6.png" alt="image-20201011235726437" tabindex="0" loading="lazy"><figcaption>image-20201011235726437</figcaption></figure>
<blockquote>
<p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p>
</blockquote>
<h2> 4.可靠传输</h2>
<h3> 4.1 基本概念</h3>
<p><strong>下面是比特差错</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/d9b470075d05446965ea05b806289928d1b3f9a7.png" alt="image-20201012153605893" tabindex="0" loading="lazy"><figcaption>image-20201012153605893</figcaption></figure>
<p><strong>其他传输差错</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/2542c8c3d4cfd1f36f926c5b5cf39c8bb80c9641.png" alt="image-20201012153811724" tabindex="0" loading="lazy"><figcaption>image-20201012153811724</figcaption></figure>
<ul>
<li>分组丢失</li>
</ul>
<p>路由器输入队列快满了，主动丢弃收到的分组</p>
<figure><img src="https://i0.hdslb.com/bfs/album/1c7c149c5cda205a4fb60990d346414a0293d9d2.png" alt="image-20201012154910921" tabindex="0" loading="lazy"><figcaption>image-20201012154910921</figcaption></figure>
<ul>
<li>分组失序</li>
</ul>
<p>数据并未按照发送顺序依次到达接收端</p>
<figure><img src="https://i0.hdslb.com/bfs/album/b7279978d099272fc4e4e81557d194007ba66f16.png" alt="image-20201012155300937" tabindex="0" loading="lazy"><figcaption>image-20201012155300937</figcaption></figure>
<ul>
<li>分组重复</li>
</ul>
<p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p>
<figure><img src="https://i0.hdslb.com/bfs/album/952edf1f47dae7d57e72c8d451b26be61008d01f.png" alt="image-20201012160026362" tabindex="0" loading="lazy"><figcaption>image-20201012160026362</figcaption></figure>
<h3> 4.2 三种可靠协议</h3>
<ul>
<li>停止-等待协议SW</li>
<li>回退N帧协议GBN</li>
<li>选择重传协议SR</li>
</ul>
<blockquote>
<p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p>
</blockquote>
<h3> 4.3 停止-等待协议</h3>
<h4> 4.3.1 停止-等待协议可能遇到的四个问题</h4>
<p><strong>确认与否认</strong></p>
<img src="https://i0.hdslb.com/bfs/album/c225aafae0e965a907095f756a27ce5cee06539e.png" alt="image-20201012162009780" style="zoom:67%;">
<p><strong>超时重传</strong></p>
<img src="https://i0.hdslb.com/bfs/album/03e31a77eaaec2895fe6bd0fd3202dfcb7f519e6.png" alt="image-20201012162112151" style="zoom:67%;">
<p><strong>确认丢失</strong></p>
<img src="https://i0.hdslb.com/bfs/album/f60c043de38fc51f1263c7023a0edde7151a2d20.png" alt="image-20201012162318298" style="zoom:67%;">
<img src="https://i0.hdslb.com/bfs/album/42e85d3b1b267aca702b85e7392a5a3699598de9.png" alt="image-20201012162348428" style="zoom:67%;">
<blockquote>
<p>既然数据分组需要编号，确认分组是否需要编号？</p>
<p>要。如下图所示</p>
</blockquote>
<p><strong>确认迟到</strong></p>
<img src="https://i0.hdslb.com/bfs/album/6e5aeb4f74c1446b4d59003da864a17ea8beca5e.png" alt="image-20201012162815885" style="zoom:67%;">
<blockquote>
<p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p>
</blockquote>
<p><strong>注意事项</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/bd9da3f3e28383b5c37b46538bd8386412500bfb.png" alt="image-20201012164008780" tabindex="0" loading="lazy"><figcaption>image-20201012164008780</figcaption></figure>
<h4> 4.3.2 停止-等待协议的信道利用率</h4>
<p>假设收发双方之间是一条直通的信道</p>
<ul>
<li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li>
<li><strong>RTT</strong>：是收发双方之间的往返时间</li>
<li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li>
</ul>
<p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p>
<figure><img src="https://i0.hdslb.com/bfs/album/830f0ec4c2598a9cc92770e2c5e4d9d3b87ff03d.png" alt="image-20201012164924635" tabindex="0" loading="lazy"><figcaption>image-20201012164924635</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/20f109d50896a0db277aa434a432e53c9fe4becc.png" alt="image-20201012181005719" tabindex="0" loading="lazy"><figcaption>image-20201012181005719</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/af72bc5df764854245161e587e7091b5f1fba767.png" alt="image-20201012181047665" tabindex="0" loading="lazy"><figcaption>image-20201012181047665</figcaption></figure>
<blockquote>
<p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p>
</blockquote>
<h3> 4.4 回退N帧协议GBN</h3>
<h4> 4.4.1 为什么用回退N帧协议</h4>
<p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p>
<figure><img src="https://i0.hdslb.com/bfs/album/afe52cb97792e7032222354d096e167c1137552e.png" alt="image-20201012190027828" tabindex="0" loading="lazy"><figcaption>image-20201012190027828</figcaption></figure>
<p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p>
<figure><img src="https://i0.hdslb.com/bfs/album/2a9603925d6e1a17b91eb2ff94b1a9a592431b8f.png" alt="image-20201012190632086" tabindex="0" loading="lazy"><figcaption>image-20201012190632086</figcaption></figure>
<h4> 4.4.2 无差错情况流程</h4>
<p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p>
<figure><img src="https://i0.hdslb.com/bfs/album/8089ed6a637a13a18f0b8e84cb15c1a01d44f3ec.png" alt="image-20201012191936466" tabindex="0" loading="lazy"><figcaption>image-20201012191936466</figcaption></figure>
<p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p>
<figure><img src="https://i0.hdslb.com/bfs/album/ee86b4c7024967115a40ecae68fd060f75acb920.png" alt="image-20201012192932035" tabindex="0" loading="lazy"><figcaption>image-20201012192932035</figcaption></figure>
<p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p>
<figure><img src="https://i0.hdslb.com/bfs/album/4c64002b9957631307406425967d290f47921462.png" alt="image-20201012193212419" tabindex="0" loading="lazy"><figcaption>image-20201012193212419</figcaption></figure>
<h4> 4.4.3 累计确认</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/d1ddd8e7e129a5d78de4e6ac98bbbeeb941b3767.png" alt="image-20201012194304696" tabindex="0" loading="lazy"><figcaption>image-20201012194304696</figcaption></figure>
<blockquote>
<p>累计确认</p>
<p>优点:</p>
<ul>
<li>即使确认分组丢失，发送方也可能不必重传</li>
<li>减小接收方的开销</li>
<li>减小对网络资源的占用</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li>
</ul>
</blockquote>
<h4> 4.4.4 有差错情况</h4>
<p>例如</p>
<p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p>
<figure><img src="https://i0.hdslb.com/bfs/album/118b7e3978e793392f0cbba4d39302427fa7cd2f.png" alt="image-20201012195440780" tabindex="0" loading="lazy"><figcaption>image-20201012195440780</figcaption></figure>
<p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p>
<figure><img src="https://i0.hdslb.com/bfs/album/7974ee7b2b1f0e17d0a6d4ff2e340528604efb26.png" alt="image-20201012195629368" tabindex="0" loading="lazy"><figcaption>image-20201012195629368</figcaption></figure>
<p>接收同样也不能接收它们，讲它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/ad50843ccec751291b2cf31810117dcd63aee331.png" alt="image-20201012195836902" tabindex="0" loading="lazy"><figcaption>image-20201012195836902</figcaption></figure>
<p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p>
<figure><img src="https://i0.hdslb.com/bfs/album/0a2ea17c814f42f6bcd13d55c58454325522ee11.png" alt="image-20201012200120166" tabindex="0" loading="lazy"><figcaption>image-20201012200120166</figcaption></figure>
<p>如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p>
<figure><img src="https://i0.hdslb.com/bfs/album/ec046d9e17ae7229a16105aabfef0903f4762c8c.png" alt="image-20201012200454557" tabindex="0" loading="lazy"><figcaption>image-20201012200454557</figcaption></figure>
<p>若WT超过取值范围，例如WT=8，会出现什么情况？</p>
<figure><img src="https://i0.hdslb.com/bfs/album/4cdb06c0972c6f9f44037b1dda6eab624c4eb032.png" alt="image-20201012201109774" tabindex="0" loading="lazy"><figcaption>image-20201012201109774</figcaption></figure>
<p>习题</p>
<figure><img src="https://i0.hdslb.com/bfs/album/05f4008f6c0888d26c511b27b132eb8bc1514bfc.png" alt="image-20201012202419107" tabindex="0" loading="lazy"><figcaption>image-20201012202419107</figcaption></figure>
<p><strong>总结</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/c66f5efe0d303d1516fc7c0337ad879e7b6fd0a8.png" alt="image-20201012202222138" tabindex="0" loading="lazy"><figcaption>image-20201012202222138</figcaption></figure>
<ul>
<li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li>
<li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li>
<li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li>
</ul>
<h3> 4.5 选择重传协议SR</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/96707e9aeac9c73870d60963bc5450bbaba31405.png" alt="image-20201012203638722" tabindex="0" loading="lazy"><figcaption>image-20201012203638722</figcaption></figure>
<p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=27" target="_blank" rel="noopener noreferrer">具体流程请看视频</a></p>
<p><strong>习题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/67d9d360b95d4f7776151dfbcc7bc7c528e6d866.png" alt="image-20201012205250996" tabindex="0" loading="lazy"><figcaption>image-20201012205250996</figcaption></figure>
<p><strong>总结</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/57a3e7bcc2c42004c61b03844c904ff50721561f.png" alt="image-20201012204742870" tabindex="0" loading="lazy"><figcaption>image-20201012204742870</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/eae3ff4440394afc5d6ae2635d4c28408edace5c.png" alt="image-20201012205133924" tabindex="0" loading="lazy"><figcaption>image-20201012205133924</figcaption></figure>
<hr>
<h2> 5.点对点协议PPP</h2>
<ul>
<li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li>
<li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li>
<li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/71446dbb26911ef7f5eb24a542d3b057eeb5a026.png" alt="image-20201012210844629" tabindex="0" loading="lazy"><figcaption>image-20201012210844629</figcaption></figure>
<ul>
<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/1fceb0cefaf86acd991e999198604c48a617a52c.png" alt="image-20201012211423528" tabindex="0" loading="lazy"><figcaption>image-20201012211423528</figcaption></figure>
<h3> 5.1 帧格式</h3>
<p>必须规定特殊的字符作为帧定界符</p>
<figure><img src="https://i0.hdslb.com/bfs/album/71c2b5c2b997a529dab9c7fa0bc8f117bf5828d1.png" alt="image-20201012211826281" tabindex="0" loading="lazy"><figcaption>image-20201012211826281</figcaption></figure>
<h3> 5.2 透明传输</h3>
<p>必须保证数据传输的透明性</p>
<p>实现透明传输的方法</p>
<ul>
<li>面向字节的异步链路：字节填充法（插入“转义字符”）</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/d5013bd9ebb6974f250809e1ab33fcd934ddd5ee.png" alt="image-20201012212148803" tabindex="0" loading="lazy"><figcaption>image-20201012212148803</figcaption></figure>
<ul>
<li>面向比特的同步链路：比特填充法（插入“比特0”）</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/d6fb32eabe33e61a1a16295a0ef179b5f2b07e6a.png" alt="image-20201012212255550" tabindex="0" loading="lazy"><figcaption>image-20201012212255550</figcaption></figure>
<h3> 5.3 差错检测</h3>
<p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/f6f3c05e615cf632bb5e8d5e32516c10dafc7077.png" alt="image-20201012212558654" tabindex="0" loading="lazy"><figcaption>image-20201012212558654</figcaption></figure>
<h3> 5.4 工作状态</h3>
<ul>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li>
<li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li>
<li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/9783bdebee0a34562325e045ef7396c68d44aabd.png" alt="image-20201012213021860" tabindex="0" loading="lazy"><figcaption>image-20201012213021860</figcaption></figure>
<blockquote>
<p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p>
</blockquote>
<hr>
<h2> 6.媒体接入控制（介质访问控制）——广播信道</h2>
<p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p>
<blockquote>
<p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p>
</blockquote>
<p><strong>局域网的数据链路层</strong></p>
<ul>
<li>局域网最主要的<strong>特点</strong>是：
<ul>
<li>网络为一个单位所拥有；</li>
<li>地理范围和站点数目均有限。</li>
</ul>
</li>
<li>局域网具有如下<strong>主要优点</strong>：
<ul>
<li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li>
<li>提高了系统的可靠性、可用性和残存性。</li>
</ul>
</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/b239bc0c1d1a9a01fb403ea9c0bf17df57251d18.png" alt="image-20201013201521915" tabindex="0" loading="lazy"><figcaption>image-20201013201521915</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/5d748f80f3499d788048b0186bd72fec312c046d.png" alt="image-20201013201533445" tabindex="0" loading="lazy"><figcaption>image-20201013201533445</figcaption></figure>
<p><strong>数据链路层的两个子层</strong></p>
<p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p>
<ol>
<li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li>
<li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li>
</ol>
<p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。
<strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/71d21d368e8348a2a47c0468a2f664dc77fa1a84.png" alt="image-20201013201133903" tabindex="0" loading="lazy"><figcaption>image-20201013201133903</figcaption></figure>
<h3> 6.1 基本概念</h3>
<p>为什么要媒体接入控制（介质访问控制）？</p>
<p><strong>共享信道带来的问题</strong></p>
<p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/1935ebbe4d1c71048038e390ee19e26f29a943ec.png" alt="image-20201013152007335" tabindex="0" loading="lazy"><figcaption>image-20201013152007335</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/51db407eaf11186eda92b2ada2abc537dfb4900b.png" alt="image-20201013152453425" tabindex="0" loading="lazy"><figcaption>image-20201013152453425</figcaption></figure>
<blockquote>
<p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p>
</blockquote>
<h3> 6.2 静态划分信道</h3>
<p><strong>信道复用</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/41fb8a21fb6809f8c79bd3be91214d225c24dc44.png" alt="image-20201013153642544" tabindex="0" loading="lazy"><figcaption>image-20201013153642544</figcaption></figure>
<p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p>
<ul>
<li>
<p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p>
</li>
<li>
<p><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p>
</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/c6b24da7f4c08c6f9b633cb88ec66d2c2819d9da.png" alt="image-20201013153947668" tabindex="0" loading="lazy"><figcaption>image-20201013153947668</figcaption></figure>
<p><strong>时分复用TDM (Time Division Multiplexing)</strong></p>
<ul>
<li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li>
<li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li>
<li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/9f1cbf2953f645f0c762af94418f17f012ab25bf.png" alt="image-20201013154142540" tabindex="0" loading="lazy"><figcaption>image-20201013154142540</figcaption></figure>
<p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/8f549e2afc70c6ba9195e22fb9c7366e6c3f7db6.png" alt="image-20201013202218132" tabindex="0" loading="lazy"><figcaption>image-20201013202218132</figcaption></figure>
<blockquote>
<p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p>
<p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p>
</blockquote>
<p><strong>码分复用 CDM  (Code Division Multiplexing)</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/c74022c4dff1e3c0251d9f70298e4db63dda4bca.png" alt="image-20201013203126625" tabindex="0" loading="lazy"><figcaption>image-20201013203126625</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/b15e8c97c0de85e028204e283f550fc04ca6f025.png" alt="image-20201013203324709" tabindex="0" loading="lazy"><figcaption>image-20201013203324709</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/b47880df32748c06422cf471bae663405adec60d.png" alt="image-20201013203459640" tabindex="0" loading="lazy"><figcaption>image-20201013203459640</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/57e1b921da32c0a50d2c92e44ef9ac9fd4aa999a.png" alt="image-20201013203819578" tabindex="0" loading="lazy"><figcaption>image-20201013203819578</figcaption></figure>
<h3> 6.3 动态接入控制</h3>
<p>受控接入</p>
<p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p>
<p><strong>随机接入</strong></p>
<p><strong>重点</strong></p>
<h3> 6.4 随机接入（CSMA/CD协议）</h3>
<p><strong>总线局域网使用协议：CSMA/CD</strong></p>
<h4> 6.4.1 基本概念</h4>
<p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p>
<blockquote>
<p><strong>以太网（Ethernet）<strong>是一种计算机</strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了**以太网（Ethernet）**的技术标准</p>
<p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/a6a6666bee1c1da1ad53dae858e4688c92b77312.png" alt="image-20201013211620687" tabindex="0" loading="lazy"><figcaption>image-20201013211620687</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/9ea8960c623c6c8f4b793480429c24e99bc1fd95.png" alt="image-20201013213102777" tabindex="0" loading="lazy"><figcaption>image-20201013213102777</figcaption></figure>
<h4> 6.4.2 多址接入MA</h4>
<p>表示许多主机以多点接入的方式连接在一根总线上。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d614cceb5714e1cc6e66572814a9eb4e21c21dbc.png" alt="image-20201013215400688" tabindex="0" loading="lazy"><figcaption>image-20201013215400688</figcaption></figure>
<h4> 6.4.3 载波监听CS</h4>
<p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/6d655ac7aec2961acfe8c9cc3dcbd3f053647e35.png" alt="image-20201013215530979" tabindex="0" loading="lazy"><figcaption>image-20201013215530979</figcaption></figure>
<p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p>
<h4> 6.4.4 碰撞检测CD</h4>
<ul>
<li><strong>“碰撞检测”<strong>就是计算机</strong>边发送数据边检测</strong>信道上的信号电压大小。</li>
<li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li>
<li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li>
<li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li>
<li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li>
<li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/9a2c67a80d95175f3997b253cc89c35a026ee55d.png" alt="image-20201013221240514" tabindex="0" loading="lazy"><figcaption>image-20201013221240514</figcaption></figure>
<blockquote>
<p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p>
<figure><img src="https://i0.hdslb.com/bfs/album/c590d8cec4125d4305ce65065a81d56d61b20576.png" alt="image-20201013221834942" tabindex="0" loading="lazy"><figcaption>image-20201013221834942</figcaption></figure>
<p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p>
</blockquote>
<h4> 6.4.5 CSMA/CD 协议工作流程</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/6533ee2d75a173ff67890633896c5132035e27a4.png" alt="image-20201013221705893" tabindex="0" loading="lazy"><figcaption>image-20201013221705893</figcaption></figure>
<h4> 6.4.6 CSMA/CD 协议工作——争用期（碰撞窗口）</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/6f9db7844f06316f29bbd55092e304e027385a72.png" alt="image-20201013223235305" tabindex="0" loading="lazy"><figcaption>image-20201013223235305</figcaption></figure>
<h4> 6.4.7 CSMA/CD 协议工作——最小帧长</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/c256c9ca131cf24167c38f340e0a7ab3c4e2a032.png" alt="image-20201013224051932" tabindex="0" loading="lazy"><figcaption>image-20201013224051932</figcaption></figure>
<h4> 6.4.8 CSMA/CD 协议工作——最大帧长</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/0c441cc932b91ee2374d728d8b1aac05907c6087.png" alt="image-20201013225400777" tabindex="0" loading="lazy"><figcaption>image-20201013225400777</figcaption></figure>
<h4> 6.4.9 CSMA/CD 协议工作——截断二进制指数退避算法</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/7f114193f64946f2eb21c0f6f3527b6990a20e2a.png" alt="image-20201013230717856" tabindex="0" loading="lazy"><figcaption>image-20201013230717856</figcaption></figure>
<h4> 6.4.10 CSMA/CD 协议工作——信道利用率</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/97bb18a85355008887fe81337e87a56a0526bf2d.png" alt="image-20201013231430295" tabindex="0" loading="lazy"><figcaption>image-20201013231430295</figcaption></figure>
<h4> 6.4.11 CSMA/CD 协议工作——帧接收流程</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/29c1fced049627a6b5751874bcfafe23dbc74c04.png" alt="image-20201013231703302" tabindex="0" loading="lazy"><figcaption>image-20201013231703302</figcaption></figure>
<h4> 6.4.12 CSMA/CD 协议的重要特性</h4>
<ul>
<li>使用 CSMA/CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li>
<li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。</li>
<li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li>
</ul>
<blockquote>
<p>CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p>
<p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CS协议</strong></p>
</blockquote>
<h3> 6.5 随机接入（CSMA/CA协议）</h3>
<p><strong>无线局域网使用的协议：CSMA/CA</strong></p>
<h4> 6.5.1 为什么无线局域网要使用CSMA/CA协议</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/b1d771c50b1b996f5f0ebb6011d417bfd49415e3.png" alt="image-20201014192811760" tabindex="0" loading="lazy"><figcaption>image-20201014192811760</figcaption></figure>
<h4> 6.5.2 帧间间隔IFS（InterFrame Space）</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/e7e399c1a0a02938f0e634c58ba570e8a8125b04.png" alt="image-20201014200149717" tabindex="0" loading="lazy"><figcaption>image-20201014200149717</figcaption></figure>
<h4> 6.5.3 CSMA/CA协议的工作原理</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/c51819994f4a569b8651707c113f82680efde0ac.png" alt="image-20201014200833233" tabindex="0" loading="lazy"><figcaption>image-20201014200833233</figcaption></figure>
<blockquote>
<p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p>
<ul>
<li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li>
</ul>
<p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p>
<ul>
<li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/5c83918730c87bd1839230f103f6bc0b28bd42bc.png" alt="image-20201014201511741" tabindex="0" loading="lazy"><figcaption>image-20201014201511741</figcaption></figure>
<blockquote>
<p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p>
<p>防止多个站点同时发送数据而产生碰撞</p>
</blockquote>
<p><strong>使用退避算法的时机</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/25873aa72701cb3f74c01f195bd7a1cfef6664fa.png" alt="image-20201014201927680" tabindex="0" loading="lazy"><figcaption>image-20201014201927680</figcaption></figure>
<h4> 6.5.4 CSMA/CA协议的退避算法</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/681ef75c2b1ca5b4f00ef0a3a2c060f9b26fbdcc.png" alt="image-20201014202213766" tabindex="0" loading="lazy"><figcaption>image-20201014202213766</figcaption></figure>
<p><strong>退避算法的示例</strong></p>
<figure><img src="https://article.biliimg.com/bfs/article/bd23a7efc8f566a696008d5b505bdbf6ee60d457.png" alt="image-20201014202819851" tabindex="0" loading="lazy"><figcaption>image-20201014202819851</figcaption></figure>
<h4> 6.5.5 CSMA/CA协议的信道预约和虚拟载波监听</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/074311a3ca73ef2e9e0a1c6a3e6ea5206988ea6c.png" alt="image-20201014203119710" tabindex="0" loading="lazy"><figcaption>image-20201014203119710</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/78c1280617dacd92f36639660b96e59e2e97ac85.png" alt="image-20201014203506878" tabindex="0" loading="lazy"><figcaption>image-20201014203506878</figcaption></figure>
<p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/c2d11ba30b0872eb2a30e22642a224dbc587a85c.png" alt="image-20201014203859033" tabindex="0" loading="lazy"><figcaption>image-20201014203859033</figcaption></figure>
<h2> 7.MAC地址、IP地址以及ARP协议</h2>
<figure><img src="https://i0.hdslb.com/bfs/album/4a6530c54fffd886dc3433bd4eaab3bc4947dcf5.png" alt="image-20201014222831663" tabindex="0" loading="lazy"><figcaption>image-20201014222831663</figcaption></figure>
<h3> 7.1 MAC地址</h3>
<blockquote>
<ul>
<li>使用点对点信道的数据链路层不需要使用地址</li>
<li>使用广播信道的数据链路层必须使用地址来区分各主机</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/a745c4f4aa4b357d805e2574517a226966a9701f.png" alt="image-20201014223659993" tabindex="0" loading="lazy"><figcaption>image-20201014223659993</figcaption></figure>
<h4> 7.1.1 广播信道的数据链路层必须使用地址（MAC）</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/14e01d2bebd0beb889785fc5feef5ab9d7a570e3.png" alt="image-20201014224732019" tabindex="0" loading="lazy"><figcaption>image-20201014224732019</figcaption></figure>
<blockquote>
<p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p>
</blockquote>
<h4> 7.1.2 IEEE 802局域网的MAC地址格式</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/9b5081dd18c8ac659f82089c87c83386b3d64745.png" alt="image-20201014225358570" tabindex="0" loading="lazy"><figcaption>image-20201014225358570</figcaption></figure>
<blockquote>
<p><strong>组织唯一标识符OUI</strong></p>
<ul>
<li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li>
</ul>
<p><strong>网络接口标识符</strong></p>
<ul>
<li>由获得OUI的厂商自行随意分配</li>
</ul>
<p><strong>EUI-48</strong></p>
<ul>
<li>48是这个MAC地址的位数</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/fea8ee4c67cc6b43a796f0bb38c1c20d955f4706.png" alt="image-20201014230248959" tabindex="0" loading="lazy"><figcaption>image-20201014230248959</figcaption></figure>
<blockquote>
<p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p>
</blockquote>
<p><strong>关于无效的 MAC 帧</strong></p>
<ul>
<li>数据字段的长度与长度字段的值不一致；</li>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。</li>
<li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
</ul>
<blockquote>
<p><strong>对于检查出的无效</strong> <strong>MAC</strong> <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong></p>
</blockquote>
<h4> 7.1.3 IEEE 802局域网的MAC地址发送顺序</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/25ce1dd6526be27fa41212788bcb1ed889110eff.png" alt="image-20201014230625182" tabindex="0" loading="lazy"><figcaption>image-20201014230625182</figcaption></figure>
<h4> 7.1.4 单播MAC地址举例</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/f48cfd95d8baec217128a4dd1ca1e40d1c4ddea8.png" alt="image-20201014230822305" tabindex="0" loading="lazy"><figcaption>image-20201014230822305</figcaption></figure>
<blockquote>
<p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/5cb02cbbeb769e7df33a286a085e03e18a382bb9.png" alt="image-20201014231244655" tabindex="0" loading="lazy"><figcaption>image-20201014231244655</figcaption></figure>
<blockquote>
<p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p>
<p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p>
<p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p>
<p>并将该帧交给其上层处理</p>
</blockquote>
<h4> 7.1.5 广播MAC地址举例</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/dfc624b19a04050f8c6fcf84c2aa6f8de870f39c.png" alt="image-20201014231754669" tabindex="0" loading="lazy"><figcaption>image-20201014231754669</figcaption></figure>
<blockquote>
<p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/a82126c5d61e6dc1cf122a0aa77ab327623695f1.png" alt="image-20201014232132424" tabindex="0" loading="lazy"><figcaption>image-20201014232132424</figcaption></figure>
<blockquote>
<p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p>
</blockquote>
<h4> 7.1.6 多播MAC地址举例</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/588d8607e4b8b8b5f35edd6939b23080532bdac6.png" alt="image-20201014232714791" tabindex="0" loading="lazy"><figcaption>image-20201014232714791</figcaption></figure>
<blockquote>
<p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p>
<p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p>
<p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/f219cf9d757a9bed4535765a340ac2c7cc39276a.png" alt="image-20201015001243584" tabindex="0" loading="lazy"><figcaption>image-20201015001243584</figcaption></figure>
<blockquote>
<p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/56eff6c529ca92b83e8b8dafc4b196e5e0580986.png" alt="image-20201015001535528" tabindex="0" loading="lazy"><figcaption>image-20201015001535528</figcaption></figure>
<blockquote>
<p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/0921cdeb48a7d72b8bd074aecdbb15b2d7633be2.png" alt="image-20201015002054876" tabindex="0" loading="lazy"><figcaption>image-20201015002054876</figcaption></figure>
<blockquote>
<p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p>
<p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p>
<p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p>
</blockquote>
<blockquote>
<p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p>
</blockquote>
<h3> 7.2 IP地址</h3>
<p>IP地址属于网络层的范畴，不属于数据链路层的范畴</p>
<p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p>
<h4> 7.2.1 基本概念</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/df95f7ef9488ae70d363474793d060d343512b53.png" alt="image-20201015104441580" tabindex="0" loading="lazy"><figcaption>image-20201015104441580</figcaption></figure>
<h4> 7.2.2 从网络体系结构看IP地址与MAC地址</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/f89c90aedc5adf512b8238f2bb1b62a801dd8a93.png" alt="image-20201015104913755" tabindex="0" loading="lazy"><figcaption>image-20201015104913755</figcaption></figure>
<h4> 7.2.3 数据包转发过程中IP地址与MAC地址的变化情况</h4>
<p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p>
<figure><img src="https://i0.hdslb.com/bfs/album/c8475e19fbf56a85a40624721526d709cf75292a.png" alt="image-20201015105455043" tabindex="0" loading="lazy"><figcaption>image-20201015105455043</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/766b031a44d9b9bc079c67155d8c0810a15b4ca8.png" alt="image-20210103212224961" tabindex="0" loading="lazy"><figcaption>image-20210103212224961</figcaption></figure>
<blockquote>
<p>如何从IP地址找出其对应的MAC地址？</p>
<p>ARP协议</p>
</blockquote>
<h3> 7.3 ARP协议</h3>
<p>如何从IP地址找出其对应的MAC地址？</p>
<p>ARP（地址解析协议）</p>
<h4> 7.3.1 流程</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/44c6127e2927ff0e70c1a9426274b5ab8f24bf11.png" alt="image-20201015113826197" tabindex="0" loading="lazy"><figcaption>image-20201015113826197</figcaption></figure>
<p>ARP高速缓存表</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e9f7106841a2958491e1a7791b78cdfd89c74b06.png" alt="image-20201015114052206" tabindex="0" loading="lazy"><figcaption>image-20201015114052206</figcaption></figure>
<blockquote>
<p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/00052c5f07e78d552f4067533e41d779b1d78f30.png" alt="image-20201015114444263" tabindex="0" loading="lazy"><figcaption>image-20201015114444263</figcaption></figure>
<blockquote>
<p>ARP请求报文有具体的格式，上图的只是简单描述</p>
<p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p>
<p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/c3145a212cd8733e6846fd8c6563571bb9f9f940.png" alt="image-20201015114811501" tabindex="0" loading="lazy"><figcaption>image-20201015114811501</figcaption></figure>
<blockquote>
<p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p>
<p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p>
<p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/4c92c647a356fe5d0bb506a627118f44235c2c31.png" alt="image-20201015115212170" tabindex="0" loading="lazy"><figcaption>image-20201015115212170</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/29cc33c2eaef3b0c7197c30bf70528ef858ea4c3.png" alt="image-20201015115236673" tabindex="0" loading="lazy"><figcaption>image-20201015115236673</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/fef93a06077f3c9aabf1c5594936e3817832cc29.png" alt="image-20201015115252972" tabindex="0" loading="lazy"><figcaption>image-20201015115252972</figcaption></figure>
<p>动态与静态的区别</p>
<figure><img src="https://i0.hdslb.com/bfs/album/6c061a5f1b0021b7a6b01d5373ef9b421996531f.png" alt="image-20201015115831543" tabindex="0" loading="lazy"><figcaption>image-20201015115831543</figcaption></figure>
<p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/ec5f1d6e9936457f1c26cfe5a3125cf968027a54.png" alt="image-20201015120108028" tabindex="0" loading="lazy"><figcaption>image-20201015120108028</figcaption></figure>
<blockquote>
<p>ARP协议的使用是逐段链路进行的</p>
</blockquote>
<h4> 7.3.2 总结</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/21e07b21f9b5baac5f894ac0731ca38bfb901fd5.png" alt="image-20201015120707150" tabindex="0" loading="lazy"><figcaption>image-20201015120707150</figcaption></figure>
<blockquote>
<p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p>
</blockquote>
<hr>
<h2> 8.集线器与交换机的区别</h2>
<h3> 8.1 集线器-在物理层扩展以太网</h3>
<h4> 8.1.1 概念</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/d1584e4b8ac79f61d08db10c6d784ee420c352d5.png" alt="image-20201015144628691" tabindex="0" loading="lazy"><figcaption>image-20201015144628691</figcaption></figure>
<blockquote>
<ul>
<li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li>
<li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</li>
<li><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li>
<li><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA/CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</li>
</ul>
</blockquote>
<h4> 8.1.2 集线器HUB在物理层扩展以太网</h4>
<p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p>
<figure><img src="https://i0.hdslb.com/bfs/album/f17f714b4cb73fbd8f03a30dba00bec65294d93e.png" alt="image-20201015145732275" tabindex="0" loading="lazy"><figcaption>image-20201015145732275</figcaption></figure>
<blockquote>
<ul>
<li><strong>优点</strong>
<ol>
<li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li>
<li>扩大了以太网覆盖的地理范围。</li>
</ol>
</li>
<li><strong>缺点</strong>
<ol>
<li>碰撞域增大了，但总的吞吐量并未提高。</li>
<li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>碰撞域</strong></p>
<ul>
<li><strong>碰撞域（collision domain）<strong>又称为</strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li>
<li>碰撞域越大，发生碰撞的概率越高。</li>
</ul>
<h3> 8.2 以太网交换机-在数据链路层扩展以太网</h3>
<h4> 8.2.1 概念</h4>
<ul>
<li>扩展以太网更常用的方法是在数据链路层进行。</li>
<li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/57a2238b81c5abacc220bb1c854c8aeb4804ccdb.png" alt="image-20201015150620067" tabindex="0" loading="lazy"><figcaption>image-20201015150620067</figcaption></figure>
<blockquote>
<p><strong>网桥</strong></p>
<ul>
<li>网桥工作在数据链路层。</li>
<li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li>
<li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</li>
</ul>
<p><strong>交换机</strong></p>
<ul>
<li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li>
<li>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</li>
<li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li>
</ul>
</blockquote>
<h4> 8.2.2 集线器HUB与交换机SWITCH区别</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/874fba2a13bd5591ca4c2e8e467ab95583bf47ba.png" alt="image-20201015152232158" tabindex="0" loading="lazy"><figcaption>image-20201015152232158</figcaption></figure>
<blockquote>
<p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p>
<p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/f0898b9cce1d1e8cf2ccf37531009623dc7ca482.png" alt="image-20201015152858146" tabindex="0" loading="lazy"><figcaption>image-20201015152858146</figcaption></figure>
<blockquote>
<p><strong>以太网交换机的交换方式</strong></p>
<ul>
<li>存储转发方式
<ul>
<li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li>
</ul>
</li>
<li>直通 (cut-through) 方式
<ul>
<li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li>
<li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li>
</ul>
</li>
</ul>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><strong>对比集线器和交换机</strong></p>
<figure><img src="https://article.biliimg.com/bfs/article/2083c0594b3f0472d99893cfc0b310912ec5650f.png" alt="image-20201015153907268" tabindex="0" loading="lazy"><figcaption>image-20201015153907268</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/0a9b53c24dd4dbcf7b12cfaee873618fff1a5456.png" alt="image-20201015154523036" tabindex="0" loading="lazy"><figcaption>image-20201015154523036</figcaption></figure>
<blockquote>
<p>多台主机同时给另一台主机发送单播帧</p>
<p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p>
<p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p>
<p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p>
</blockquote>
<p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p>
<p><strong>单播</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/ee67bac4e2757e1887b7dd5b89261ba0c70c3f1c.png" alt="image-20201015155408692" tabindex="0" loading="lazy"><figcaption>image-20201015155408692</figcaption></figure>
<p><strong>广播</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/5bef6b6b192bc4b8ebb2daf6875282d413530de1.png" alt="image-20201015155440402" tabindex="0" loading="lazy"><figcaption>image-20201015155440402</figcaption></figure>
<p><strong>多个单播</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/f6cac6ae01c8f94c4acc204969a905a6f1251b5f.png" alt="image-20201015155526386" tabindex="0" loading="lazy"><figcaption>image-20201015155526386</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/e43f80c5063476b20251ac6bb72d88598baf26de.png" alt="image-20201015155706698" tabindex="0" loading="lazy"><figcaption>image-20201015155706698</figcaption></figure>
<p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p>
<h4> 8.2.3 总结</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/84d1b6c77cb6b196ef80237bdffa5a064b70851d.png" alt="image-20201015160146482" tabindex="0" loading="lazy"><figcaption>image-20201015160146482</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/da33ca1ab444c221bbd3356cac06e4d98a5941bc.png" alt="image-20201015160526999" tabindex="0" loading="lazy"><figcaption>image-20201015160526999</figcaption></figure>
<blockquote>
<p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p>
</blockquote>
<hr>
<h2> 9.以太网交换机自学习和转发帧的流程</h2>
<h3> 9.1 概念</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/65f622051bcc832d61f5dcab327419e4111d8d57.png" alt="image-20201015161015165" tabindex="0" loading="lazy"><figcaption>image-20201015161015165</figcaption></figure>
<h3> 9.2 自学习和转发帧的例子</h3>
<p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p>
<p><strong>A -&gt; B</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/226a8e6d0dd3bc6828492e33200a5c37e1c46a68.png" alt="image-20201015161458528" tabindex="0" loading="lazy"><figcaption>image-20201015161458528</figcaption></figure>
<blockquote>
<ol>
<li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li>
<li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li>
<li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li>
<li>交换机向除接口 1 以外的所有的接口广播这个帧</li>
<li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li>
<li>交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中</li>
<li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li>
<li>主机B发现是给自己的帧，接受该帧</li>
</ol>
</blockquote>
<p><strong>B -&gt; A</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/90d823f4548e94178e74b932c14187095f80e5c0.png" alt="image-20201015162310922" tabindex="0" loading="lazy"><figcaption>image-20201015162310922</figcaption></figure>
<blockquote>
<ol>
<li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li>
<li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li>
<li>主机 A 发现目的地址是它，就接受该帧</li>
<li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li>
</ol>
</blockquote>
<p><strong>E -&gt; A</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/15053219ab8ffdb9c6dc50307b92255e4b3bf64a.png" alt="image-20201015162622462" tabindex="0" loading="lazy"><figcaption>image-20201015162622462</figcaption></figure>
<blockquote>
<ol>
<li>E 向 A发送一帧</li>
<li>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</li>
<li>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</li>
<li>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li>
<li>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</li>
<li>主机 A 发现目的地址是它，就接受该帧</li>
</ol>
</blockquote>
<p><strong>G -&gt; A</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/630afa3bb2626280ec094a2a76aead0519236c46.png" alt="image-20201015163157140" tabindex="0" loading="lazy"><figcaption>image-20201015163157140</figcaption></figure>
<blockquote>
<p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p>
<ol>
<li>主机 G 发送给 主机 A 一个帧</li>
<li>主机 A 和 交换机接口 1都能接收到</li>
<li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li>
<li>交换机 1收到该帧后，首先进行登记工作</li>
<li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li>
<li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 将帧转发出去，因为这是没有必要，于是丢弃该帧</li>
</ol>
</blockquote>
<p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p>
<figure><img src="https://i0.hdslb.com/bfs/album/bdffa944968064b8972e708140abcc5fe2e95c7d.png" alt="image-20201015164210543" tabindex="0" loading="lazy"><figcaption>image-20201015164210543</figcaption></figure>
<blockquote>
<p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p>
<p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p>
</blockquote>
<h3> 9.3 总结</h3>
<p><strong>交换机自学习和转发帧的步骤归纳</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/c2672b54d7180ff080007677817091f5abdb4317.png" alt="image-20201015170656500" tabindex="0" loading="lazy"><figcaption>image-20201015170656500</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/beaaac1babd661fa091e858d954aef4cea0790fe.png" alt="image-20201015170739679" tabindex="0" loading="lazy"><figcaption>image-20201015170739679</figcaption></figure>
<h2> 10.以太网交换机的生成树协议STP</h2>
<h3> 10.1 如何提高以太网的可靠性</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/33f90356a1e462738126f136f03869eedec9a81b.png" alt="image-20201015171453001" tabindex="0" loading="lazy"><figcaption>image-20201015171453001</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/85de6f86aa7d8ce19c70dc084d0b56d853cfc266.png" alt="image-20201015171515481" tabindex="0" loading="lazy"><figcaption>image-20201015171515481</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/b8983f9f95afed66cb598d9c0b0a4d7c2f0d5b00.png" alt="image-20201015171900775" tabindex="0" loading="lazy"><figcaption>image-20201015171900775</figcaption></figure>
<h3> 10.2 生成树协议STP</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/29b66d858a3c8ceca1ff251968f36fa719d85ba0.png" alt="image-20201015172204419" tabindex="0" loading="lazy"><figcaption>image-20201015172204419</figcaption></figure>
<blockquote>
<ul>
<li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong>  (Spanning Tree Protocol)。</li>
<li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/81a4b0b7ef8036d57ab43225b37efe2d4ada2491.png" alt="image-20201015202257756" tabindex="0" loading="lazy"><figcaption>image-20201015202257756</figcaption></figure>
<hr>
<h2> 11.虚拟局域网VLAN</h2>
<h3> 11.1 为什么要虚拟局域网VLAN</h3>
<p><strong>广播风暴</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/8410d2be4964ac20df47ec86e5c5641bf98a68d3.png" alt="image-20201015202859124" tabindex="0" loading="lazy"><figcaption>image-20201015202859124</figcaption></figure>
<p><strong>分割广播域的方法</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/0c6572eb7d7b00ef4519498be2cb532fae820f3b.png" alt="image-20201015203113654" tabindex="0" loading="lazy"><figcaption>image-20201015203113654</figcaption></figure>
<blockquote>
<p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p>
</blockquote>
<h3> 11.2 概念</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/147446245ddafa32e0418146f4998c77fbb96206.png" alt="image-20201015203559548" tabindex="0" loading="lazy"><figcaption>image-20201015203559548</figcaption></figure>
<blockquote>
<ul>
<li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li>
<li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：
<strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li>
<li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</li>
<li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li>
<li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li>
</ul>
</blockquote>
<h3> 11.3 虚拟局域网VLAN的实现机制</h3>
<p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p>
<ul>
<li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li>
<li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/fa610982a3c922594ab71a8e93a5e71d1d0600f0.png" alt="image-20201015204639599" tabindex="0" loading="lazy"><figcaption>image-20201015204639599</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/df8d1d98fe4c02480d0398deaaa25c9fab2733b5.png" alt="image-20201015204749141" tabindex="0" loading="lazy"><figcaption>image-20201015204749141</figcaption></figure>
<p><strong>Access端口</strong></p>
<p>交换机与用户计算机之间的互连</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e835a10cf4f359b6686d932e87f849672916a8b7.png" alt="image-20201015205311757" tabindex="0" loading="lazy"><figcaption>image-20201015205311757</figcaption></figure>
<blockquote>
<p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p>
</blockquote>
<p><strong>Truck端口</strong></p>
<p>交换机之间或交换机与路由器之间的互连</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e128cb3ff8be1b25d5f787762a430570e3b21f8a.png" alt="image-20201015205947636" tabindex="0" loading="lazy"><figcaption>image-20201015205947636</figcaption></figure>
<p><strong>小例题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/140150c1c5d9677cf961e384a5474ed18e26d4db.png" alt="image-20201015210417695" tabindex="0" loading="lazy"><figcaption>image-20201015210417695</figcaption></figure>
<p><strong>华为交换机私有的Hybrid端口类型</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/d4997ef8866a3a19c0be62d5495507d1ebed1a20.png" alt="image-20201015211031361" tabindex="0" loading="lazy"><figcaption>image-20201015211031361</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/d958887620c526ccee197350c9da33384d2b6bf3.png" alt="image-20230128194154936" tabindex="0" loading="lazy"><figcaption>image-20230128194154936</figcaption></figure>
<h3> 11.4 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/ede9a736f345655ad37cfbba5401d58063bdf196.png" alt="image-20201015211512622" tabindex="0" loading="lazy"><figcaption>image-20201015211512622</figcaption></figure>
<blockquote>
<p><strong>虚拟局域网优点</strong></p>
<p>虚拟局域网（VLAN）技术具有以下主要优点：</p>
<ol>
<li>改善了性能</li>
<li>简化了管理</li>
<li>降低了成本</li>
<li>改善了安全性</li>
</ol>
</blockquote>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-02-10T13:52:13.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">04 【计算机网络-网络层】</title>
    <id>https://blog.dselegent.cf/professional_knowledge/computer_network/04.html</id>
    <link href="https://blog.dselegent.cf/professional_knowledge/computer_network/04.html"/>
    <updated>2023-02-10T13:52:13.000Z</updated>
    <summary type="html"><![CDATA[<h1> 04 【计算机网络-网络层】</h1>
<h2> 1.网络层概述</h2>
<h3> 1.1 简介</h3>
<ul>
<li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/cc633422af4e17502e62051745ce202b7c5b730f.png" alt="image-20201017134630948" tabindex="0" loading="lazy"><figcaption>image-20201017134630948</figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<h1> 04 【计算机网络-网络层】</h1>
<h2> 1.网络层概述</h2>
<h3> 1.1 简介</h3>
<ul>
<li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/cc633422af4e17502e62051745ce202b7c5b730f.png" alt="image-20201017134630948" tabindex="0" loading="lazy"><figcaption>image-20201017134630948</figcaption></figure>
<blockquote>
<p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p>
<p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p>
<p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p>
</blockquote>
<ul>
<li>
<p>要实现网络层任务，需要解决一下主要问题：</p>
<ul>
<li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li>
</ul>
<p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p>
<ul>
<li>网络层寻址问题</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/fa09132d5ff67d4d4476c331e6af37a6dc1cf909.png" alt="image-20201017135644630" tabindex="0" loading="lazy"><figcaption>image-20201017135644630</figcaption></figure>
<ul>
<li>路由选择问题</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/e0e732269b737f0fd20a678c7c513497302ccf66.png" alt="image-20201017135710478" tabindex="0" loading="lazy"><figcaption>image-20201017135710478</figcaption></figure>
<blockquote>
<p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p>
<p><strong>依据数据包的目的地址和路由器中的路由表</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/53a5591562c3bf9848853055f058858e1457454e.png" alt="image-20201017135914985" tabindex="0" loading="lazy"><figcaption>image-20201017135914985</figcaption></figure>
<p>但在实际当中，路由器是怎样知道这些路由记录？</p>
<ul>
<li>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</li>
<li><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></li>
</ul>
</blockquote>
</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/29d44452fd7d4798bfd700cddf6bbffc4fe350a6.png" alt="image-20201017142545630" tabindex="0" loading="lazy"><figcaption>image-20201017142545630</figcaption></figure>
<blockquote>
<p>补充 <strong>网络层（网际层）<strong>除了 <strong>IP协议</strong>外，还有之前介绍过的</strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p>
</blockquote>
<h3> 1.2 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/6612b2ca3c5447be5429015d0f1d56ac60147376.png" alt="image-20201017140623851" tabindex="0" loading="lazy"><figcaption>image-20201017140623851</figcaption></figure>
<h2> 2.网络层提供的两种服务</h2>
<ul>
<li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li>
<li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</li>
</ul>
<h3> 2.1 面向连接的虚电路服务</h3>
<p><strong>一种观点：让网络负责可靠交付</strong></p>
<ul>
<li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li>
<li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。</li>
<li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/fbc30a6a4dd64735afb297706a795125d02a2615.png" alt="image-20201017141425892" tabindex="0" loading="lazy"><figcaption>image-20201017141425892</figcaption></figure>
<p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p>
<blockquote>
<ul>
<li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>
<li>请注意，电路交换的电话通信是先建立了一条真正的连接。</li>
<li>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</li>
</ul>
</blockquote>
<h3> 2.2 无连接的数据报服务</h3>
<p><strong>另一种观点：网络提供数据报服务</strong></p>
<ul>
<li>互联网的先驱者提出了一种崭新的网络设计思路。</li>
<li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li>
<li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li>
<li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/1892b8efe44dd96e0605194561bd5085e429cc9c.png" alt="image-20201017141851030" tabindex="0" loading="lazy"><figcaption>image-20201017141851030</figcaption></figure>
<p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p>
<blockquote>
<p><strong>尽最大努力交付</strong></p>
<ul>
<li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</li>
<li><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li>
<li>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li>
</ul>
</blockquote>
<h3> 2.3 虚电路服务与数据报服务的对比</h3>
<table>
<thead>
<tr>
<th><strong>对比的方面</strong></th>
<th><strong>虚电路服务</strong></th>
<th><strong>数据报服务</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>思路</strong></td>
<td><strong>可靠通信应当由网络来保证</strong></td>
<td><strong>可靠通信应当由用户主机来保证</strong></td>
</tr>
<tr>
<td><strong>连接的建立</strong></td>
<td><strong>必须有</strong></td>
<td><strong>不需要</strong></td>
</tr>
<tr>
<td><strong>终点地址</strong></td>
<td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td>
<td><strong>每个分组都有终点的完整地址</strong></td>
</tr>
<tr>
<td><strong>分组的转发</strong></td>
<td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td>
<td><strong>每个分组独立选择路由进行转发</strong></td>
</tr>
<tr>
<td><strong>当结点出故障时</strong></td>
<td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td>
<td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td>
</tr>
<tr>
<td><strong>分组的顺序</strong></td>
<td><strong>总是按发送顺序到达终点</strong></td>
<td><strong>到达终点时不一定按发送顺序</strong></td>
</tr>
<tr>
<td><strong>端到端的差错处理和流量控制</strong></td>
<td><strong>可以由网络负责，也可以由用户主机负责</strong></td>
<td><strong>由用户主机负责</strong></td>
</tr>
</tbody>
</table>
<h2> 3.IPv4</h2>
<h3> 3.1 概述</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/dc73657b3e728a0052071ab22646dd516a1504bd.png" alt="image-20201017143206060" tabindex="0" loading="lazy"><figcaption>image-20201017143206060</figcaption></figure>
<h3> 3.2 分类编制的IPv4地址</h3>
<h4> 3.2.1 简介</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/d1b24c9f2f75c9a95f55ac7beb0ff9681fe10aa4.png" alt="image-20201017144317166" tabindex="0" loading="lazy"><figcaption>image-20201017144317166</figcaption></figure>
<ul>
<li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li>
<li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li>
<li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li>
</ul>
<p><strong>A类地址</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/f124b871a293c854649b9b3e864e7df5d5f5e058.png" alt="image-20201017145210533" tabindex="0" loading="lazy"><figcaption>image-20201017145210533</figcaption></figure>
<p><strong>B类地址</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/67d391cb0b582eb92d3bf27742f6abf01df0a39e.png" alt="image-20201017145508001" tabindex="0" loading="lazy"><figcaption>image-20201017145508001</figcaption></figure>
<p><strong>C类地址</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/352d6fe90e1aba299c0ae4591483eda12cc44e02.png" alt="image-20201017150204774" tabindex="0" loading="lazy"><figcaption>image-20201017150204774</figcaption></figure>
<p><strong>练习</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/37543b8db85b93eb16f48cfb3aa7a5dd40c4771a.png" alt="image-20201017150543386" tabindex="0" loading="lazy"><figcaption>image-20201017150543386</figcaption></figure>
<h4> 3.2.2 总结</h4>
<p><strong>IP 地址的指派范围</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/4f11b79cbf4080829589ec3132a6c4f771c95e3e.png" alt="image-20201017152911541" tabindex="0" loading="lazy"><figcaption>image-20201017152911541</figcaption></figure>
<p><strong>一般不使用的特殊的 IP 地址</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/e3759a13f6adfcc84265bc95c8fa6b8eaa2f62b7.png" alt="image-20201017152959586" tabindex="0" loading="lazy"><figcaption>image-20201017152959586</figcaption></figure>
<p><strong>IP 地址的一些重要特点</strong></p>
<p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p>
<ul>
<li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li>
<li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li>
</ul>
<p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p>
<ul>
<li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li>
<li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li>
</ul>
<p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p>
<p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p>
<h3> 3.3 划分子网的IPv4地址</h3>
<h4> 3.3.1 为什么要划分子网</h4>
<p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p>
<ul>
<li>IP 地址空间的利用率有时很低。</li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li>
<li>两级的 IP 地址不够灵活。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/d926dbeff0446f5b7746b1c78df2c3dfc3c1ec93.png" alt="image-20201017154645198" tabindex="0" loading="lazy"><figcaption>image-20201017154645198</figcaption></figure>
<p>如果想要将原来的网络划分成三个独立的网路</p>
<figure><img src="https://i0.hdslb.com/bfs/album/78b53145ed5c3fb0214e61fe95749babe4262909.png" alt="image-20201017154852896" tabindex="0" loading="lazy"><figcaption>image-20201017154852896</figcaption></figure>
<p>所以是否可以从主机号部分借用一部分作为子网号</p>
<figure><img src="https://i0.hdslb.com/bfs/album/3ce333627e8ff935ca0a5fe1377cb2ab55d42eff.png" alt="image-20201017155026814" tabindex="0" loading="lazy"><figcaption>image-20201017155026814</figcaption></figure>
<blockquote>
<p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p>
<p>所以就有了划分子网的工具：<strong>子网掩码</strong></p>
<ul>
<li>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</li>
<li>这种做法叫做<strong>划分子网</strong> (subnetting) 。</li>
<li>划分子网已成为互联网的正式标准协议。</li>
</ul>
</blockquote>
<h4> 3.3.2 如何划分子网</h4>
<p>基本思路</p>
<ul>
<li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li>
<li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/f08b96ab1bee9cea8cd99c063794cc8447cc1d7b.png" alt="image-20201017155930011" tabindex="0" loading="lazy"><figcaption>image-20201017155930011</figcaption></figure>
<ul>
<li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li>
<li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li>
<li>最后就将 IP 数据报直接交付目的主机。</li>
</ul>
<p>划分为三个子网后对外仍是一个网络</p>
<figure><img src="https://i0.hdslb.com/bfs/album/5a006fb5f19a7524f30fab234c95a7c175e69845.png" alt="image-20201017160116239" tabindex="0" loading="lazy"><figcaption>image-20201017160116239</figcaption></figure>
<blockquote>
<ul>
<li><strong>优点</strong>
<ol>
<li>减少了 IP 地址的浪费</li>
<li>使网络的组织更加灵活</li>
<li>更便于维护和管理</li>
</ol>
</li>
<li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li>
</ul>
</blockquote>
<h4> 3.3.3 子网掩码</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/1463fe28d3fcf3ee3257db3158079502eae0a776.png" alt="image-20201017160252066" tabindex="0" loading="lazy"><figcaption>image-20201017160252066</figcaption></figure>
<blockquote>
<p><strong>(IP 地址) AND (子网掩码) = 网络地址</strong> 重要，下面很多相关知识都会用到</p>
</blockquote>
<p>举例</p>
<p>例子1</p>
<figure><img src="https://i0.hdslb.com/bfs/album/5d0fbf63f3106e8a7737da475024b5835edb814f.png" alt="image-20201017161651058" tabindex="0" loading="lazy"><figcaption>image-20201017161651058</figcaption></figure>
<p>例子2</p>
<figure><img src="https://i0.hdslb.com/bfs/album/1c87644735c37dcd867159506ff1a567d21f7aef.png" alt="image-20201017161719339" tabindex="0" loading="lazy"><figcaption>image-20201017161719339</figcaption></figure>
<p><strong>默认子网掩码</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/be4efbb0a8954bfbe92cd4c8f16777aa56c44e19.png" alt="image-20201017162807076" tabindex="0" loading="lazy"><figcaption>image-20201017162807076</figcaption></figure>
<h4> 3.3.4 总结</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/5d6ff3bcda05d0cf22a1891c8db2b59d99a67230.png" alt="image-20201017162938612" tabindex="0" loading="lazy"><figcaption>image-20201017162938612</figcaption></figure>
<blockquote>
<ul>
<li>子网掩码是一个网络或一个子网的重要属性。</li>
<li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li>
<li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li>
<li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li>
</ul>
</blockquote>
<h3> 3.4 无分类编址的IPv4地址</h3>
<h4> 3.4.1 为什么使用无分类编址</h4>
<p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/a18d839c4f5b290e82186de0daadfc7da8cbabd8.png" alt="image-20201017164031532" tabindex="0" loading="lazy"><figcaption>image-20201017164031532</figcaption></figure>
<blockquote>
<p><strong>CIDR 最主要的特点</strong></p>
<ul>
<li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li>
<li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li>
</ul>
</blockquote>
<h4> 3.4.2 如何使用无分类编址</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/bd6914b4ab15400f980dedbdd55b613e1ab97618.png" alt="image-20201017165037268" tabindex="0" loading="lazy"><figcaption>image-20201017165037268</figcaption></figure>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/album/db67c81dabbf9c1e782ec182529e3b655511e07f.png" alt="image-20201017165113442" tabindex="0" loading="lazy"><figcaption>image-20201017165113442</figcaption></figure>
<h4> 3.4.3 路由聚合（构造超网）</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/90d3e83ab74f4af584279ff5f8fc955fe953dfd4.png" alt="image-20201017165615915" tabindex="0" loading="lazy"><figcaption>image-20201017165615915</figcaption></figure>
<h4> 3.4.4 总结</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/c6fd076933a25dca1e0875cff6d2647fda7bf48f.png" alt="image-20201017170552495" tabindex="0" loading="lazy"><figcaption>image-20201017170552495</figcaption></figure>
<h3> 3.5 IPv4地址的应用规划</h3>
<p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p>
<h4> 3.5.1 定长的子网掩码FLSM（Fixed Length Subnet Mask）</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/0d01f66e6e64d33cc595febe36e74fcb29941814.png" alt="image-20201018143550103" tabindex="0" loading="lazy"><figcaption>image-20201018143550103</figcaption></figure>
<p><strong>划分子网的IPv4就是定长的子网掩码</strong></p>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/album/8dffbe40b025aad31e241065f952dca35bb3c5a7.png" alt="image-20201018140809079" tabindex="0" loading="lazy"><figcaption>image-20201018140809079</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/39e372763e5195269358a09797eeeb8bc68faca5.png" alt="image-20201018140916631" tabindex="0" loading="lazy"><figcaption>image-20201018140916631</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/955b57889438b5a7c96f113501f69c286fd6c646.png" alt="image-20201018141132446" tabindex="0" loading="lazy"><figcaption>image-20201018141132446</figcaption></figure>
<blockquote>
<p>通过上面步骤分析，就可以从子网1<sub>8中任选5个分配给左图中的N1</sub>N5</p>
<p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p>
<p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p>
</blockquote>
<h4> 3.5.2 变长的子网掩码VLSM（Variable Length Subnet Mask）</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/9129a256a9332c19387ede08a453639f27205e68.png" alt="image-20201018143632352" tabindex="0" loading="lazy"><figcaption>image-20201018143632352</figcaption></figure>
<p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/album/68cebdd88c50457adbd61a3012f49d83a170d346.png" alt="image-20201018142333145" tabindex="0" loading="lazy"><figcaption>image-20201018142333145</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/97c7f72a1a07a127c337a14fc58a6e9884080d13.png" alt="image-20201018143344440" tabindex="0" loading="lazy"><figcaption>image-20201018143344440</figcaption></figure>
<hr>
<h2> 4.IP数据报的发送和转发过程</h2>
<figure><img src="https://i0.hdslb.com/bfs/album/a1ee517b25d92e8df099e03a36e7b4215cbbaa85.png" alt="image-20201018144335297" tabindex="0" loading="lazy"><figcaption>image-20201018144335297</figcaption></figure>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/album/5716d8594f8500e2f70e8769e4f9e176ccb98c71.png" alt="image-20201018151314019" tabindex="0" loading="lazy"><figcaption>image-20201018151314019</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/ddde299fe00ce6d457c02360b11fb4917d2b32fd.png" alt="image-20201018150151171" tabindex="0" loading="lazy"><figcaption>image-20201018150151171</figcaption></figure>
<p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p>
<figure><img src="https://i0.hdslb.com/bfs/album/4261899f93ac5f3ba0394101b7720de6511ba9cd.png" alt="image-20201018150223497" tabindex="0" loading="lazy"><figcaption>image-20201018150223497</figcaption></figure>
<blockquote>
<p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p>
<ul>
<li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li>
<li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</li>
</ul>
</blockquote>
<p>主机C如何知道路由器R的存在？</p>
<figure><img src="https://i0.hdslb.com/bfs/album/b6e79586b15827f4d7003ecd074fccb727cbb33a.png" alt="image-20201018145501063" tabindex="0" loading="lazy"><figcaption>image-20201018145501063</figcaption></figure>
<blockquote>
<p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，<strong>所指定的路由器</strong>，也被称为<strong>默认网关</strong></p>
<p>例如。路由器的接口0的IP地址192.168.0.128做为左边网络的默认网关</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/5adacb10bc135493bc40c3d2bac2a9494d6b8d78.png" alt="image-20201018150029179" tabindex="0" loading="lazy"><figcaption>image-20201018150029179</figcaption></figure>
<blockquote>
<p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p>
</blockquote>
<p>路由器收到IP数据报后如何转发？</p>
<ul>
<li>检查IP数据报首部是否出错：
<ul>
<li>若出错，则直接丢弃该IP数据报并通告源主机</li>
<li>若没有出错，则进行转发</li>
</ul>
</li>
<li>根据IP数据报的目的地址在路由表中查找匹配的条目：
<ul>
<li>若找到匹配的条目，则转发给条目中指示的吓一跳</li>
<li>若找不到，则丢弃该数据报并通告源主机</li>
</ul>
</li>
</ul>
<p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e899f29d39479336d8e81fb2ae564dab168a578c.png" alt="image-20201018151108989" tabindex="0" loading="lazy"><figcaption>image-20201018151108989</figcaption></figure>
<p>接下来路由器对该IP数据报进行查表转发</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d963a467476b9c8c31f7c93b5f03267d37897b90.png" alt="image-20201018151528027" tabindex="0" loading="lazy"><figcaption>image-20201018151528027</figcaption></figure>
<blockquote>
<p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/0b71e404e482bc13f9bab27d65a53b6f5e5a1924.png" alt="image-20201018151956275" tabindex="0" loading="lazy"><figcaption>image-20201018151956275</figcaption></figure>
<p>路由器是隔离广播域的</p>
<figure><img src="https://i0.hdslb.com/bfs/album/942596482ca2de62911de9d1f57c49bc3ad1875e.png" alt="image-20201018152040610" tabindex="0" loading="lazy"><figcaption>image-20201018152040610</figcaption></figure>
<h2> 5.静态路由配置及其可能产生的路由环路问题</h2>
<h3> 5.1 概念</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/99dd8d969f1bac3f2d6a155bde5831cc4beb26b6.png" alt="image-20201018155702081" tabindex="0" loading="lazy"><figcaption>image-20201018155702081</figcaption></figure>
<h3> 5.2 多种情况举例</h3>
<p><strong>静态路由配置</strong></p>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/album/02592f0d3abc3a19b92139ce54241549bc07dbcf.png" alt="image-20201018160349375" tabindex="0" loading="lazy"><figcaption>image-20201018160349375</figcaption></figure>
<p><strong>默认路由</strong></p>
<p>举例</p>
<p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p>
<figure><img src="https://i0.hdslb.com/bfs/album/52d6e5add08b0c57f25273acfd389dd981c771d3.png" alt="image-20201018160906284" tabindex="0" loading="lazy"><figcaption>image-20201018160906284</figcaption></figure>
<p><strong>特定主机路由</strong></p>
<p>举例</p>
<p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p>
<p>一般用于网络管理人员对网络的管理和测试</p>
<figure><img src="https://i0.hdslb.com/bfs/album/5867f9ff77dcbc0dd4db57ff0b1979e22e942e01.png" alt="image-20201018161440257" tabindex="0" loading="lazy"><figcaption>image-20201018161440257</figcaption></figure>
<blockquote>
<p>多条路由可选，匹配路由最具体的</p>
</blockquote>
<p><strong>静态路由配置错误导致路由环路</strong></p>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/album/0ca1c549854b4fcda9d4b30186842352528db00e.png" alt="image-20201018161542579" tabindex="0" loading="lazy"><figcaption>image-20201018161542579</figcaption></figure>
<p>假设将R2的路由表中第三条目录配置错了下一跳</p>
<p>这导致R2和R3之间产生了路由环路</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d6847d6e4510f72ca600f0f743c1ebf5acaf9abc.png" alt="image-20201018162041966" tabindex="0" loading="lazy"><figcaption>image-20201018162041966</figcaption></figure>
<p><strong>聚合了不存在的网络而导致路由环路</strong></p>
<p>举例</p>
<p>正常情况</p>
<figure><img src="https://i0.hdslb.com/bfs/album/17b6a0c1d26cfa0002dc1b98a665c9d4324576fc.png" alt="image-20201018162333671" tabindex="0" loading="lazy"><figcaption>image-20201018162333671</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/e031f04e8d67d1bea203c4b305c0ea1de8df1fe5.png" alt="image-20201018162759562" tabindex="0" loading="lazy"><figcaption>image-20201018162759562</figcaption></figure>
<p>错误情况</p>
<figure><img src="https://i0.hdslb.com/bfs/album/2f28f4b0573f1fdfef89f27ec4dec0946d96e5fa.png" alt="image-20201018163323343" tabindex="0" loading="lazy"><figcaption>image-20201018163323343</figcaption></figure>
<p>解决方法</p>
<figure><img src="https://i0.hdslb.com/bfs/album/ba9824fd32c0e2eb609326045e4c5c7d9a8ae731.png" alt="image-20201018163933715" tabindex="0" loading="lazy"><figcaption>image-20201018163933715</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/f1a6939386bfb693811272f242685222e7ac7895.png" alt="image-20201018164453398" tabindex="0" loading="lazy"><figcaption>image-20201018164453398</figcaption></figure>
<blockquote>
<p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p>
</blockquote>
<p><strong>网络故障而导致路由环路</strong></p>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/album/456dd9efbd81926b62403aa02babc33a39718994.png" alt="image-20201018164811811" tabindex="0" loading="lazy"><figcaption>image-20201018164811811</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/9b1676e708f2ac1095dc365ccafccceae3a05d04.png" alt="image-20201018164913684" tabindex="0" loading="lazy"><figcaption>image-20201018164913684</figcaption></figure>
<p>解决方法</p>
<p>添加故障的网络为黑洞路由</p>
<figure><img src="https://i0.hdslb.com/bfs/album/2298d41ecd81e5da91b6c789b1beab92673a2678.png" alt="image-20201018165122023" tabindex="0" loading="lazy"><figcaption>image-20201018165122023</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/7a059bd9cdb6148306aa6fa4e66a16eb9776933c.png" alt="image-20201018165153517" tabindex="0" loading="lazy"><figcaption>image-20201018165153517</figcaption></figure>
<p>假设。一段时间后故障网络恢复了</p>
<p>R1又自动地得出了其接口0的直连网络的路由条目</p>
<p>针对该网络的黑洞网络会自动失效</p>
<figure><img src="https://i0.hdslb.com/bfs/album/0660f955e5b4857693ad4d8d7413e15244f5d793.png" alt="image-20201018165328319" tabindex="0" loading="lazy"><figcaption>image-20201018165328319</figcaption></figure>
<p>如果又故障</p>
<p>则生效该网络的黑洞网络</p>
<figure><img src="https://i0.hdslb.com/bfs/album/21f46ff70706f42acaa147039380cdee88d41c69.png" alt="image-20201018165521938" tabindex="0" loading="lazy"><figcaption>image-20201018165521938</figcaption></figure>
<h3> 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/07bf182d16898f157e15b64f56b61efac44c028b.png" alt="image-20201018165709294" tabindex="0" loading="lazy"><figcaption>image-20201018165709294</figcaption></figure>
<h2> 6.路由选择协议</h2>
<h3> 6.1 概述</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/6bf16ddd5f9fbb6eeeadf534fe26e67c2b4802b2.png" alt="image-20201019134827343" tabindex="0" loading="lazy"><figcaption>image-20201019134827343</figcaption></figure>
<p><strong>因特网所采用的路由选择协议的主要特点</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/81849934b63349e677fb497c35310774fcfb7490.png" alt="image-20201019134946971" tabindex="0" loading="lazy"><figcaption>image-20201019134946971</figcaption></figure>
<p><strong>因特网采用分层次的路由选择协议</strong></p>
<ul>
<li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/ab348c951a84b909f181c1e29455431924ab7ef7.png" alt="image-20201019135122326" tabindex="0" loading="lazy"><figcaption>image-20201019135122326</figcaption></figure>
<blockquote>
<p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/122e2cd7ffe34bbd5fc26b7678166aa7a039f3be.png" alt="image-20201019135328925" tabindex="0" loading="lazy"><figcaption>image-20201019135328925</figcaption></figure>
<blockquote>
<p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p>
<p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p>
<p><strong>网关协议</strong>的名称可称为<strong>路由协议</strong></p>
</blockquote>
<p><strong>常见的路由选择协议</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/34b5132331d322a8c701af9490515096fbeb99e7.png" alt="image-20201019140009740" tabindex="0" loading="lazy"><figcaption>image-20201019140009740</figcaption></figure>
<p><strong>路由器的基本结构</strong></p>
<p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p>
<figure><img src="https://i0.hdslb.com/bfs/album/7b65d6211457d51ca56d2fec4e12f9a4aae1b021.png" alt="image-20201019140234652" tabindex="0" loading="lazy"><figcaption>image-20201019140234652</figcaption></figure>
<p>路由器结构可划分为两大部分：</p>
<p>1、<strong>分组转发部分</strong></p>
<p>由三部分构成</p>
<ul>
<li>
<p>交换结构</p>
</li>
<li>
<p>一组输入端口：</p>
<p>信号从某个输入端口进入路由器</p>
<img src="https://i0.hdslb.com/bfs/album/6353518d9aa432c221f2fc2818c6060bb7c0135f.png" alt="image-20201019141149194" style="zoom:50%;">
<p>物理层将信号转换成比特流，送交数据链路层处理</p>
<img src="https://i0.hdslb.com/bfs/album/076fe966048adb5bd73efc1ed716628db69f2b71.png" alt="image-20201019141210774" style="zoom: 50%;">
<p>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p>
<img src="https://i0.hdslb.com/bfs/album/c67e8b4862b346f9e3e2aa7e0a1604faa26e2014.png" alt="image-20201019141242246" style="zoom:50%;">
<p>如果送交网络层的分组是普通待转发的数据分组</p>
<img src="https://i0.hdslb.com/bfs/album/3cde6af16d002ab24a63add303d1691f3605374d.png" alt="image-20201019141305650" style="zoom:50%;">
<p>则根据分组首部中的目的地址进行查表转发</p>
<img src="https://i0.hdslb.com/bfs/album/af53296ffec7f4aa26bf0184c27702a9ee29946c.png" alt="image-20201019141327380" style="zoom:50%;">
<p>若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p>
</li>
<li>
<p>一组输出端口</p>
<p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p>
<img src="https://i0.hdslb.com/bfs/album/c1ac3537fc5caed80a21ff8c2c80c2b3b05060ba.png" alt="image-20201019141745375" style="zoom:50%;">
<p>数据链路层将数据分组封装成帧，交给物理层处理</p>
<img src="https://i0.hdslb.com/bfs/album/0694fed109c790a483f6d850861730c4166be53c.png" alt="image-20201019141838032" style="zoom:50%;">
<p>物理层将帧看成比特流将其变换成相应的电信号进行发送</p>
</li>
</ul>
<blockquote>
<p>路由器的各端口还会有输入缓冲区和输出缓冲区</p>
<ul>
<li>
<p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p>
</li>
<li>
<p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p>
</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/58ca97f12164cb65fee315ae4ac80c59abd8d82b.png" alt="image-20201019143040253" tabindex="0" loading="lazy"><figcaption>image-20201019143040253</figcaption></figure>
<p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p>
</blockquote>
<p>2、<strong>路由选择部分</strong></p>
<ul>
<li>
<p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p>
<p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p>
<img src="https://i0.hdslb.com/bfs/album/20562e3556ed32d73a225271a52f1bbe54fed9fe.png" alt="image-20201019142228360" style="zoom:50%;">
<p>路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/d56d0ae358a579e6b2775b20a9dee00899bbab94.png" alt="image-20201019142415055" tabindex="0" loading="lazy"><figcaption>image-20201019142415055</figcaption></figure>
<p>路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p>
<figure><img src="https://i0.hdslb.com/bfs/album/2444d95c8e8c844cf72a42be2f399f6d2f7266fe.png" alt="image-20201019142924889" tabindex="0" loading="lazy"><figcaption>image-20201019142924889</figcaption></figure>
</li>
</ul>
<h3> 6.2 路由信息协议RIP</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/7b2979629f75cbfa9e7eaa97f92ccca610ed299d.png" alt="image-20201019144915687" tabindex="0" loading="lazy"><figcaption>image-20201019144915687</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/3e0f0a779723e0aee4e33cfc703e36cc6be58e49.png" alt="image-20201019145247606" tabindex="0" loading="lazy"><figcaption>image-20201019145247606</figcaption></figure>
<p><strong>RIP的基本工作过程</strong></p>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/album/c67aecd2227b008ab79d03a748a3d8e99099f569.png" alt="image-20201019145510947" tabindex="0" loading="lazy"><figcaption>image-20201019145510947</figcaption></figure>
<p><strong>RIP的路由条目的更新规则</strong></p>
<p>举例1</p>
<figure><img src="https://i0.hdslb.com/bfs/album/9c300a63aad934fdd9cf3c04e4b28e2749054381.png" alt="image-20201019145627339" tabindex="0" loading="lazy"><figcaption>image-20201019145627339</figcaption></figure>
<blockquote>
<p>路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p>
<p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/a1c577f5462584e45b9ff6819f24b2630d392c74.png" alt="image-20201019150120900" tabindex="0" loading="lazy"><figcaption>image-20201019150120900</figcaption></figure>
<blockquote>
<p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/7776a2742b9ef2183cb5a58ca02639cfed3b5529.png" alt="image-20201019150412666" tabindex="0" loading="lazy"><figcaption>image-20201019150412666</figcaption></figure>
<p>举例2</p>
<figure><img src="https://i0.hdslb.com/bfs/album/3ddcfeac732ae33bc49da61a32a670906cfd9427.png" alt="image-20201019150525711" tabindex="0" loading="lazy"><figcaption>image-20201019150525711</figcaption></figure>
<p><strong>RIP存在“坏消息传播得慢”的问题</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/82aaec2776ca3d33b573ee8d4ba4c2ab1c1e1f3a.png" alt="image-20201019151041492" tabindex="0" loading="lazy"><figcaption>image-20201019151041492</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/d50b96c9eb5419a86897b4efb878a93dc1ed7327.png" alt="image-20201019151135255" tabindex="0" loading="lazy"><figcaption>image-20201019151135255</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/239db3d225c3a28639262d1b8b35d93b781abea4.png" alt="image-20201019151332767" tabindex="0" loading="lazy"><figcaption>image-20201019151332767</figcaption></figure>
<p>解决方法</p>
<figure><img src="https://i0.hdslb.com/bfs/album/bf38aabf1a11a60623e53cabc4a4b3c4151b32d5.png" alt="image-20201019151639181" tabindex="0" loading="lazy"><figcaption>image-20201019151639181</figcaption></figure>
<blockquote>
<p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p>
</blockquote>
<p><strong>总结</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/809ef421b1ac2062cc20059d6d0e34afe844f5e6.png" alt="image-20201019152526098" tabindex="0" loading="lazy"><figcaption>image-20201019152526098</figcaption></figure>
<blockquote>
<p>RIP 协议的优缺点</p>
<p>优点：</p>
<ol>
<li>实现简单，开销较小。</li>
</ol>
<p>缺点：</p>
<ol>
<li>
<p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p>
</li>
<li>
<p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p>
</li>
<li>
<p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p>
</li>
</ol>
</blockquote>
<h3> 开放最短路径优先OSPF</h3>
<p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p>
<p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p>
<p><strong>概念</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/a259d31e6d4cea37562180f6223487453fa180c3.png" alt="image-20201019161841695" tabindex="0" loading="lazy"><figcaption>image-20201019161841695</figcaption></figure>
<p><strong>问候（Hello）分组</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/38d92453a585ba4b7e4e885859ecee969a8f453c.png" alt="image-20201019161653875" tabindex="0" loading="lazy"><figcaption>image-20201019161653875</figcaption></figure>
<blockquote>
<p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p>
</blockquote>
<p><strong>发送链路状态通告LSA</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/769bce96da9a9fe1730d7c0529360baa7d54f035.png" alt="image-20201019162341151" tabindex="0" loading="lazy"><figcaption>image-20201019162341151</figcaption></figure>
<blockquote>
<p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p>
</blockquote>
<p><strong>链路状态数据库同步</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/1f5264130009f4e42851d59ce0db63446dc08517.png" alt="image-20201019162933483" tabindex="0" loading="lazy"><figcaption>image-20201019162933483</figcaption></figure>
<p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/347fef9c326a8a5d9b1958db86e2d2c4ab497ef3.png" alt="image-20201019163148068" tabindex="0" loading="lazy"><figcaption>image-20201019163148068</figcaption></figure>
<p><strong>OSPF五种分组类型</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/d8fbf7b6bb3f60d752d8bbf3f9ef4d935a7d9ffe.png" alt="image-20201019163250129" tabindex="0" loading="lazy"><figcaption>image-20201019163250129</figcaption></figure>
<p><strong>OSPF的基本工作过程</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/91012dee07a38eade22608ff03bc08582b347e73.png" alt="image-20201019163746254" tabindex="0" loading="lazy"><figcaption>image-20201019163746254</figcaption></figure>
<p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p>
<p>如果不采用其他机制，将会产生大量的多播分组</p>
<figure><img src="https://i0.hdslb.com/bfs/album/67f98b2572d50c1b421cd47a2c7e7d578a4cc8ea.png" alt="image-20201019164657606" tabindex="0" loading="lazy"><figcaption>image-20201019164657606</figcaption></figure>
<blockquote>
<p>若DR出现问题，则由BDR顶替DR</p>
</blockquote>
<p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p>
<ul>
<li>
<p>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</p>
</li>
<li>
<p>每个区域都有一个32比特的区域标识符</p>
</li>
<li>
<p>主干区域的区域标识符必须为0，主干区域用于连通其他区域</p>
</li>
<li>
<p>其他区域的区域标识符不能为0且不相同</p>
</li>
<li>
<p>每个区域一般不应包含路由器超过200个</p>
</li>
<li>
<p>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</p>
</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/c85b8dcb213ec7508277149e9fbb4eebc31caba5.png" alt="image-20201019170100568" tabindex="0" loading="lazy"><figcaption>image-20201019170100568</figcaption></figure>
<p><strong>总结</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/00845a4cf454ca3efe8e72372a304eb08cb26158.png" alt="image-20201019170217622" tabindex="0" loading="lazy"><figcaption>image-20201019170217622</figcaption></figure>
<h3> 6.3 边界网关协议BGP</h3>
<p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p>
<figure><img src="https://i0.hdslb.com/bfs/album/ff4eaaff2fdb0fd4e6f911680275f0afa1e4bfa2.png" alt="image-20201019191438399" tabindex="0" loading="lazy"><figcaption>image-20201019191438399</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/942505f166ee9ec79896acb014aeb0345ae86cde.png" alt="image-20201019191718506" tabindex="0" loading="lazy"><figcaption>image-20201019191718506</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/b2e680156fa938dc96abc1c306b9c45176336cfe.png" alt="image-20201019191836397" tabindex="0" loading="lazy"><figcaption>image-20201019191836397</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/b44a239e43baa0800c5e355ac0d13ada2764d8c5.png" alt="image-20201019192031087" tabindex="0" loading="lazy"><figcaption>image-20201019192031087</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/67d48dccae40288df9cfe7eac7940ddb4cb8a710.png" alt="image-20201019192059962" tabindex="0" loading="lazy"><figcaption>image-20201019192059962</figcaption></figure>
<p><strong>总结</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/f59601463ae2be2182f498efecfa48bd8680742f.png" alt="image-20201019192840368" tabindex="0" loading="lazy"><figcaption>image-20201019192840368</figcaption></figure>
<h3> 6.4 直接封装RIP、OSPF和BGP报文的协议</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/cd9f5d70cd17df7794bd32c5d2d4d4c4a88c2838.png" alt="image-20201019192800829" tabindex="0" loading="lazy"><figcaption>image-20201019192800829</figcaption></figure>
<h2> 7.IPv4数据报的首部格式</h2>
<h3> 7.1 各字段的作用</h3>
<ul>
<li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li>
<li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li>
<li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/6c049782ec3111fc0d4d0fde383ad6797327d651.png" alt="image-20201019205931748" tabindex="0" loading="lazy"><figcaption>image-20201019205931748</figcaption></figure>
<p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p>
<figure><img src="https://i0.hdslb.com/bfs/album/35df6da5e621b23d605ff5099e4ded58caf78951.png" alt="image-20201019211719880" tabindex="0" loading="lazy"><figcaption>image-20201019211719880</figcaption></figure>
<blockquote>
<p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p>
<p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/e8284920fd3c62d1da7c153952c961009668262c.png" alt="image-20201019212617006" tabindex="0" loading="lazy"><figcaption>image-20201019212617006</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/6ffea16852654edaae61c46fece08fbad8924035.png" alt="image-20201019220435415" tabindex="0" loading="lazy"><figcaption>image-20201019220435415</figcaption></figure>
<p><strong>对IPv4数据报进行分片</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/4a061982a80fd33764e4e73fb03031f8c42c9fab.png" alt="image-20201019221021157" tabindex="0" loading="lazy"><figcaption>image-20201019221021157</figcaption></figure>

<figure><img src="https://i0.hdslb.com/bfs/album/7bab3a6d3496cce85c6c331ce5ec1e8e3231fdfb.png" alt="image-20201019221246870" tabindex="0" loading="lazy"><figcaption>image-20201019221246870</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/264863d9782e1c0e03b3462826e60527522e7adb.png" alt="image-20201019222512112" tabindex="0" loading="lazy"><figcaption>image-20201019222512112</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/3ce604ae5d6b74d3a3cc1df924c657c5b4d3f62c.png" alt="image-20201019222552444" tabindex="0" loading="lazy"><figcaption>image-20201019222552444</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/fc7dfa8341daf59e77510ac1a5d21cc88333c240.png" alt="image-20201019222729797" tabindex="0" loading="lazy"><figcaption>image-20201019222729797</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/fe0bde5154b90506bb05380a8b50027795c97d4e.png" alt="image-20201019223101434" tabindex="0" loading="lazy"><figcaption>image-20201019223101434</figcaption></figure>
<h3> 7.2 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/322fa8ab242428faeb5adc8b96406932a33915e4.png" alt="image-20201019225141559" tabindex="0" loading="lazy"><figcaption>image-20201019225141559</figcaption></figure>
<hr>
<h2> 8.网际控制报文协议ICMP</h2>
<h3> 8.1 概念</h3>
<p>架构IP网络时需要特别注意两点：</p>
<ul>
<li>确认网络是否正常工作</li>
<li>遇到异常时进行问题诊断</li>
</ul>
<p><strong>而ICMP就是实现这些问题的协议</strong></p>
<p>ICMP的主要功能包括：</p>
<ul>
<li>确认IP包是否成功送达目标地址</li>
<li>通知在发送过程当中IP包被废弃的具体原因</li>
<li>改善网络设置等</li>
</ul>
<p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/048a10b856898045a20aa6df23500cb63cfa53d4.png" alt="image-20201019232539898" tabindex="0" loading="lazy"><figcaption>image-20201019232539898</figcaption></figure>
<p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p>
<p>ICMP 报文的格式</p>
<figure><img src="https://i0.hdslb.com/bfs/album/145b046d220732be782c621f608922dc9fb25222.png" alt="image-20201020001035813" tabindex="0" loading="lazy"><figcaption>image-20201020001035813</figcaption></figure>
<h3> 8.2 ICMP差错报告报文</h3>
<h4> 8.2.1 终点不可达</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/b03b8c1e3a74e3960ba595a3fab25685d9cbac7d.png" alt="image-20201019230838587" tabindex="0" loading="lazy"><figcaption>image-20201019230838587</figcaption></figure>
<h4> 8.2.2 源点抑制</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/4a07b5b48c3ee97aef31f1a6594df8c1f85bd4ac.png" alt="image-20201019231022291" tabindex="0" loading="lazy"><figcaption>image-20201019231022291</figcaption></figure>
<h4> 8.2.3 时间超过</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/34d1ab3406d66611922c0b141f694153e83d16dc.png" alt="image-20201019231230798" tabindex="0" loading="lazy"><figcaption>image-20201019231230798</figcaption></figure>
<h4> 8.2.4 参数问题</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/d80cc1e50e3972d526875f21c35a283ce622d3a5.png" alt="image-20201019231355471" tabindex="0" loading="lazy"><figcaption>image-20201019231355471</figcaption></figure>
<h4> 8.2.5 改变路由（重定向）</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/2e1fc2b673efae91b636e9a00c2954cb6c7dc272.png" alt="image-20201019231553990" tabindex="0" loading="lazy"><figcaption>image-20201019231553990</figcaption></figure>
<h4> 8.2.6 不应发送ICMP差错报告报文情况</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/c980402282342ac034f3e993d00b17287c3ea892.png" alt="image-20201019231733673" tabindex="0" loading="lazy"><figcaption>image-20201019231733673</figcaption></figure>
<h3> 8.3 ICMP应用举例</h3>
<h4> 8.3.1 分组网间探测PING（Packet InterNet Groper）</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/8ac3da014736d2b48bfe4b6ebce2292ce3101b7b.png" alt="image-20201019233817921" tabindex="0" loading="lazy"><figcaption>image-20201019233817921</figcaption></figure>
<h4> 8.3.2 跟踪路由（traceroute）</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/ff32712df37959a078ed0876e163e5db3c9f401c.png" alt="image-20201019234123026" tabindex="0" loading="lazy"><figcaption>image-20201019234123026</figcaption></figure>
<p><strong>tracert命令的实现原理</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/4aa253827237d9f28a4beab03ef93fbb93877c38.png" alt="image-20201019234718107" tabindex="0" loading="lazy"><figcaption>image-20201019234718107</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/6c63fda64be19a212b84bd0b93640af79933e5d3.png" alt="image-20201019234741268" tabindex="0" loading="lazy"><figcaption>image-20201019234741268</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/0884156b426a321be60eab6b0c7ed7fbd891dc79.png" alt="image-20201019234758693" tabindex="0" loading="lazy"><figcaption>image-20201019234758693</figcaption></figure>
<h3> 8.4 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/13b52ee41df2d60b5e51f1531895221cd78c035d.png" alt="image-20201019234909146" tabindex="0" loading="lazy"><figcaption>image-20201019234909146</figcaption></figure>
<h2> 9.虚拟专用网VPN与网络地址转换NAT</h2>
<h3> 9.1 虚拟专用网VPN（Virtual Private Network）</h3>
<ul>
<li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li>
<li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li>
<li>假定在一个机构内部的计算机通信也是采用 TCP/IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/02f5459da7056a69307c4a820d4749e4c0acc157.png" alt="image-20201019235534728" tabindex="0" loading="lazy"><figcaption>image-20201019235534728</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/b8e675670bf18e3e9f98b5bdda47fe10d16a8048.png" alt="image-20201019235631474" tabindex="0" loading="lazy"><figcaption>image-20201019235631474</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/d2f6e266b72eac30bbb272622202145d1cfb9dee.png" alt="image-20201019235718010" tabindex="0" loading="lazy"><figcaption>image-20201019235718010</figcaption></figure>
<blockquote>
<p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p>
<p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/cda29a35fd0000286b26bf39362b3452b7a1d870.png" alt="image-20201020000136443" tabindex="0" loading="lazy"><figcaption>image-20201020000136443</figcaption></figure>
<blockquote>
<p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p>
<p>私有地址只能用作本地地址而不能用作全球地址</p>
<p>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</p>
<p><strong>本地地址与全球地址</strong></p>
<ul>
<li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li>
<li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。</li>
<li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li>
</ul>
</blockquote>
<p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p>
<figure><img src="https://i0.hdslb.com/bfs/album/18680fdba56d81c8eb3db43d1d11d83390527414.png" alt="image-20201020000618797" tabindex="0" loading="lazy"><figcaption>image-20201020000618797</figcaption></figure>
<p>部门A向部门B发送数据流程</p>
<figure><img src="https://i0.hdslb.com/bfs/album/fbb2612027d57cf89aa9226d5568237d6485aece.png" alt="image-20201020001107425" tabindex="0" loading="lazy"><figcaption>image-20201020001107425</figcaption></figure>
<blockquote>
<p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p>
<p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e97183050d36dde1c0a4e5dce552721864dd9cfe.png" alt="image-20201020001528569" tabindex="0" loading="lazy"><figcaption>image-20201020001528569</figcaption></figure>
<p>因此也被称为IP隧道技术</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/7ee9e4d221ba25af6498cbb7c77a932971d8d0d0.png" alt="image-20201020001935801" tabindex="0" loading="lazy"><figcaption>image-20201020001935801</figcaption></figure>
<h3> 9.2 网络地址转换NAT（Network Address Translation）</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/c544c47199fadc9176a6f97f95345236ce46ec22.png" alt="image-20201020002020607" tabindex="0" loading="lazy"><figcaption>image-20201020002020607</figcaption></figure>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e5f1ce30c6c48afbe8e2bd87ffd7082621db0f8b.png" alt="image-20201020002439942" tabindex="0" loading="lazy"><figcaption>image-20201020002439942</figcaption></figure>
<blockquote>
<p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p>
<p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/2726a8fae847399b66a6822d36178a15b91a37c4.png" alt="image-20201020002734192" tabindex="0" loading="lazy"><figcaption>image-20201020002734192</figcaption></figure>
<blockquote>
<p>专有NAT软件的路由器叫做NAT路由器</p>
<p>它至少有一个有效的外部全球IP地址</p>
<p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p>
</blockquote>
<p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p>
<figure><img src="https://i0.hdslb.com/bfs/album/ecdaacbfe8b9668c6feeef9efe52c4fdebfa5f8b.png" alt="image-20201020003238729" tabindex="0" loading="lazy"><figcaption>image-20201020003238729</figcaption></figure>
<p>因特网上的这台主机给源主机发回数据报</p>
<figure><img src="https://i0.hdslb.com/bfs/album/6feef8527b76547f408e1f79dc6e13e1b6965bf8.png" alt="image-20201020003411024" tabindex="0" loading="lazy"><figcaption>image-20201020003411024</figcaption></figure>
<p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p>
<figure><img src="https://i0.hdslb.com/bfs/album/682262324132869c3ef7b98203f64d7a9a254f5e.png" alt="image-20201020003658349" tabindex="0" loading="lazy"><figcaption>image-20201020003658349</figcaption></figure>
<p>这种基本转换存在一个问题</p>
<figure><img src="https://i0.hdslb.com/bfs/album/adada6bde499962944a4835bbcfbfbcff1ccd122.png" alt="image-20201020003733863" tabindex="0" loading="lazy"><figcaption>image-20201020003733863</figcaption></figure>
<p>解决方法</p>
<figure><img src="https://i0.hdslb.com/bfs/album/4a8746a123d942cfa615a99ce516624ed07e4bfd.png" alt="image-20201020003840584" tabindex="0" loading="lazy"><figcaption>image-20201020003840584</figcaption></figure>
<blockquote>
<p>我们现在用的很多家用路由器都是这种NART路由器</p>
</blockquote>
<p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p>
<p>否定</p>
<figure><img src="https://i0.hdslb.com/bfs/album/8f9ad6ebfe98f162a9a357a77991f71c9fa11c9b.png" alt="image-20201020004159360" tabindex="0" loading="lazy"><figcaption>image-20201020004159360</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/df6f168237dd54b9f7315796d3f5a5fa4c3fd455.png" alt="image-20201020004312942" tabindex="0" loading="lazy"><figcaption>image-20201020004312942</figcaption></figure>
<h3> 9.3 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/album/5d4a2cc0829d36149feb7ba2e45ea532f48e1943.png" alt="image-20201020004447021" tabindex="0" loading="lazy"><figcaption>image-20201020004447021</figcaption></figure>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-02-10T13:52:13.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">05 【计算机网络-运输层】</title>
    <id>https://blog.dselegent.cf/professional_knowledge/computer_network/05.html</id>
    <link href="https://blog.dselegent.cf/professional_knowledge/computer_network/05.html"/>
    <updated>2023-02-10T13:52:13.000Z</updated>
    <summary type="html"><![CDATA[<h1> 05 【计算机网络-运输层】</h1>
<h2> 1.运输层概述</h2>
<h3> 1.1 概念</h3>
<p><strong>进程之间的通信</strong></p>
<img src="https://i0.hdslb.com/bfs/new_dyn/41570a04266b6bbc098a1ba8b8e81be03493119651743993.png" alt="image-20201020211725185" style="zoom:67%;">
<ul>
<li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h1> 05 【计算机网络-运输层】</h1>
<h2> 1.运输层概述</h2>
<h3> 1.1 概念</h3>
<p><strong>进程之间的通信</strong></p>
<img src="https://i0.hdslb.com/bfs/new_dyn/41570a04266b6bbc098a1ba8b8e81be03493119651743993.png" alt="image-20201020211725185" style="zoom:67%;">
<ul>
<li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/514795d188c0621816fc9ac564e8fd763493119651743993.png" alt="image-20201020211339131" tabindex="0" loading="lazy"><figcaption>image-20201020211339131</figcaption></figure>
<p><strong>进程之间通信流程</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/00d2cc48eeab9df3630cdee44f1ac3013493119651743993.png" alt="image-20201020213721054" tabindex="0" loading="lazy"><figcaption>image-20201020213721054</figcaption></figure>
<p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p>
<blockquote>
<p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p>
<p>在运输层使用不同的端口，来对应不同的应用进程</p>
<p>然后通过网络层及其下层来传输应用层报文</p>
<p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p>
<p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/3fc74895f3f16dff0b6247eea2a9f05d3493119651743993.png" alt="image-20201020220439303" tabindex="0" loading="lazy"><figcaption>image-20201020220439303</figcaption></figure>
<h3> 1.2 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/cd8a5305c82d3079d32b55a23fdffb153493119651743993.png" alt="image-20201020220545411" tabindex="0" loading="lazy"><figcaption>image-20201020220545411</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/93ce95ee8760b53bf8ffc19a14630b263493119651743993.png" alt="image-20201020222828878" tabindex="0" loading="lazy"><figcaption>image-20201020222828878</figcaption></figure>
<h2> 2.运输层端口号、复用与分用的概念</h2>
<h3> 2.1 为什么用端口号</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/da2c703f9f32ba463d08126b6e642e8d3493119651743993.png" alt="image-20201020223242364" tabindex="0" loading="lazy"><figcaption>image-20201020223242364</figcaption></figure>
<h3> 2.2 发送方的复用和接收方的分用</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/8439a2ff4bb879e764d60d0447ee5ba93493119651743993.png" alt="image-20201020223920225" tabindex="0" loading="lazy"><figcaption>image-20201020223920225</figcaption></figure>
<blockquote>
<p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p>
<p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做  <strong>分用</strong>。</p>
</blockquote>
<h3> 2.3 TCP/IP体系的应用层常用协议所使用的运输层熟知端口号</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/739f6eb8d83162022207c862f575def63493119651743993.png" alt="image-20201020224521744" tabindex="0" loading="lazy"><figcaption>image-20201020224521744</figcaption></figure>
<h3> 2.4 运输层传输流程</h3>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/9f29e09225af246ce261233cb1e033933493119651743993.png" alt="image-20201020224658524" tabindex="0" loading="lazy"><figcaption>image-20201020224658524</figcaption></figure>
<blockquote>
<p>在浏览器输入域名，回车浏览</p>
<p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p>
<p>DNS查询请求报文需要使用运输层的UDP协议</p>
<p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p>
<p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/94bb63a7024dd359e6eb637d8103e8b33493119651743993.png" alt="image-20201020225830336" tabindex="0" loading="lazy"><figcaption>image-20201020225830336</figcaption></figure>
<blockquote>
<p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/7688294660827ad3a74cd7b92364b82e3493119651743993.png" alt="image-20201020230059196" tabindex="0" loading="lazy"><figcaption>image-20201020230059196</figcaption></figure>
<blockquote>
<p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p>
<p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p>
<p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p>
<p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p>
<p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/c685af22e1d85034ac4f257e2ef114c53493119651743993.png" alt="image-20201020231032812" tabindex="0" loading="lazy"><figcaption>image-20201020231032812</figcaption></figure>
<blockquote>
<p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/b6e7704a92991427eb8c6e675c0b2df63493119651743993.png" alt="image-20201020231308120" tabindex="0" loading="lazy"><figcaption>image-20201020231308120</figcaption></figure>
<blockquote>
<p>用户PC收到该数据报后，从中解封出UDP用户数据报</p>
<p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p>
<p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p>
</blockquote>
<p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/b098ba763cb9e997c13034a5240793653493119651743993.png" alt="image-20201020231935656" tabindex="0" loading="lazy"><figcaption>image-20201020231935656</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/94926e0102f33ca79fa50503aef6b81c3493119651743993.png" alt="image-20201020232517383" tabindex="0" loading="lazy"><figcaption>image-20201020232517383</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/d649b524048611a5d4b06634b4265d513493119651743993.png" alt="image-20201020232132890" tabindex="0" loading="lazy"><figcaption>image-20201020232132890</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/de42cf32ee1e302a784f96964a3758a33493119651743993.png" alt="image-20201020232548833" tabindex="0" loading="lazy"><figcaption>image-20201020232548833</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/8950054da9f95fdbde7ce0b33e1ed1cf3493119651743993.png" alt="image-20201020232337332" tabindex="0" loading="lazy"><figcaption>image-20201020232337332</figcaption></figure>
<h2> 3.UDP和TCP的对比</h2>
<h3> 3.1 概念</h3>
<ul>
<li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP/IP体系结构<strong>运输层</strong>中的两个重要协议</li>
<li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li>
<li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li>
</ul>
<p>可靠信道与不可靠信道</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/0b0cb53f6cd27ee1267acf07e5ffde3a3493119651743993.png" alt="image-20201021192221061" tabindex="0" loading="lazy"><figcaption>image-20201021192221061</figcaption></figure>
<ul>
<li>
<p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</p>
</li>
<li>
<p>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</p>
</li>
<li>
<p>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</p>
</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/b4cc780c46688f268f19c1e54dab0d193493119651743993.png" alt="image-20201021193640130" tabindex="0" loading="lazy"><figcaption>image-20201021193640130</figcaption></figure>
<p>UDP的通信是无连接的，不需要套接字（Socket）</p>
<p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p>
<h3> 3.2 用户数据报协议UDP（User Datagram Protocol）</h3>
<p>可以发送广播</p>
<img src="https://i0.hdslb.com/bfs/new_dyn/5172e1cadaa8aaf10494d5178e486c4d3493119651743993.png" alt="image-20201021194104694" style="zoom: 50%;">
<p>可以向某个多播组发送多播</p>
<img src="https://i0.hdslb.com/bfs/new_dyn/864d7a3925584a0adbc2b79cfa9c16a23493119651743993.png" alt="image-20201021194225567" style="zoom:50%;">
<p>还可以发送单播</p>
<img src="https://i0.hdslb.com/bfs/new_dyn/ab820046c36f867950267fedb27ebb823493119651743993.png" alt="image-20201021194341256" style="zoom:50%;">
<blockquote>
<p>UDP 支持单播、多播以及广播</p>
<p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p>
</blockquote>
<p>运输过程</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/67aa12d6c498f440378b88503bc12bc93493119651743993.png" alt="image-20201021195034383" tabindex="0" loading="lazy"><figcaption>image-20201021195034383</figcaption></figure>
<blockquote>
<p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p>
<p>换句话说，UDP是面向应用报文的</p>
</blockquote>
<p>UDP向上层提供无连接不可靠传输服务</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/db27f489b24d107f15d5919a47c52cb13493119651743993.png" alt="image-20201021204152175" tabindex="0" loading="lazy"><figcaption>image-20201021204152175</figcaption></figure>
<p>UDP结构</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/2be41d79635dbb8ece7c5611a74dc7123493119651743993.png" alt="image-20201021205214512" tabindex="0" loading="lazy"><figcaption>image-20201021205214512</figcaption></figure>
<h3> 3.3 传输控制协议TCP（Transmission Control Protocol）</h3>
<p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p>
<img src="https://i0.hdslb.com/bfs/new_dyn/66507c26395a78153ce680562d46782d3493119651743993.png" alt="image-20201021194557102" style="zoom:50%;">
<p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p>
<img src="https://i0.hdslb.com/bfs/new_dyn/ee0498549a4a44bf811020d3948cc7203493119651743993.png" alt="image-20201021194749562" style="zoom:50%;">
<blockquote>
<p>很显然，TCP仅支持单播，也就是一对一的通信</p>
</blockquote>
<p>运输过程</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/b1654f5505ecc9974b89021235439c573493119651743993.png" alt="image-20201021195435677" tabindex="0" loading="lazy"><figcaption>image-20201021195435677</figcaption></figure>
<blockquote>
<p>发送方</p>
<ul>
<li>
<p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p>
</li>
<li>
<p>并将他们编号，并存储在自己发送缓存中</p>
</li>
<li>
<p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li>
<li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li>
<li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li>
</ul>
<p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p>
<p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p>
</blockquote>
<p>TCP向上层提供面向连接的可靠传输服务</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/5c2424e8fd1a35f92c390316bff253fe3493119651743993.png" alt="image-20201021204508839" tabindex="0" loading="lazy"><figcaption>image-20201021204508839</figcaption></figure>
<p>TCP结构</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/f88e273a00e17e12ee75c08949196e4f3493119651743993.png" alt="image-20201021205307406" tabindex="0" loading="lazy"><figcaption>image-20201021205307406</figcaption></figure>
<h3> 3.4 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/6d9444a94d2aa0ef9a64eedcb9978b873493119651743993.png" alt="image-20201023004653315" tabindex="0" loading="lazy"><figcaption>image-20201023004653315</figcaption></figure>
<h2> 4.TCP的流量控制</h2>
<h3> 4.1 概念</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/05ef76386e36a42bdcf1e6a82ad99dbc3493119651743993.png" alt="image-20201021223432091" tabindex="0" loading="lazy"><figcaption>image-20201021223432091</figcaption></figure>
<p>举例</p>
<p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60" target="_blank" rel="noopener noreferrer">具体流程的视频</a></p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/a3c45c3f170288728ab154af5f03c89e3493119651743993.png" alt="image-20201021231801076" tabindex="0" loading="lazy"><figcaption>image-20201021231801076</figcaption></figure>
<p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/f800f437f814c92eba06131c99fdb86a3493119651743993.png" alt="image-20201021231904707" tabindex="0" loading="lazy"><figcaption>image-20201021231904707</figcaption></figure>
<p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/91f054d969b040a506c6449bd800ded03493119651743993.png" alt="image-20201021231945653" tabindex="0" loading="lazy"><figcaption>image-20201021231945653</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/432f587c8ffeb16da29735f6adfd567a3493119651743993.png" alt="image-20201021232027721" tabindex="0" loading="lazy"><figcaption>image-20201021232027721</figcaption></figure>
<p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/d7308fc752e4a62b04fd0c2d1b8e0cab3493119651743993.png" alt="image-20201021232600497" tabindex="0" loading="lazy"><figcaption>image-20201021232600497</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/117cd026f250e2e46a655bfcde84f00f3493119651743993.png" alt="image-20201021232645300" tabindex="0" loading="lazy"><figcaption>image-20201021232645300</figcaption></figure>
<blockquote>
<p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p>
<p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p>
</blockquote>
<h3> 4.2 总结</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/a3c3b35d21c347324f6ff8aca3c292aa3493119651743993.png" alt="image-20201021234004254" tabindex="0" loading="lazy"><figcaption>image-20201021234004254</figcaption></figure>
<h2> 5.TCP的拥塞控制</h2>
<h3> 5.1 概念</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/c57eef1ef9a497a885386347fbde65f33493119651743993.png" alt="image-20201022141057083" tabindex="0" loading="lazy"><figcaption>image-20201022141057083</figcaption></figure>
<p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p>
<ol>
<li>点缓存的容量太小；</li>
<li>链路的容量不足；</li>
<li>处理机处理的速率太慢；</li>
<li>拥塞本身会进一步加剧拥塞；</li>
</ol>
<p><strong>拥塞控制的一般原理</strong></p>
<ul>
<li>拥塞控制的前提：网络能够承受现有的网络负荷。</li>
<li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li>
<li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li>
<li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li>
</ul>
<p><strong>开环控制和闭环控制</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/e0d12c14eaf5bac0a7231aea446eaea33493119651743993.png" alt="image-20201022142108309" tabindex="0" loading="lazy"><figcaption>image-20201022142108309</figcaption></figure>
<p><strong>监测网络的拥塞</strong></p>
<p>主要指标有：</p>
<ol>
<li>由于缺少缓存空间而被丢弃的分组的百分数；</li>
<li>平均队列长度；</li>
<li>超时重传的分组数；</li>
<li>平均分组时延；</li>
<li>分组时延的标准差，等等。</li>
</ol>
<p>上述这些指标的上升都标志着拥塞的增长。</p>
<h3> 5.2 拥塞控制的算法</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/6d4477df3d2ef9bfc32b9efebde963f43493119651743993.png" alt="image-20201022141423443" tabindex="0" loading="lazy"><figcaption>image-20201022141423443</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/a417efa5ae3097d1e0be517191febbba3493119651743993.png" alt="image-20201022141556134" tabindex="0" loading="lazy"><figcaption>image-20201022141556134</figcaption></figure>
<blockquote>
<p>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</p>
</blockquote>
<p>下图的实例横纵坐标的意思</p>
<p>传输轮次：</p>
<ul>
<li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li>
<li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li>
<li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li>
</ul>
<p>拥塞窗口：</p>
<ul>
<li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li>
</ul>
<h4> 慢开始和拥塞避免</h4>
<h5> 慢开始（slow-start）</h5>
<ul>
<li>目的：用来确定网络的负载能力或拥塞程度。</li>
<li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li>
<li>两个变量：
<ul>
<li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。
<ul>
<li>1 至 2 个最大报文段 （旧标准）</li>
<li>2 至 4 个最大报文段 （RFC 5681）</li>
</ul>
</li>
<li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li>
</ul>
</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/ac0c46fb82f6867a3f74a0fb8955a1cc3493119651743993.png" alt="image-20201022145631052" tabindex="0" loading="lazy"><figcaption>image-20201022145631052</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/01d8dadc664cf35f8da89c389887e46a3493119651743993.png" alt="image-20201022144725100" tabindex="0" loading="lazy"><figcaption>image-20201022144725100</figcaption></figure>
<blockquote>
<p>图中swnd是发送窗口</p>
<p>每经过一个传输轮次，拥塞窗口就加倍</p>
<p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p>
</blockquote>
<h5> 拥塞避免（congestion avoidance）</h5>
<ul>
<li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li>
<li>每经过一个传输轮次，拥塞窗口 <strong>cwnd = cwnd + 1</strong>。</li>
<li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li>
<li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/01f7324e259dc1d10f17107075177d803493119651743993.png" alt="image-20201022150143886" tabindex="0" loading="lazy"><figcaption>image-20201022150143886</figcaption></figure>
<p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/fa74add2478dc878bddddb2062e9a8603493119651743993.png" alt="image-20201022145749592" tabindex="0" loading="lazy"><figcaption>image-20201022145749592</figcaption></figure>
<p>这个时候又回到了慢开始</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/0a9a43f07d7b03ea9fe47bf95ae356273493119651743993.png" alt="image-20201022145544163" tabindex="0" loading="lazy"><figcaption>image-20201022145544163</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/f9b2e88bf202262f21553f0353a7b32c3493119651743993.png" alt="image-20201022145824004" tabindex="0" loading="lazy"><figcaption>image-20201022145824004</figcaption></figure>
<h5> 两个算法完整示意图</h5>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/f96e848f1baa856bbf06fd5c103cc1e93493119651743993.png" alt="image-20201022150236926" tabindex="0" loading="lazy"><figcaption>image-20201022150236926</figcaption></figure>
<h4> 快重传和快恢复</h4>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/d4b9fca69495a3eb5c0d98032eeb6efa3493119651743993.png" alt="image-20201022150902709" tabindex="0" loading="lazy"><figcaption>image-20201022150902709</figcaption></figure>
<h5> 快重传（fast retrasmit）</h5>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/d3b6bc1a4f312d8fb229122ee36881ce3493119651743993.png" alt="image-20201022151250183" tabindex="0" loading="lazy"><figcaption>image-20201022151250183</figcaption></figure>
<h5> 快恢复（fast recovery）</h5>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/a64bb1bb041db36660ad47f9eb3b28d83493119651743993.png" alt="image-20201022151819265" tabindex="0" loading="lazy"><figcaption>image-20201022151819265</figcaption></figure>
<h5> 改进后的整体算法的示意图</h5>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/037416144066dca2ee7c328a8b0731263493119651743993.png" alt="image-20201022152041751" tabindex="0" loading="lazy"><figcaption>image-20201022152041751</figcaption></figure>
<hr>
<h2> 6.TCP超时重传时间的选择</h2>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/260855b0013c2db5effa2570e2823f223493119651743993.png" alt="image-20201022152651184" tabindex="0" loading="lazy"><figcaption>image-20201022152651184</figcaption></figure>
<blockquote>
<p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/029b4efc4a90a77a7f41934a7198d40b3493119651743993.png" alt="image-20201022152708875" tabindex="0" loading="lazy"><figcaption>image-20201022152708875</figcaption></figure>
<blockquote>
<p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/6ba0a5eceab7eae63253690a2d8e13a23493119651743993.png" alt="image-20201022153244047" tabindex="0" loading="lazy"><figcaption>image-20201022153244047</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/a32aa2bb920787680a3f736c0714120d3493119651743993.png" alt="image-20201022153518218" tabindex="0" loading="lazy"><figcaption>image-20201022153518218</figcaption></figure>
<p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/8820a548bf3b404f322d2c8e4eccf37b3493119651743993.png" alt="image-20201022153758413" tabindex="0" loading="lazy"><figcaption>image-20201022153758413</figcaption></figure>
<p><strong>往返时间RTT的测量比较复杂</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/5cf798f27d762e5b8c9a8a603ce553be3493119651743993.png" alt="image-20201022154045440" tabindex="0" loading="lazy"><figcaption>image-20201022154045440</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/ec4dc6c5bec083bbfb6f77cffd6e79b43493119651743993.png" alt="image-20201022154137911" tabindex="0" loading="lazy"><figcaption>image-20201022154137911</figcaption></figure>
<p><strong>TCP超时重传的计算</strong></p>
<p>举例</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/f40ec68d008f457d2ec30fc99eb7d8e43493119651743993.png" alt="image-20201022154350745" tabindex="0" loading="lazy"><figcaption>image-20201022154350745</figcaption></figure>
<p><strong>总结</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/821e0c67e063447feb4160e3dc9e83a13493119651743993.png" alt="image-20201022154418863" tabindex="0" loading="lazy"><figcaption>image-20201022154418863</figcaption></figure>
<hr>
<h2> 7.TCP可靠传输的实现</h2>
<p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=63" target="_blank" rel="noopener noreferrer">本集具体讲解</a></p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/8ffeb0ed3a148f3f737407e86f38e4423493119651743993.png" alt="image-20201022161436801" tabindex="0" loading="lazy"><figcaption>image-20201022161436801</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/b0ccba07154ba893948b0d2218d680973493119651743993.png" alt="image-20201022161734997" tabindex="0" loading="lazy"><figcaption>image-20201022161734997</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/2ca25592ebbd37f9932c4b573bf34be13493119651743993.png" alt="image-20201022164339902" tabindex="0" loading="lazy"><figcaption>image-20201022164339902</figcaption></figure>
<h2> 8.TCP的运输连接管理</h2>
<h3> 8.1 概念</h3>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/0001dcd9d0c6c1f81c1d753da1f2699f3493119651743993.png" alt="image-20201022193215183" tabindex="0" loading="lazy"><figcaption>image-20201022193215183</figcaption></figure>
<h3> 8.2 TCP的连接建立</h3>
<ul>
<li>TCP 建立连接的过程叫做<strong>握手</strong>。</li>
<li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li>
<li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li>
</ul>
<h4> TCP的连接建立要解决以下三个问题</h4>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/6386057160436d945505a96ff1d76a893493119651743993.png" alt="image-20201022193418673" tabindex="0" loading="lazy"><figcaption>image-20201022193418673</figcaption></figure>
<h4> TCP使用“三报文握手”建立连接</h4>
<ul>
<li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li>
</ul>
<p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p>
<p>过程</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/fe4a622ecffd108552d14b42ae5f83473493119651743993.png" alt="image-20201022194219693" tabindex="0" loading="lazy"><figcaption>image-20201022194219693</figcaption></figure>
<blockquote>
<p>最初两端的TCP进程都处于关闭状态</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/baaf74bf04183360b1190edb22c08f8c3493119651743993.png" alt="image-20201022194350899" tabindex="0" loading="lazy"><figcaption>image-20201022194350899</figcaption></figure>
<blockquote>
<p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p>
<p>之后，就准备接受TCP客户端进程的连接请求</p>
<p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p>
</blockquote>
<p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/9bbf13ecfa4f0e358b166eac2c1a47f63493119651743993.png" alt="image-20201022194926877" tabindex="0" loading="lazy"><figcaption>image-20201022194926877</figcaption></figure>
<blockquote>
<p>TCP客户进程也是首先创建传输控制块</p>
</blockquote>
<p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/0203ddba49258c2a5dab40b9a99908bf3493119651743993.png" alt="image-20201022195108616" tabindex="0" loading="lazy"><figcaption>image-20201022195108616</figcaption></figure>
<blockquote>
<p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p>
<p>TCP连接请求报文段首部中</p>
<ul>
<li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li>
<li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li>
</ul>
<p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/ea00c23ec83c1652c174793ec8c2fd0f3493119651743993.png" alt="image-20201022195847144" tabindex="0" loading="lazy"><figcaption>image-20201022195847144</figcaption></figure>
<blockquote>
<p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p>
<p>TCP连接请求确认报文段首部中</p>
<ul>
<li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li>
<li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li>
<li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li>
</ul>
<p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/2be0b93f85212383d5733fe57f53a05d3493119651743993.png" alt="image-20201022202010182" tabindex="0" loading="lazy"><figcaption>image-20201022202010182</figcaption></figure>
<blockquote>
<p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已建立状态</p>
<p>普通的TCP确认报文段首部中</p>
<ul>
<li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li>
<li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li>
<li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li>
</ul>
<p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/1e923c78f9a1aab97c12df22d5aff6873493119651743993.png" alt="image-20201022202932905" tabindex="0" loading="lazy"><figcaption>image-20201022202932905</figcaption></figure>
<blockquote>
<p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p>
<p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p>
</blockquote>
<p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p>
<p>下图实例是“两报文握手”</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/580888a7e06aa135eadc7786752ef2b53493119651743993.png" alt="image-20201022203744174" tabindex="0" loading="lazy"><figcaption>image-20201022203744174</figcaption></figure>
<blockquote>
<p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有&gt; 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个&gt; 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同&gt; 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因&gt; 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。</p>
<p>所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p>
</blockquote>
<h4> 总结</h4>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/356221db9fac475e2fee97233e2dfd8b3493119651743993.png" alt="image-20201022204422775" tabindex="0" loading="lazy"><figcaption>image-20201022204422775</figcaption></figure>
<h3> TCP的连接释放</h3>
<ul>
<li>TCP 连接释放过程比较复杂。</li>
<li>数据传输结束后，通信的双方都可释放连接。</li>
<li>TCP 连接释放过程是<strong>四报文握手</strong>。</li>
</ul>
<h4> TCP通过“四报文挥手”来释放连接</h4>
<ul>
<li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li>
<li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li>
<li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li>
<li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li>
</ul>
<p>过程</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/896c47433b7295a9b74da5af687831563493119651743993.png" alt="image-20201022205124204" tabindex="0" loading="lazy"><figcaption>image-20201022205124204</figcaption></figure>
<blockquote>
<p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p>
<p>TCP客户进程的应用进程通知其主动关闭TCP连接</p>
<p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p>
<p>TCP连接释放报文段首部中</p>
<ul>
<li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li>
<li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li>
<li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li>
</ul>
<p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/4fc3bf1ceca46dfec04a5a1601048f933493119651743993.png" alt="image-20201022210030419" tabindex="0" loading="lazy"><figcaption>image-20201022210030419</figcaption></figure>
<blockquote>
<p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p>
<p>普通的TCP确认报文段首部中</p>
<ul>
<li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li>
<li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li>
<li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/1b833114c2f46c4f4bb4d709b502358e3493119651743993.png" alt="image-20201022232158631" tabindex="0" loading="lazy"><figcaption>image-20201022232158631</figcaption></figure>
<blockquote>
<p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p>
<p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p>
<p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p>
<p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/dc2f13d274f2d0a461886249c01259703493119651743993.png" alt="image-20201022233050922" tabindex="0" loading="lazy"><figcaption>image-20201022233050922</figcaption></figure>
<blockquote>
<p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p>
<p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p>
<p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/12951bb93324e2d14f509c312ec16cbf3493119651743993.png" alt="image-20201022233941557" tabindex="0" loading="lazy"><figcaption>image-20201022233941557</figcaption></figure>
<blockquote>
<p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p>
<p>该报文段首部中</p>
<ul>
<li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li>
<li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li>
<li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li>
</ul>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/885111080586ecca39b70c21514409f03493119651743993.png" alt="image-20201022234741310" tabindex="0" loading="lazy"><figcaption>image-20201022234741310</figcaption></figure>
<blockquote>
<p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p>
<p>该报文段首部中</p>
<ul>
<li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li>
<li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li>
<li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li>
</ul>
<p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p>
</blockquote>
<p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/d0fc8fa8271872a9f8464a3c468828053493119651743993.png" alt="image-20201022234942562" tabindex="0" loading="lazy"><figcaption>image-20201022234942562</figcaption></figure>
<blockquote>
<p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p>
<p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p>
</blockquote>
<h4> TCP保活计时器的作用</h4>
<p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p>
<p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p>
<p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/9f9ae8702673494130392caa4bf821023493119651743993.png" alt="image-20201022235800155" tabindex="0" loading="lazy"><figcaption>image-20201022235800155</figcaption></figure>
<h2> 9.TCP报文段的首部格式</h2>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/89ef95babf44920afc24a339fc63837c3493119651743993.png" alt="image-20201023000859363" tabindex="0" loading="lazy"><figcaption>image-20201023000859363</figcaption></figure>
<h3> 9.1 各字段的作用</h3>
<p>源端口和目的端口</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/ba4189861ae7c65a2a4f452d80f2d5d13493119651743993.png" alt="image-20201023005210010" tabindex="0" loading="lazy"><figcaption>image-20201023005210010</figcaption></figure>
<p>序号、确认号和确认标志位</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/8943bb6ebb718364a47d2b7c82a727463493119651743993.png" alt="image-20201023003826059" tabindex="0" loading="lazy"><figcaption>image-20201023003826059</figcaption></figure>
<p>数据偏移、保留、窗口和校验和</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/78f13729f5e2c0e97f8a4592553e89fb3493119651743993.png" alt="image-20201023004227265" tabindex="0" loading="lazy"><figcaption>image-20201023004227265</figcaption></figure>
<p>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/49d7739e26dff675c1648fc7aa85899a3493119651743993.png" alt="image-20201023005001450" tabindex="0" loading="lazy"><figcaption>image-20201023005001450</figcaption></figure>
<p>选项和填充</p>
<figure><img src="https://i0.hdslb.com/bfs/new_dyn/c2928f30a9fe68f3cfaf4af43277c19b3493119651743993.png" alt="image-20201023005132426" tabindex="0" loading="lazy"><figcaption>image-20201023005132426</figcaption></figure>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-02-10T13:52:13.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">06 【计算机网络-应用层】</title>
    <id>https://blog.dselegent.cf/professional_knowledge/computer_network/06.html</id>
    <link href="https://blog.dselegent.cf/professional_knowledge/computer_network/06.html"/>
    <updated>2023-02-10T13:52:13.000Z</updated>
    <summary type="html"><![CDATA[<h1> 06 【计算机网络-应用层】</h1>
<h2> 1.应用层概述</h2>
<figure><img src="https://article.biliimg.com/bfs/article/7a067ff7ed5f2a814f3c79dc8e1b2ff09d4fb917.png" alt="image-20201023195112701" tabindex="0" loading="lazy"><figcaption>image-20201023195112701</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/107b2834eb0dd39dc064b741df13662ef9a2e219.png" alt="image-20201023200511781" tabindex="0" loading="lazy"><figcaption>image-20201023200511781</figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<h1> 06 【计算机网络-应用层】</h1>
<h2> 1.应用层概述</h2>
<figure><img src="https://article.biliimg.com/bfs/article/7a067ff7ed5f2a814f3c79dc8e1b2ff09d4fb917.png" alt="image-20201023195112701" tabindex="0" loading="lazy"><figcaption>image-20201023195112701</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/107b2834eb0dd39dc064b741df13662ef9a2e219.png" alt="image-20201023200511781" tabindex="0" loading="lazy"><figcaption>image-20201023200511781</figcaption></figure>
<p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p>
<figure><img src="https://article.biliimg.com/bfs/article/ac0a8a353cdc32b669e17edf23eddc532e2a3161.png" alt="image-20201023200819770" tabindex="0" loading="lazy"><figcaption>image-20201023200819770</figcaption></figure>
<p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP/IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p>
<figure><img src="https://article.biliimg.com/bfs/article/b05babe0bc0665e29b8328eeb5c834c2d698b84a.png" alt="image-20201023201028141" tabindex="0" loading="lazy"><figcaption>image-20201023201028141</figcaption></figure>
<p>常见的应用</p>
<figure><img src="https://article.biliimg.com/bfs/article/4430160818180c538bde81a48d5f728412bb00f5.png" alt="image-20201023201101024" tabindex="0" loading="lazy"><figcaption>image-20201023201101024</figcaption></figure>
<p>总结</p>
<figure><img src="https://article.biliimg.com/bfs/article/6a25eceda46b60664e040ab17e76ecad3da6219b.png" alt="image-20201023201137047" tabindex="0" loading="lazy"><figcaption>image-20201023201137047</figcaption></figure>
<h2> 2.客户/服务器方式（C/S方式）和对等方式（P2P方式）</h2>
<h3> 2.1 概念</h3>
<figure><img src="https://article.biliimg.com/bfs/article/69454720ceb19d7b2f75b464df5551997f291fc6.png" alt="image-20201023201308269" tabindex="0" loading="lazy"><figcaption>image-20201023201308269</figcaption></figure>
<h3> 2.2 客户/服务器方式（C/S方式）</h3>
<figure><img src="https://article.biliimg.com/bfs/article/3cd6f41ed422be7194fc09a451c71745ae84a6e0.png" alt="image-20201023201610088" tabindex="0" loading="lazy"><figcaption>image-20201023201610088</figcaption></figure>
<h3> 2.3 对等方式（P2P方式）</h3>
<figure><img src="https://article.biliimg.com/bfs/article/391c8c31503bd6a97c6e4bc9987e766b0f0921e2.png" alt="image-20201023202017683" tabindex="0" loading="lazy"><figcaption>image-20201023202017683</figcaption></figure>
<h3> 2.4 总结</h3>
<figure><img src="https://article.biliimg.com/bfs/article/2afe2cf58cdbc42591616c3ee11396b3413b0473.png" alt="image-20201023202049202" tabindex="0" loading="lazy"><figcaption>image-20201023202049202</figcaption></figure>
<h2> 3.动态主机配置协议DHCP</h2>
<h3> 3.1 概念</h3>
<ul>
<li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li>
<li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li>
</ul>
<h3> 3.2 DHCP的作用</h3>
<p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p>
<figure><img src="https://article.biliimg.com/bfs/article/e2ed42551a923d64d0816a427a8640188200f8c6.png" alt="image-20201023205719672" tabindex="0" loading="lazy"><figcaption>image-20201023205719672</figcaption></figure>
<blockquote>
<p>如果主机数很多，就工作量大，容易出错</p>
</blockquote>
<p>如果我们给网络中添加一台DHCP服务器</p>
<figure><img src="https://article.biliimg.com/bfs/article/a9435f198b5bb389f37ff3a3fd97d8a2774adc78.png" alt="image-20201023210345650" tabindex="0" loading="lazy"><figcaption>image-20201023210345650</figcaption></figure>
<h3> 3.3 DHCP的工作过程</h3>
<p><strong>DHCP 使用客户 - 服务器方式</strong></p>
<ul>
<li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文
（DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li>
<li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li>
<li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li>
</ul>
<p><strong>DHCP 工作方式</strong></p>
<ul>
<li>DHCP 使用客户-服务器方式，采用请求/应答方式工作。</li>
<li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li>
</ul>
<p><strong>DHCP交互过程</strong></p>
<figure><img src="https://article.biliimg.com/bfs/article/f6631476f91f09c2d4ef4abc72def2fa76aea4e1.png" alt="image-20201023211525686" tabindex="0" loading="lazy"><figcaption>image-20201023211525686</figcaption></figure>
<blockquote>
<p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p>
<ul>
<li>事务ID</li>
<li>DHCP客户端的MAC地址</li>
</ul>
<p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p>
<p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p>
<p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p>
</blockquote>
<figure><img src="https://article.biliimg.com/bfs/article/8ba46bf8c4d0620d887629ed42454fd19323d5a9.png" alt="image-20201023213058543" tabindex="0" loading="lazy"><figcaption>image-20201023213058543</figcaption></figure>
<blockquote>
<p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p>
<ul>
<li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li>
<li>配置信息：
<ul>
<li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li>
<li>子网掩码</li>
<li>地址租期</li>
<li>默认网关</li>
<li>DNS服务器</li>
</ul>
</li>
</ul>
<p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p>
<p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p>
</blockquote>
<p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p>
<figure><img src="https://article.biliimg.com/bfs/article/c84533e1a201882d4c80d441eef0f3b592e78ccd.png" alt="image-20201023214542329" tabindex="0" loading="lazy"><figcaption>image-20201023214542329</figcaption></figure>
<blockquote>
<p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p>
<ul>
<li>事务ID</li>
<li>DHCP客户端的MAC地址</li>
<li>接收的租约中的IP地址</li>
<li>提供此租约的DHCP服务器端的IP地址</li>
</ul>
<p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p>
<p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p>
</blockquote>
<p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p>
<figure><img src="https://article.biliimg.com/bfs/article/1fa8336596f4b959a6505aa10192ec98b390eca5.png" alt="image-20201023215341522" tabindex="0" loading="lazy"><figcaption>image-20201023215341522</figcaption></figure>
<blockquote>
<p>源地址：DHCP服务器1的IP地址</p>
<p>目的地址：广播地址</p>
<p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p>
<p><strong>在使用前还会进行ARP检测</strong></p>
<figure><img src="https://article.biliimg.com/bfs/article/9fa28b2ff711b115a4ada7d4767cf20977790ed4.png" alt="image-20201023215652859" tabindex="0" loading="lazy"><figcaption>image-20201023215652859</figcaption></figure>
</blockquote>
<p>剩下流程图示</p>
<figure><img src="https://article.biliimg.com/bfs/article/5bde5134044b7704ad27735b4d3c69d63c939dd8.png" alt="image-20201023220114952" tabindex="0" loading="lazy"><figcaption>image-20201023220114952</figcaption></figure>
<h3> 3.4 DHCP中继代理</h3>
<p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p>
<figure><img src="https://article.biliimg.com/bfs/article/755a110ae3d18c57cd4ed8c14b749b1c6c11f8e5.png" alt="image-20201023221111923" tabindex="0" loading="lazy"><figcaption>image-20201023221111923</figcaption></figure>
<blockquote>
<p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p>
</blockquote>
<h3> 3.5 总结</h3>
<figure><img src="https://article.biliimg.com/bfs/article/55e34681dfe1292c168b72a8976335f96ec80edf.png" alt="image-20201023221251022" tabindex="0" loading="lazy"><figcaption>image-20201023221251022</figcaption></figure>
<h2> 4.域名系统DNS</h2>
<h3> 4.1 概述</h3>
<p>域名相比IP地址更容易记忆</p>
<figure><img src="https://article.biliimg.com/bfs/article/77af2c54eeb5b87f4be5aa46b9241488881d15bc.png" alt="image-20201023234832678" tabindex="0" loading="lazy"><figcaption>image-20201023234832678</figcaption></figure>
<p>因特网是否可以只使用一台DNS服务器？</p>
<p>不行</p>
<figure><img src="https://article.biliimg.com/bfs/article/f71963f7024eece58fbb9e926c4856bd41c11b19.png" alt="image-20201023235123151" tabindex="0" loading="lazy"><figcaption>image-20201023235123151</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/fbb9f4c876a9fcbb68e209f3c285554ad48ca252.png" alt="image-20201023235231869" tabindex="0" loading="lazy"><figcaption>image-20201023235231869</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/7961b69efb3935b9b6120c8821af721458abc685.png" alt="image-20201023235457857" tabindex="0" loading="lazy"><figcaption>image-20201023235457857</figcaption></figure>
<blockquote>
<p>名称相同的域名其等级未必相同</p>
</blockquote>
<figure><img src="https://article.biliimg.com/bfs/article/0c173d2ef4a174d3ef4a8e24064388c9003367f7.png" alt="image-20201023235617575" tabindex="0" loading="lazy"><figcaption>image-20201023235617575</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/469b16834236d72959fb2ffa8115641659cc8dac.png" alt="image-20201023235910545" tabindex="0" loading="lazy"><figcaption>image-20201023235910545</figcaption></figure>
<h3> 4.2 域名解析过程</h3>
<figure><img src="https://article.biliimg.com/bfs/article/35f8dc93bcb4d5ec3ea9bd2deaf65aafc3d95b63.png" alt="image-20201024000255580" tabindex="0" loading="lazy"><figcaption>image-20201024000255580</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/d1786f608a834df805af565f1cae25c311fca9c4.png" alt="image-20201024000335147" tabindex="0" loading="lazy"><figcaption>image-20201024000335147</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/1e764e2458e6504ca05c008a95a8be0f329f345a.png" alt="image-20201024000408396" tabindex="0" loading="lazy"><figcaption>image-20201024000408396</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/0d155528277be957f3042dc62ae1bb3b35a1143c.png" alt="image-20201024002135210" tabindex="0" loading="lazy"><figcaption>image-20201024002135210</figcaption></figure>
<h3> 4.3 总结</h3>
<figure><img src="https://article.biliimg.com/bfs/article/02bd5d23ec91e30eebabb14616f5f5eb46298a52.png" alt="image-20201024002224354" tabindex="0" loading="lazy"><figcaption>image-20201024002224354</figcaption></figure>
<h2> 5.文件传送协议FTP</h2>
<h3> 5.1 概念</h3>
<figure><img src="https://article.biliimg.com/bfs/article/8cbb06251862b22d326c57f317e42d28e6caec90.png" alt="image-20201024132745558" tabindex="0" loading="lazy"><figcaption>image-20201024132745558</figcaption></figure>
<h3> 5.2 文件传送协议FTP的应用</h3>
<p>FTP采用C/S方式（客户/服务器方式）</p>
<p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p>
<img src="https://article.biliimg.com/bfs/article/c3cf82c93a5bea8596e92c7b4968f7abb5fa03aa.png" alt="image-20201024133155327" style="zoom:50%;">
<p>FTP客户计算机也可以从FTP服务器计算机下载文件</p>
<img src="https://article.biliimg.com/bfs/article/de9e5ae40ad55f5906e543addc0556f100bcb2a2.png" alt="image-20201024133247537" style="zoom:50%;">
<figure><img src="https://article.biliimg.com/bfs/article/7f92dbfb1ef29797b9cf9962b74e2a2d7b2793d2.png" alt="image-20201024133400777" tabindex="0" loading="lazy"><figcaption>image-20201024133400777</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/58a99bbcf3eb7f53aedbb7e10f38d67f68732291.png" alt="image-20201024133601943" tabindex="0" loading="lazy"><figcaption>image-20201024133601943</figcaption></figure>
<h3> 5.3 FTP基本工作原理</h3>
<p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p>
<p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p>
<figure><img src="https://article.biliimg.com/bfs/article/1fb4b0253cdcf252355fd95fd84e98cfa63a6369.png" alt="image-20201024134319922" tabindex="0" loading="lazy"><figcaption>image-20201024134319922</figcaption></figure>
<p>下图为建立数据通道的TCP连接</p>
<p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p>
<figure><img src="https://article.biliimg.com/bfs/article/f394a1d54bab7d7e91168e6314628c5a519a1b02.png" alt="image-20201024134624114" tabindex="0" loading="lazy"><figcaption>image-20201024134624114</figcaption></figure>
<blockquote>
<p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p>
</blockquote>
<p>下图实例为被动模式</p>
<img src="https://article.biliimg.com/bfs/article/473851153daafb4e79a97bf2c5d9f8f9cb2eb05e.png" alt="image-20201024135018620" style="zoom:67%;">
<p>两种模式对比</p>
<figure><img src="https://article.biliimg.com/bfs/article/5864c7ac1834c3fabcc24251aacd12cba6962504.png" alt="image-20201024135050743" tabindex="0" loading="lazy"><figcaption>image-20201024135050743</figcaption></figure>
<blockquote>
<p>注意两种模式都是</p>
<p>控制连接在整个会话期间保持打开状态</p>
<p>数据连接传输完毕后就关闭</p>
</blockquote>
<h3> 5.4 总结</h3>
<figure><img src="https://article.biliimg.com/bfs/article/1b3285f1d1fa759b39a3499c372c99c1aba61176.png" alt="image-20201024135848563" tabindex="0" loading="lazy"><figcaption>image-20201024135848563</figcaption></figure>
<h2> 6.电子邮件</h2>
<h3> 6.1 概念</h3>
<figure><img src="https://article.biliimg.com/bfs/article/b8244f53f3e14805fc7eb4d63e9e1a0955135a10.png" alt="image-20201024151757221" tabindex="0" loading="lazy"><figcaption>image-20201024151757221</figcaption></figure>
<h3> 6.2 邮件发送和接收过程</h3>
<figure><img src="https://article.biliimg.com/bfs/article/990578bfce9796f8107b2148d163fa3dd8808c11.png" alt="image-20201024152052056" tabindex="0" loading="lazy"><figcaption>image-20201024152052056</figcaption></figure>
<h3> 6.3 简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h3>
<figure><img src="https://article.biliimg.com/bfs/article/01ad4d6abf564c8ee1463e7817c784e82a32b044.png" alt="image-20201024152628966" tabindex="0" loading="lazy"><figcaption>image-20201024152628966</figcaption></figure>
<h3> 6.4 电子邮件的信息格式</h3>
<figure><img src="https://article.biliimg.com/bfs/article/3ce616adc58f3fca06e013778d22fb8a5d627373.png" alt="image-20201024153425016" tabindex="0" loading="lazy"><figcaption>image-20201024153425016</figcaption></figure>
<h3> 6.5 邮件读取</h3>
<figure><img src="https://article.biliimg.com/bfs/article/4edfb716c513dbed221e0592ddea29ddaf489957.png" alt="image-20201024153736033" tabindex="0" loading="lazy"><figcaption>image-20201024153736033</figcaption></figure>
<h3> 6.6 基于万维网的电子邮件</h3>
<figure><img src="https://article.biliimg.com/bfs/article/e3ba29b0d7e555b6b0978b1e8f5c6e68846e739a.png" alt="image-20201024154039565" tabindex="0" loading="lazy"><figcaption>image-20201024154039565</figcaption></figure>
<h3> 6.7 总结</h3>
<figure><img src="https://article.biliimg.com/bfs/article/957aff7ecaf9ec415b39abafd00b716f32b7b722.png" alt="image-20201024154744175" tabindex="0" loading="lazy"><figcaption>image-20201024154744175</figcaption></figure>
<h2> 7.万维网WWW</h2>
<h3> 7.1 概念</h3>
<p><strong>概述</strong></p>
<ul>
<li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li>
<li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li>
<li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li>
<li>这种访问方式称为“<strong>链接</strong>”。</li>
</ul>
<p><strong>万维网的工作方式</strong></p>
<ul>
<li>万维网以<strong>客户 - 服务器</strong>方式工作。</li>
<li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li>
<li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li>
<li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li>
</ul>
<figure><img src="https://article.biliimg.com/bfs/article/741207c25abd283ee6ffa9e4ee36bb26a2eae7d4.png" alt="image-20201024170819303" tabindex="0" loading="lazy"><figcaption>image-20201024170819303</figcaption></figure>
<figure><img src="https://article.biliimg.com/bfs/article/ca655f7df0d91200596ccc85529f7a3a6a1557a0.png" alt="image-20201024171432743" tabindex="0" loading="lazy"><figcaption>image-20201024171432743</figcaption></figure>
<p><strong>万维网应用举例</strong></p>
<p>访问网页</p>
<figure><img src="https://article.biliimg.com/bfs/article/d2a54a46502f4afb2a7b451b5c17fe2c083e561b.png" alt="image-20201024170923530" tabindex="0" loading="lazy"><figcaption>image-20201024170923530</figcaption></figure>
<p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p>
<figure><img src="https://article.biliimg.com/bfs/article/3ab1d7ef0ddd42551fb2a1ffce6040f31fa9a8e6.png" alt="image-20201024171058583" tabindex="0" loading="lazy"><figcaption>image-20201024171058583</figcaption></figure>
<p><strong>万维网的文档</strong></p>
<figure><img src="https://article.biliimg.com/bfs/article/3de1b148b0a6ba5d7e2af512959753c533788dc0.png" alt="image-20201024171724030" tabindex="0" loading="lazy"><figcaption>image-20201024171724030</figcaption></figure>
<h3> 7.2 超文本传输协议HTTP（Hyper Transfer Protocol）</h3>
<h4> 概念和传输过程</h4>
<ul>
<li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li>
<li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li>
</ul>
<figure><img src="https://article.biliimg.com/bfs/article/0cfaf51d59e9cb0c85dd82e67b7425a7c36f9c8d.png" alt="image-20201024222457800" tabindex="0" loading="lazy"><figcaption>image-20201024222457800</figcaption></figure>
<ul>
<li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li>
<li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li>
<li>最后，TCP 连接就被释放了。</li>
</ul>
<figure><img src="https://article.biliimg.com/bfs/article/5701649ac0b1afdb5539a54d0c87e6f4d63a65d2.png" alt="image-20201024222825888" tabindex="0" loading="lazy"><figcaption>image-20201024222825888</figcaption></figure>
<h4> HTTP报文格式</h4>
<p><strong>HTTP请求报文格式</strong></p>
<figure><img src="https://article.biliimg.com/bfs/article/e970a7fc735a271dfec588b43acd001fc8f11ca6.png" alt="image-20201024224828528" tabindex="0" loading="lazy"><figcaption>image-20201024224828528</figcaption></figure>
<p><strong>HTTP响应报文格式</strong></p>
<figure><img src="https://article.biliimg.com/bfs/article/1ce1f6b993e830dfb149b3cb77692e1d5ea743b4.png" alt="image-20201024224920638" tabindex="0" loading="lazy"><figcaption>image-20201024224920638</figcaption></figure>
<h4> 使用Cookie在服务器上记录用户信息</h4>
<figure><img src="https://article.biliimg.com/bfs/article/7369851d2ee3978ac817f60655ec4c606fa0ede8.png" alt="image-20201024224945200" tabindex="0" loading="lazy"><figcaption>image-20201024224945200</figcaption></figure>
<h4> 万维网缓存与代理服务器</h4>
<figure><img src="https://article.biliimg.com/bfs/article/0829ae41fe6ec2b2e7b8a764db4399e89c0f40d5.png" alt="image-20201024224632514" tabindex="0" loading="lazy"><figcaption>image-20201024224632514</figcaption></figure>
<p>如果该请求有缓存</p>
<figure><img src="https://article.biliimg.com/bfs/article/65074134d07a40c4e12be4398799a12922c8cb00.png" alt="image-20201024224720124" tabindex="0" loading="lazy"><figcaption>image-20201024224720124</figcaption></figure>
<p>如果该请求没有缓存</p>
<figure><img src="https://article.biliimg.com/bfs/article/c6f1d58cd21eae63bf65d1120328e2287c6cb0c5.png" alt="image-20201024225013288" tabindex="0" loading="lazy"><figcaption>image-20201024225013288</figcaption></figure>
<blockquote>
<p>若WEb缓存的命中率比较高</p>
<p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p>
</blockquote>
<p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p>
<p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p>
<p>若未过期</p>
<figure><img src="https://article.biliimg.com/bfs/article/61274f1628c98e4eca5f88ce3b77dbee01719503.png" alt="image-20201024225504869" tabindex="0" loading="lazy"><figcaption>image-20201024225504869</figcaption></figure>
<p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p>
<figure><img src="https://article.biliimg.com/bfs/article/81cfa2c7ea76840cb49c3320f01beeffab6bf83c.png" alt="image-20201024225846863" tabindex="0" loading="lazy"><figcaption>image-20201024225846863</figcaption></figure>
<p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p>
<figure><img src="https://article.biliimg.com/bfs/article/18c58e3c8cded08a7d4e1e32014aaf4cdc5f9f91.png" alt="image-20201024230242550" tabindex="0" loading="lazy"><figcaption>image-20201024230242550</figcaption></figure>
<h3> 7.3 总结</h3>
<figure><img src="https://article.biliimg.com/bfs/article/90c80da9e178c821def658cb665dc8745389accd.png" alt="image-20201024231143505" tabindex="0" loading="lazy"><figcaption>image-20201024231143505</figcaption></figure>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-02-10T13:52:13.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">01 【入门篇-介绍和安装】</title>
    <id>https://blog.dselegent.cf/back_end/linux/01.html</id>
    <link href="https://blog.dselegent.cf/back_end/linux/01.html"/>
    <updated>2023-01-30T06:57:36.000Z</updated>
    <summary type="html"><![CDATA[<h1> 01 【入门篇-介绍和安装】</h1>
<h2> 1.Linux课程介绍</h2>
<h3> 1.1 学习方向</h3>
<ul>
<li>linux运维工程师： 维护linux的服务器（一般大型企业）</li>
<li>linux嵌入式工程师： linux做驱动开发，或者linux的嵌入式</li>
<li>linux下开发项目
<img src="https://i0.hdslb.com/bfs/album/08c3b1b814156e29bf4e53e0b59f4961a9f0bc41.jpg" alt="学习方向" loading="lazy"></li>
</ul>
<h3> 1.2 应用领域</h3>]]></summary>
    <content type="html"><![CDATA[<h1> 01 【入门篇-介绍和安装】</h1>
<h2> 1.Linux课程介绍</h2>
<h3> 1.1 学习方向</h3>
<ul>
<li>linux运维工程师： 维护linux的服务器（一般大型企业）</li>
<li>linux嵌入式工程师： linux做驱动开发，或者linux的嵌入式</li>
<li>linux下开发项目
<img src="https://i0.hdslb.com/bfs/album/08c3b1b814156e29bf4e53e0b59f4961a9f0bc41.jpg" alt="学习方向" loading="lazy"></li>
</ul>
<h3> 1.2 应用领域</h3>
<ul>
<li>个人桌面</li>
<li>服务器应用
<ul>
<li>免费，稳定，高效</li>
</ul>
</li>
<li>侵入式应用
<ul>
<li>机顶盒，手机，数字电视，智能家居等</li>
</ul>
</li>
</ul>
<h3> 1.3 学习进阶</h3>
<ol>
<li>学习基本指令
<ul>
<li>文件操作指令</li>
<li>编辑工具</li>
<li>用户管理</li>
</ul>
</li>
<li>linux系统配置
<ul>
<li>环境变量，网络配置，服务配置</li>
</ul>
</li>
<li>linux环境下搭建开发环境
<ul>
<li>大数据 JavaEE Python 等</li>
</ul>
</li>
<li>编写shell脚本，对Linux服务器维护</li>
<li>安全设置，防止攻击，保证服务器正常运行，系统调优</li>
<li>深入理解Linux，对内核有研究，掌握大型网站架构、熟悉各环节部署方法</li>
</ol>
<h2> 2.Linux介绍及安装</h2>
<h3> 2.1 Linux介绍</h3>
<ul>
<li>Linux 是一款免费，开源，安全，高效，稳定，处理高斌发很强悍的操作系统</li>
<li>Linux创始人——linux（林纳斯）</li>
<li>Linux主要发行版本</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/810e414ba869dd66f88b92a607e46ba32df68a10.jpg" alt="发行版本" tabindex="0" loading="lazy"><figcaption>发行版本</figcaption></figure>
<h3> 2.2 Unix与Linux的关系</h3>
<p><strong>Unix来源</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/3e6990c8adb641d8ec6d9a617fc0eb37ab505715.jpg" alt="unix来源" tabindex="0" loading="lazy"><figcaption>unix来源</figcaption></figure>
<p><strong>Linux来源</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/d46ae88ce01f8cc54b1775c7a10378cb3d8fed6e.jpg" alt="Linux来源" tabindex="0" loading="lazy"><figcaption>Linux来源</figcaption></figure>
<p><strong>Linux与Unix关系</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/dd8ce4f9ca7bebf60a2681d69d80bcee4db33279.jpg" alt="Linux与Unix关系" tabindex="0" loading="lazy"><figcaption>Linux与Unix关系</figcaption></figure>
<p><strong>Linux与Windows关系</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/9ce17216d979da5d1afacd8669750a3815b8d787.jpg" alt="Linux与Windows关系" tabindex="0" loading="lazy"><figcaption>Linux与Windows关系</figcaption></figure>
<h3> 2.3 CentOS的安装</h3>
<h4> 2.3.1 无脑安装vmware workstation</h4>
<img src="https://i0.hdslb.com/bfs/album/439efd46a01d9dc2f79669b4c4a655142b43b6df.png" alt="image-20211112085949513" style="zoom: 67%;">
<h4> 2.3.2 编辑vmware workstation 的虚拟网卡</h4>
<h5> 2.3.2.1 进行便捷的远程开发需要满足的两个条件</h5>
<figure><img src="https://i0.hdslb.com/bfs/album/8ec4fc0bd23e569c057782ccd3680dfab82d7ee2.png" alt="image-20211112090629524" tabindex="0" loading="lazy"><figcaption>image-20211112090629524</figcaption></figure>
<h5> 2.3.2.2 三种类型的网卡的含义</h5>
<p><strong>1) 桥接模式：虚拟机电脑在网络环境中的地位和宿主环境（开发电脑）是一样的，虚拟机可以上网，但是ip地址会变来变去，因为虚拟机的ip地址是由DHCP动态分配的</strong></p>
<p><strong>2) NAT模式：开发电脑（宿主环境）会通过虚拟网卡构建一个局域网，虚拟机电脑作为局域网中一个成员，由于局域网受开发电脑的控制，因此虚拟机电脑的ip地址可以是固定的，局域网中的成员（虚拟机）可以通过开发电脑（宿主环境）间接的连到外面的互联网</strong></p>
<p><strong>3）仅主机模式：虚拟机相当于黑户，完全和外界隔绝，因此不能上网</strong></p>
<figure><img src="https://i0.hdslb.com/bfs/album/49ac3fa86025844928494ca67958e16a83c2d607.png" alt="image-20211112092206452" tabindex="0" loading="lazy"><figcaption>image-20211112092206452</figcaption></figure>
<h5> 2.3.2.3 规划局域网</h5>
<h5> 网段         192.168.10.xx</h5>
<h5> 子网掩码  255.255.255.0</h5>
<h5> 网关         192.168.10.2</h5>
<h5> 2.3.2.4 编辑虚拟网卡（大家使用10的网段，而不是使用图片中的19网段）</h5>
<blockquote>
<p>大家使用10的网段，而不是使用图片中的19网段</p>
</blockquote>
<ol>
<li>以管理员身份打开vmware workstation</li>
</ol>
<figure><img src="https://i0.hdslb.com/bfs/album/55e14e9ccb1c9cc2f79bb77c23d05fe10e470f50.png" alt="image-20211112093605466" tabindex="0" loading="lazy"><figcaption>image-20211112093605466</figcaption></figure>
<ol start="2">
<li>打开VMware Workstation 编辑虚拟网卡</li>
<li>打开VMware Workstation 编辑虚拟网卡</li>
</ol>
<figure><img src="https://i0.hdslb.com/bfs/album/f0356e47a4d2a7d8a53b298b0125efaccda79bb4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="4">
<li>（做了第1步就不需要再做第3步）由于需要管理员权限才能修改网络配置，我们点击更改设置</li>
</ol>
<figure><img src="https://i0.hdslb.com/bfs/album/112a4c4e2c6e928a191f2df2e0869e1169ee06de.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="5">
<li>仅保留NAT模式的虚拟网卡，并参照图片完成设置</li>
</ol>
<figure><img src="https://i0.hdslb.com/bfs/album/dea824b77e46505f9f21da65e30a2617cd5f71f8.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="6">
<li>设置网关</li>
</ol>
<figure><img src="https://i0.hdslb.com/bfs/album/aa333ee41fb6258018130ab5c3721cb6c0b412c1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="7">
<li>点击确定生效</li>
</ol>
<figure><img src="https://i0.hdslb.com/bfs/album/d08e96203db9cedb7f70ad9a5ec371c77e330fa4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol start="8">
<li>直接使用windows查看虚拟网卡设置生效情况，如果没有正常生效的部分，需要我们手动修改，然后点击确定生效</li>
</ol>
<figure><img src="https://i0.hdslb.com/bfs/album/09851836beeb1a97cc6c4f93f9c31c9caa06f834.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h4> 2.3.3 安装centos的linux操作系统</h4>
<h5> 2.3.3.1  创建一个虚拟机（虚拟电脑）</h5>
<figure><img src="https://i0.hdslb.com/bfs/album/327bd63f00e7ea4cd0fc4702b07290d28b1a9998.png" alt="image-20211112101126528" tabindex="0" loading="lazy"><figcaption>image-20211112101126528</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/0e97c3b98bb8f16f9d28197228aa67d7bb322da1.png" alt="image-20211112101207152" tabindex="0" loading="lazy"><figcaption>image-20211112101207152</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/05c1e097d8a58ffa0718fd616b7b2b7ef80f4adb.png" alt="image-20211112101419743" tabindex="0" loading="lazy"><figcaption>image-20211112101419743</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/ec6bd1daafdd330d8170e41a5564dcc39cb2d514.png" alt="image-20211112101633715" tabindex="0" loading="lazy"><figcaption>image-20211112101633715</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/fb753f20a21ffaea28caa615a959f52a0050d757.png" alt="image-20211112101910920" tabindex="0" loading="lazy"><figcaption>image-20211112101910920</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/1450560a7fc552e7328d66f6dfc9b7f0e1d714d6.png" alt="image-20211112102039077" tabindex="0" loading="lazy"><figcaption>image-20211112102039077</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/2be2c87928f931e121fe073507ebc6d57038e948.png" alt="image-20211112102252690" tabindex="0" loading="lazy"><figcaption>image-20211112102252690</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/1db17867aca2be6b0ca891356c3a3f38a540c6eb.png" alt="image-20211112102338211" tabindex="0" loading="lazy"><figcaption>image-20211112102338211</figcaption></figure>
<h5> 2.3.3.2 在虚拟机上安装centos的操作系统</h5>
<figure><img src="https://i0.hdslb.com/bfs/album/cefa59adabbed2bfdb3c0d1101e5bf2611a16d74.png" alt="image-20211112102422321" tabindex="0" loading="lazy"><figcaption>image-20211112102422321</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/c11688ec2c99957d2c9b093e88a9ac15e9a8eef3.png" alt="image-20211112102523270" tabindex="0" loading="lazy"><figcaption>image-20211112102523270</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/f71ad0c435f08954acb8a7a76a59566d4e5aea54.png" alt="image-20211112102943673" tabindex="0" loading="lazy"><figcaption>image-20211112102943673</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/fd9b7d92cafa61c0b55568bd20ebbaa0e9b96c70.png" alt="image-20211112103018047" tabindex="0" loading="lazy"><figcaption>image-20211112103018047</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/80df58dff80c4bde862fd7a9b53b7250a43b38c3.png" alt="image-20211112103124685" tabindex="0" loading="lazy"><figcaption>image-20211112103124685</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/31167e2a0ca9b00f4e403bc93c473f858c53a5bb.png" alt="image-20211112103316020" tabindex="0" loading="lazy"><figcaption>image-20211112103316020</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/207a4689064acd44c452d351fa128c6913a7f940.png" alt="image-20211112103402101" tabindex="0" loading="lazy"><figcaption>image-20211112103402101</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/1031c8ca689bea9bc940b874f29ea6a97d942720.png" alt="image-20211112103428107" tabindex="0" loading="lazy"><figcaption>image-20211112103428107</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/dba8970f77a6334823236f5f93ddeaa89c035085.png" alt="image-20211112152234468" tabindex="0" loading="lazy"><figcaption>image-20211112152234468</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/7f4bd9b8c3f4372f53b0526c7d6a1e399d4d4902.png" alt="image-20211112103624114" tabindex="0" loading="lazy"><figcaption>image-20211112103624114</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/85a1f9c8023b7f7a952c1d346a5cafdfcc062150.png" alt="image-20211112103706278" tabindex="0" loading="lazy"><figcaption>image-20211112103706278</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/dc549197a1fed76ff0ceca28c88b26f9736046f9.png" alt="image-20211112103733703" tabindex="0" loading="lazy"><figcaption>image-20211112103733703</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/610ce3d9ba79d61662b2163ca2040444874812c3.png" alt="image-20211112104318911" tabindex="0" loading="lazy"><figcaption>image-20211112104318911</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/f8ba300fcfd03e9f5147392b6a258b83e1483b4b.png" alt="image-20211112104520575" tabindex="0" loading="lazy"><figcaption>image-20211112104520575</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/1efe220ba6fb8c0bd79187350964dbcc7be39217.png" alt="image-20211112104549330" tabindex="0" loading="lazy"><figcaption>image-20211112104549330</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/db41a79086008bfbfc183e73173e2599cfc0a3de.png" alt="image-20211112104611613" tabindex="0" loading="lazy"><figcaption>image-20211112104611613</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/8b887fbd050ea6598335b12d6e7b01d41a1f436e.png" alt="image-20211112105044673" tabindex="0" loading="lazy"><figcaption>image-20211112105044673</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/a4be3a272635f5aa0869cec1046b0d8f136d4866.png" alt="image-20211112105126584" tabindex="0" loading="lazy"><figcaption>image-20211112105126584</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/68e27a837c01d40e96d75c34ea10dc3166e0d3f4.png" alt="image-20211112104647373" tabindex="0" loading="lazy"><figcaption>image-20211112104647373</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/e71a1714c4866266136f123f9fd33b61602f53ed.png" alt="image-20211112110654155" tabindex="0" loading="lazy"><figcaption>image-20211112110654155</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/f1909a9859a12e23cd87e1c6278e4228a10a523a.png" alt="image-20211112111741098" tabindex="0" loading="lazy"><figcaption>image-20211112111741098</figcaption></figure>
<h2> 3.Linux基本目录机构</h2>
<h3> 3.1 基本介绍</h3>
<ul>
<li>Linux的文件系统采用级层式子的树状目录结构，</li>
<li>最上层是根目录“/”</li>
<li><strong>Linux世界里，一切皆文件。</strong>
<img src="https://i0.hdslb.com/bfs/album/9b6a7fb1fdb9796228fec46327ff0b69953ccaf0.jpg" alt="目录结构" loading="lazy"></li>
</ul>
<h3> 3.2 目录用途</h3>
<ul>
<li><code>/bin：</code> 是Binary的缩写，这个目录存放着最经常使用的命令。</li>
<li>/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><code>/home：</code>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
<li><code>/root：</code>该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li>/lib：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li>
<li>/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li>/etc：所有的系统管理所需要的配置文件和子目录my.conf。</li>
<li><code>/usr/local</code>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</li>
<li><code>/boot：</code>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</li>
<li>/srv：service的缩写，该目录存放一些服务启动之后需要提供的数据。</li>
<li>/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。</li>
<li>/tmp：这个目录是用来存放一些临时文件的。</li>
<li>/dev：类似windows的设备管理器，把所有的硬件用文件的形式存储。</li>
<li><code>/media：</code>linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li>
<li><code>/mnt：</code>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。</li>
<li><code>/opt：</code>这是给主机额外安装软件所摆放的目录，如安装ORACLE数据库就可放到该目录下。默认为空。</li>
<li>/usr/local：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</li>
<li><code>/var：</code>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</li>
<li>/selinux：SELinux是一种安全子系统，它能控制程序只能访问特定文件。</li>
</ul>
<h3> 3.3 总结</h3>
<ol>
<li>Linux的目录中有且只有一个根目录。</li>
<li>Linux的各个目录存放的内容是规划好，不用乱放文件。</li>
<li>Linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。</li>
<li>Linux的各个文件目录下存放什么内容，必须有一个认识。</li>
</ol>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-01-30T06:57:36.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">02 【基础篇-vim编辑器 网络配置 远程登录】</title>
    <id>https://blog.dselegent.cf/back_end/linux/02.html</id>
    <link href="https://blog.dselegent.cf/back_end/linux/02.html"/>
    <updated>2023-01-30T06:57:36.000Z</updated>
    <summary type="html"><![CDATA[<h1> 02 【基础篇-vim编辑器 网络配置 远程登录】</h1>
<h2> 1.vi和vim编辑器</h2>
<h3> 1.1 vi和vim的基本介绍</h3>
<ul>
<li>所有Linux系统都会内置vi文本编辑器</li>
<li>vim是vi的升级版，可以主动以字体颜色分辨语法的正确性，代码补完和编译，错误跳转等功能。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/a0196d78f8e7e4af8150fc199185b84c90fc644a.png" alt="image-20220815123840409" tabindex="0" loading="lazy"><figcaption>image-20220815123840409</figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<h1> 02 【基础篇-vim编辑器 网络配置 远程登录】</h1>
<h2> 1.vi和vim编辑器</h2>
<h3> 1.1 vi和vim的基本介绍</h3>
<ul>
<li>所有Linux系统都会内置vi文本编辑器</li>
<li>vim是vi的升级版，可以主动以字体颜色分辨语法的正确性，代码补完和编译，错误跳转等功能。</li>
</ul>
<figure><img src="https://i0.hdslb.com/bfs/album/a0196d78f8e7e4af8150fc199185b84c90fc644a.png" alt="image-20220815123840409" tabindex="0" loading="lazy"><figcaption>image-20220815123840409</figcaption></figure>
<h3> 1.2 vi和vim的三种模式</h3>
<p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p>
<h4> 1.2.1 正常模式</h4>
<ul>
<li>
<p>用户刚刚启动 vi/vim，便进入了正常模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li><strong>i</strong> 切换到输入模式，以输入字符。</li>
<li><strong>x</strong> 删除当前光标所在处的字符。</li>
<li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li>
</ul>
</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<h4> 1.2.2 插入/编辑模式</h4>
<ul>
<li>
<p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li>
<li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li>
<li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
</li>
</ul>
<h4> 1.2.3 命令行模式</h4>
<ul>
<li>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
</li>
</ul>
<h4> 1.2.4 三种模式转换示意图</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/be02de7ca3ef734ffc094598a07193a7ddc56b7a.jpg" alt="3.2vim模式转换.jpg" tabindex="0" loading="lazy"><figcaption>3.2vim模式转换.jpg</figcaption></figure>
<h3> 1.3 vi/vim 使用实例</h3>
<p><strong>使用 vi/vim 进入一般模式</strong></p>
<p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p>
<figure><img src="https://i0.hdslb.com/bfs/album/6e4689bed198cb377cd7341650f9927ae4002295.png" alt="image-20220815124239030" tabindex="0" loading="lazy"><figcaption>image-20220815124239030</figcaption></figure>
<p><strong>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</strong></p>
<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/cdfc99dc399b6fc3b0e83a6280eb816535e64ed7.png" alt="image-20220815124308987" tabindex="0" loading="lazy"><figcaption>image-20220815124308987</figcaption></figure>
<p><strong>按下 ESC 按钮回到一般模式</strong></p>
<p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<p><strong>在一般模式中按下 :wq 储存后离开 vi</strong></p>
<p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p>
<h3> 1.4 Vim 按键说明</h3>
<p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<h4> 1.4.1 一般模式的光标移动、搜索替换、复制粘贴</h4>
<table>
<thead>
<tr>
<th style="text-align:left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><mark>h 或 向左箭头键(←)</mark></td>
<td><mark>光标向左移动一个字符</mark></td>
</tr>
<tr>
<td style="text-align:left"><mark>j 或 向下箭头键(↓)</mark></td>
<td><mark>光标向下移动一个字符</mark></td>
</tr>
<tr>
<td style="text-align:left"><mark>k 或 向上箭头键(↑)</mark></td>
<td><mark>光标向上移动一个字符</mark></td>
</tr>
<tr>
<td style="text-align:left"><mark>l 或 向右箭头键(→)</mark></td>
<td><mark>光标向右移动一个字符</mark></td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td style="text-align:left"><mark><code>n&lt;space&gt;</code></mark></td>
<td><mark>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 <code>20&lt;space&gt;</code> 则光标会向后面移动 20 个字符距离。</mark></td>
</tr>
<tr>
<td style="text-align:left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td style="text-align:left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td style="text-align:left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td style="text-align:left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td style="text-align:left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td style="text-align:left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td>
</tr>
<tr>
<td style="text-align:left"><mark><code>n&lt;Enter&gt;</code></mark></td>
<td><mark>n 为数字。光标向下移动 n 行(常用)</mark></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">搜索</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><mark>/word</mark></td>
<td><mark>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</mark></td>
</tr>
<tr>
<td style="text-align:left">`?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td style="text-align:left">/^abc</td>
<td>查找以 abc 为行首的行</td>
</tr>
<tr>
<td style="text-align:left">/abc$</td>
<td>查找以 abc 为行尾的行</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td><mark>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</mark></td>
</tr>
<tr>
<td style="text-align:left"><mark>N</mark></td>
<td><mark>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</mark></td>
</tr>
</tbody>
</table>
<p>在查找过程中需要注意的是，要查找的字符串是严格区分大小写的，如查找 "shenchao" 和 "ShenChao" 会得到不同的结果。</p>
<p>如果想忽略大小写，则输入命令 ":set ic"；调整回来输入":set noic"。</p>
<p>如果在字符串中出现特殊符号，则需要加上转义字符 ""。常见的特殊符号有 \、*、?、$ 等。如果出现这些字符，例如，要查找字符串 "10$"，则需要在命令模式中输入 "/10$"。</p>
<table>
<thead>
<tr>
<th>替换文本</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>替换光标所在位置的字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束</td>
</tr>
<tr>
<td>😒/a1/a2/g</td>
<td>将当前光标所在行中的所有 a1 用 a2 替换</td>
</tr>
<tr>
<td>:n1,n2s/a1/a2/g</td>
<td>将文件中 n1 到 n2 行中所有 a1 都用 a2 替换</td>
</tr>
<tr>
<td>:g/a1/a2/g</td>
<td>将文件中所有的 a1 都用 a2 替换例如，要将某文件中所有的 "root" 替换为 "liudehua"，则有两种输入命令，分别为：</td>
</tr>
</tbody>
</table>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述命令是在编辑模式下操作的，表示的是从第一行到最后一行，即全文查找 "root"，然后替换成 "liudehua"。</p>
<p>如果刚才的命令变成 <code>:10,20 s/root/liudehua/g</code>，则只替换从第 10 行到第 20 行的 "root"。</p>
<table>
<thead>
<tr>
<th>复制粘贴</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>将剪贴板中的内容粘贴到光标后</td>
</tr>
<tr>
<td>P（大写）</td>
<td>将剪贴板中的内容粘贴到光标前</td>
</tr>
<tr>
<td>y</td>
<td>复制已选中的文本到剪贴板</td>
</tr>
<tr>
<td>yy</td>
<td>将光标所在行复制到剪贴板，此命令前可以加数字 n，可复制多行</td>
</tr>
<tr>
<td>yw</td>
<td>将光标位置的单词复制到剪贴板</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>删除文本</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除光标所在位置的字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在行</td>
</tr>
<tr>
<td>ndd</td>
<td>删除当前行（包括此行）后 n 行文本</td>
</tr>
<tr>
<td>dG</td>
<td>删除光标所在行一直到文件末尾的所有内容</td>
</tr>
<tr>
<td>D</td>
<td>删除光标位置到行尾的内容</td>
</tr>
<tr>
<td>:a1,a2d</td>
<td>函数从 a1 行到 a2 行的文本内容</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意，被删除的内容并没有真正删除，都放在了剪贴板中。将光标移动到指定位置处，按下 "p" 键，就可以将刚才删除的内容又粘贴到此处。</p>
</blockquote>
<h4> 1.4.2 一般模式切换到编辑模式</h4>
<table>
<thead>
<tr>
<th style="text-align:left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><mark>i, I</mark></td>
<td><mark>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</mark></td>
</tr>
<tr>
<td style="text-align:left">a, A</td>
<td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td style="text-align:left">o, O</td>
<td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td>
</tr>
<tr>
<td style="text-align:left">r, R</td>
<td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td style="text-align:left"><mark>[Esc]</mark></td>
<td><mark>退出编辑模式，回到一般模式中(常用)</mark></td>
</tr>
</tbody>
</table>
<h4> 1.4.3 一般模式切换到指令行模式</h4>
<table>
<thead>
<tr>
<th style="text-align:left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><mark>:w</mark></td>
<td><mark>将编辑的数据写入硬盘档案中(常用)</mark></td>
</tr>
<tr>
<td style="text-align:left"><mark>:w!</mark></td>
<td><mark>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</mark></td>
</tr>
<tr>
<td style="text-align:left"><mark>:q</mark></td>
<td><mark>离开 vi (常用)</mark></td>
</tr>
<tr>
<td style="text-align:left"><mark>:q!</mark></td>
<td><mark>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</mark></td>
</tr>
<tr>
<td style="text-align:left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><mark>:wq</mark></td>
<td><mark>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</mark></td>
</tr>
<tr>
<td style="text-align:left"><mark>ZZ</mark></td>
<td><mark>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</mark></td>
</tr>
<tr>
<td style="text-align:left">ZQ</td>
<td>不保存，强制退出。效果等同于 <strong>:q!</strong>。</td>
</tr>
<tr>
<td style="text-align:left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td style="text-align:left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td style="text-align:left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td style="text-align:left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">vim 环境的变更</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><mark>:set nu</mark></td>
<td><mark>显示行号，设定之后，会在每一行的前缀显示该行的行号</mark></td>
</tr>
<tr>
<td style="text-align:left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody>
</table>
<h3> 1.5 总结Vim 的常见指令</h3>
<p><strong>必须掌握</strong></p>
<ol>
<li>yy：复制光标当前一行</li>
<li>5yy：拷贝当前5行</li>
<li>p：箭头移动到目的行粘贴</li>
<li>u：撤销上一步</li>
<li>dd：删除当前行</li>
<li>5dd：删除当前行向下的5行</li>
<li>x：剪切一个字母，相当于del</li>
<li>X：剪切一个字母，相当于退格键</li>
<li>yw：复制一个词</li>
<li>dw：删除一个词</li>
<li>在文件中查找某个单词：命令行输入 /（查找内容），按n查找下一个</li>
<li>设置文件行号：set nu，取消文件行号：set nonu</li>
<li>编辑文件，正常模式下使用快捷键到达文档最末行：G，最首行：gg</li>
<li>编辑文件，光标移动到某行：shift+g
<ul>
<li>显示行号：set nu</li>
<li>输入行号这个数</li>
<li>输入shift+g</li>
</ul>
</li>
<li>w：向前移动一个单词（光标停在单词首部）</li>
<li>b：向后移动一个单词 2b 向后移动2个单词</li>
</ol>
<p><strong>插入命令</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>在当前位置生前插入</td>
</tr>
<tr>
<td>I</td>
<td>在当前行首插入</td>
</tr>
<tr>
<td>a</td>
<td>在当前位置后插入</td>
</tr>
<tr>
<td>A</td>
<td>在当前行尾插入</td>
</tr>
<tr>
<td>o</td>
<td>在当前行之后插入一行</td>
</tr>
<tr>
<td>O</td>
<td>在当前行之前插入一行</td>
</tr>
</tbody>
</table>
<p><strong>游标移动</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>gg</td>
<td>移动到文件头。 = [[</td>
</tr>
<tr>
<td>G（shift + g）</td>
<td>移动到文件尾。 = ]]</td>
</tr>
<tr>
<td>行數 → G</td>
<td>移動到第 n 行</td>
</tr>
<tr>
<td>冒号+行号，回车</td>
<td>比如跳到240行就是 :240回车</td>
</tr>
<tr>
<td>h</td>
<td>左移一个字符</td>
</tr>
<tr>
<td>l</td>
<td>右移一个字符，这个命令很少用，一般用w代替。</td>
</tr>
<tr>
<td>k</td>
<td>上移一个字符</td>
</tr>
<tr>
<td>j</td>
<td>下移一个字符</td>
</tr>
<tr>
<td>w</td>
<td>向前移动一个单词（光标停在单词首部）</td>
</tr>
<tr>
<td>b</td>
<td>向后移动一个单词 2b 向后移动2个单词</td>
</tr>
<tr>
<td>e</td>
<td>同w，只不过是光标停在单词尾部</td>
</tr>
<tr>
<td>ge</td>
<td>同b，光标停在单词尾部。</td>
</tr>
<tr>
<td>^</td>
<td>移动到本行第一个非空白字符上。</td>
</tr>
<tr>
<td>0</td>
<td>移动到本行第一个字符上</td>
</tr>
<tr>
<td>HOME</td>
<td>移动到本行第一个字符。同0健。</td>
</tr>
<tr>
<td>$</td>
<td>移动到行尾 3$ 移动到下面3行的行尾</td>
</tr>
<tr>
<td>f（find）</td>
<td>fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</td>
</tr>
<tr>
<td>F</td>
<td>同f，反向查找</td>
</tr>
</tbody>
</table>
<p><strong>撤销和重做</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>撤销（Undo）</td>
</tr>
<tr>
<td>U</td>
<td>撤销对整行的操作</td>
</tr>
<tr>
<td>Ctrl + r</td>
<td>重做（Redo），即撤销的撤销。</td>
</tr>
</tbody>
</table>
<p><strong>删除命令</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>删除当前字符</td>
</tr>
<tr>
<td>3x</td>
<td>删除当前光标开始向后三个字符</td>
</tr>
<tr>
<td>X</td>
<td>删除当前字符的前一个字符。X=dh</td>
</tr>
<tr>
<td>dl</td>
<td>删除当前字符， dl=x</td>
</tr>
<tr>
<td>dh</td>
<td>删除前一个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行</td>
</tr>
<tr>
<td>dj</td>
<td>删除上一行</td>
</tr>
<tr>
<td>dk</td>
<td>删除下一行</td>
</tr>
<tr>
<td>10d</td>
<td>删除当前行开始的10行。</td>
</tr>
<tr>
<td>D</td>
<td>删除当前字符至行尾。D=d$</td>
</tr>
<tr>
<td>d$</td>
<td>删除当前字符之后的所有字符（本行）</td>
</tr>
<tr>
<td>kdgg</td>
<td>删除当前行之前所有行（不包括当前行）</td>
</tr>
<tr>
<td>jdG（jd shift + g）</td>
<td>删除当前行之后所有行（不包括当前行）</td>
</tr>
<tr>
<td>:1,10d</td>
<td>删除1-10行</td>
</tr>
<tr>
<td>:11,$d</td>
<td>删除11行及以后所有的行</td>
</tr>
<tr>
<td>:1,$d</td>
<td>删除所有行</td>
</tr>
<tr>
<td>J(shift + j)</td>
<td>删除两行之间的空行，实际上是合并两行。</td>
</tr>
</tbody>
</table>
<p><strong>拷贝，剪贴和粘贴</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>yy</td>
<td>拷贝当前行</td>
</tr>
<tr>
<td>nyy</td>
<td>拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</td>
</tr>
<tr>
<td>p</td>
<td>在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</td>
</tr>
<tr>
<td>shift+p</td>
<td>在当前行前粘贴</td>
</tr>
<tr>
<td>:1,10 co 20</td>
<td>将1-10行插入到第20行之后。</td>
</tr>
<tr>
<td>:1,$ co $</td>
<td>将整个文件复制一份并添加到文件尾部。</td>
</tr>
<tr>
<td>ddp</td>
<td>交换当前行和其下一行</td>
</tr>
<tr>
<td>xp</td>
<td>交换当前字符和其后一个字符</td>
</tr>
<tr>
<td>ndd</td>
<td>剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</td>
</tr>
<tr>
<td>:1,10d</td>
<td>将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</td>
</tr>
<tr>
<td>:1, 10 m 20</td>
<td>将第1-10行移动到第20行之后。</td>
</tr>
</tbody>
</table>
<p>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</p>
<p><strong>退出命令</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td>ZZ</td>
<td>保存并退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出并忽略所有更改</td>
</tr>
<tr>
<td>:e!</td>
<td>放弃所有修改，并打开原来文件。</td>
</tr>
<tr>
<td>:q</td>
<td>未修改直接退出</td>
</tr>
</tbody>
</table>
<h2> 2.网络配置</h2>
<h3> 2.1 三种网络模式详解</h3>
<p>vmware为我们提供了三种网络工作模式，它们分别是：<strong>Bridged（桥接模式）</strong>、<strong>NAT（网络地址转换模式）</strong>、<strong>Host-Only（仅主机模式）</strong>。</p>
<p>打开vmware虚拟机，我们可以在选项栏的“编辑”下的“虚拟网络编辑器”中看到VMnet0（桥接模式）、VMnet1（仅主机模式）、VMnet8（NAT模式），那么这些都是有什么作用呢？其实，我们现在看到的VMnet0表示的是用于桥接模式下的虚拟交换机；VMnet1表示的是用于仅主机模式下的虚拟交换机；VMnet8表示的是用于NAT模式下的虚拟交换机。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/ee24cee5cdad25bb2a992ba665553b822473b126.png" alt="image-20220815195704711" tabindex="0" loading="lazy"><figcaption>image-20220815195704711</figcaption></figure>
<p>同时，在主机上对应的有VMware Network Adapter VMnet1和VMware Network Adapter VMnet8两块虚拟网卡，它们分别作用于仅主机模式与NAT模式下。在“网络连接”中我们可以看到这两块虚拟网卡，如果将这两块卸载了，可以在vmware的“编辑”下的“虚拟网络编辑器”中点击“还原默认设置”，可重新将虚拟网卡还原。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/3244dc5ef61faac2bfee5a5940d7a4883718fcf6.png" alt="image-20220815195743297" tabindex="0" loading="lazy"><figcaption>image-20220815195743297</figcaption></figure>
<p>小伙伴看到这里，肯定有疑问，为什么在真机上没有VMware Network Adapter VMnet0虚拟网卡呢？那么接下来，我们就一起来看一下这是为什么。</p>
<h4> 2.1.1 Bridged（桥接模式）</h4>
<p>什么是桥接模式？桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关DNS需要与主机网卡一致。其网络结构如下图所示：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/da53965814800fc4c6ed509d342a98c92ebaf73f.png" alt="image-20220815195824917" tabindex="0" loading="lazy"><figcaption>image-20220815195824917</figcaption></figure>
<p>点击“网络适配器”，选择“桥接模式”，然后“确定”</p>
<figure><img src="https://i0.hdslb.com/bfs/album/bbf1feb660af180fbc6758834b276e4a757c2a16.png" alt="image-20220815195911118" tabindex="0" loading="lazy"><figcaption>image-20220815195911118</figcaption></figure>
<p>在进入系统之前，我们先确认一下主机的ip地址、网关、DNS等信息。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/12ea5f96f660c11d2949098d8c7f7af7af0e281e.png" alt="image-20220815195920630" tabindex="0" loading="lazy"><figcaption>image-20220815195920630</figcaption></figure>
<p>然后，进入系统编辑网卡配置文件，在终端输入命令<code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code></p>
<p>添加内容如下：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/feecd44f3a8c421c6340e1bc9b07467b36a5be64.png" alt="image-20220815200013770" tabindex="0" loading="lazy"><figcaption>image-20220815200013770</figcaption></figure>
<p>编辑完成，保存退出，然后重启虚拟机网卡，使用ping命令ping外网ip，测试能否联网。</p>
<blockquote>
<p>基本语法: ping [主机地址]</p>
<p>例如： ping <a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">www.baidu.com</a></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/f82d7bd3be7abb5b18cba1d35570023ba9e259e4.png" alt="image-20220815200027788" tabindex="0" loading="lazy"><figcaption>image-20220815200027788</figcaption></figure>
<p>能ping通外网ip，证明桥接模式设置成功。</p>
<p>能ping通外网ip，证明桥接模式设置成功。</p>
<p>那主机与虚拟机之间的通信是否正常呢？我们就用远程工具来测试一下。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/3a720a028a54a7d98aaff5f55799aef20d59b671.png" alt="image-20220815200102291" tabindex="0" loading="lazy"><figcaption>image-20220815200102291</figcaption></figure>
<p>主机与虚拟机通信正常。</p>
<p>这就是桥接模式的设置步骤，相信大家应该学会了如何去设置桥接模式了。桥接模式配置简单，但如果你的网络环境是ip资源很缺少或对ip管理比较严格的话，那桥接模式就不太适用了。这时，我们就来认识vmware的另一种网络模式：NAT模式。</p>
<h4> 2.1.2 NAT（地址转换模式）</h4>
<p>如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。其网络结构如下图所示：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/e9688aa206ae1003042fe5256a25497b91c05c05.png" alt="image-20220815200210830" tabindex="0" loading="lazy"><figcaption>image-20220815200210830</figcaption></figure>
<p>在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。那么我们会觉得很奇怪，为什么需要虚拟网卡VMware Network Adapter VMnet8呢？原来我们的VMware Network Adapter VMnet8虚拟网卡主要是为了实现主机与虚拟机之间的通信。在之后的设置步骤中，我们可以加以验证。</p>
<p>首先，设置虚拟机中NAT模式的选项，打开vmware，点击“编辑”下的“虚拟网络编辑器”，设置NAT参数及DHCP参数。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d62e2bb3d5a15dc2dbca6d594b875cd1b62bd5e0.png" alt="image-20220815200228608" tabindex="0" loading="lazy"><figcaption>image-20220815200228608</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/19e5972a9d9e6f888cf7f7997add7ecb5c989d22.png" alt="image-20220815200238861" tabindex="0" loading="lazy"><figcaption>image-20220815200238861</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/a9468789e50fe61d80e12ee4a1cb73855533c1fc.png" alt="image-20220815200259125" tabindex="0" loading="lazy"><figcaption>image-20220815200259125</figcaption></figure>
<p>将虚拟机的网络连接模式修改成NAT模式。</p>
<p>点击“网络适配器”，选择“NAT模式”</p>
<figure><img src="https://i0.hdslb.com/bfs/album/980fb0a5071db9d1bf88cb672f7cd7d414423d98.png" alt="image-20220815200327743" tabindex="0" loading="lazy"><figcaption>image-20220815200327743</figcaption></figure>
<p>然后开机启动系统，编辑网卡配置文件，在终端输入命令<code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code></p>
<p>具体配置如下：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/72bd28d00d8b752da7078c509706c890d3d6d859.png" alt="image-20220815200401415" tabindex="0" loading="lazy"><figcaption>image-20220815200401415</figcaption></figure>
<p>编辑完成，保存退出，然后重启虚拟机网卡，动态获取ip地址，使用ping命令ping外网ip，测试能否联网。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/5ae0c3d927dc8b5ad61e6ae06483f728f295c7a9.png" alt="image-20220815200410949" tabindex="0" loading="lazy"><figcaption>image-20220815200410949</figcaption></figure>
<p>之前，我们说过VMware Network Adapter VMnet8虚拟网卡的作用，那我们现在就来测试一下。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/b9b4a398da088d5ae0f99344ab197a184b9e4b97.png" alt="image-20220815200426008" tabindex="0" loading="lazy"><figcaption>image-20220815200426008</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/c4d4d256a74d094167a1605c5c506950b864920e.png" alt="image-20220815200435870" tabindex="0" loading="lazy"><figcaption>image-20220815200435870</figcaption></figure>
<p>如此看来，虚拟机能联通外网，确实不是通过VMware Network Adapter VMnet8虚拟网卡，那么为什么要有这块虚拟网卡呢？</p>
<p>之前我们就说VMware Network Adapter VMnet8的作用是主机与虚拟机之间的通信，接下来，我们就用远程连接工具来测试一下。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/f9c0ef7cd879419b3f4147040ee600336aa4d59d.png" alt="image-20220815200451232" tabindex="0" loading="lazy"><figcaption>image-20220815200451232</figcaption></figure>
<p>然后，将VMware Network Adapter VMnet8启用之后，发现远程工具可以连接上虚拟机了。</p>
<p>那么，这就是NAT模式，利用虚拟的NAT设备以及虚拟DHCP服务器来使虚拟机连接外网，而VMware Network Adapter VMnet8虚拟网卡是用来与虚拟机通信的。</p>
<h4> 2.1.3 Host-Only（仅主机模式）</h4>
<p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。其网络结构如下图所示：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/9112bf9968122839aabf8048a0ea86cca6cb333f.png" alt="image-20220815200523595" tabindex="0" loading="lazy"><figcaption>image-20220815200523595</figcaption></figure>
<p>通过上图，我们可以发现，如果要使得虚拟机能联网，我们可以将主机网卡共享给VMware Network Adapter VMnet1网卡，从而达到虚拟机联网的目的。接下来，我们就来测试一下。</p>
<p>首先设置“虚拟网络编辑器”，可以设置DHCP的起始范围。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/fbee609ea8624fb198bf20ff154b959e92303bd2.png" alt="image-20220815200545448" tabindex="0" loading="lazy"><figcaption>image-20220815200545448</figcaption></figure>
<p>设置虚拟机为Host-Only模式。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/6e25cf1fcebd6c40f3b0fa5938b1df63caccaf43.png" alt="image-20220815200602718" tabindex="0" loading="lazy"><figcaption>image-20220815200602718</figcaption></figure>
<p>开机启动系统，然后设置网卡文件。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/c64bde49346573bd5fc768b9196f0d03d11c75b5.png" alt="image-20220815200612317" tabindex="0" loading="lazy"><figcaption>image-20220815200612317</figcaption></figure>
<p>保存退出，然后重启网卡，利用远程工具测试能否与主机通信。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/5be5c99244429c5375411d5165ba9ae583d3cc41.png" alt="image-20220815200622408" tabindex="0" loading="lazy"><figcaption>image-20220815200622408</figcaption></figure>
<p>主机与虚拟机之间可以通信，现在设置虚拟机联通外网。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/bfd966fe4c9a9904684a1c02155a864590fe2df9.png" alt="image-20220815200634892" tabindex="0" loading="lazy"><figcaption>image-20220815200634892</figcaption></figure>
<p>我们可以看到上图有一个提示，强制将VMware Network Adapter VMnet1的ip设置成192.168.137.1，那么接下来，我们就要将虚拟机的DHCP的子网和起始地址进行修改，点击“虚拟网络编辑器”</p>
<figure><img src="https://i0.hdslb.com/bfs/album/26af0bbe03bc68d3fc8e56d25bedfe3b36b90820.png" alt="image-20220815200653975" tabindex="0" loading="lazy"><figcaption>image-20220815200653975</figcaption></figure>
<p>重新配置网卡，将VMware Network Adapter VMnet1虚拟网卡作为虚拟机的路由。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/4a2332b3944ce97b635ee3c4d71d43bd1e1cc191.png" alt="image-20220815200721717" tabindex="0" loading="lazy"><figcaption>image-20220815200721717</figcaption></figure>
<p>重启网卡，然后通过 远程工具测试能否联通外网以及与主机通信。</p>
<figure><img src="https://i0.hdslb.com/bfs/album/511329168b2bac89e79940628e20a0b5f48db59f.png" alt="image-20220815200752317" tabindex="0" loading="lazy"><figcaption>image-20220815200752317</figcaption></figure>
<p>测试结果证明可以使得虚拟机连接外网。</p>
<h3> 2.2 查看网络 IP 和 网关</h3>
<p>1）查看虚拟网络编辑器</p>
<figure><img src="https://i0.hdslb.com/bfs/album/29862c5ca010e080847f2d3a5903178d888487c6.png" alt="image-20220815201209483" tabindex="0" loading="lazy"><figcaption>image-20220815201209483</figcaption></figure>
<p>2）修改虚拟网卡 Ip</p>
<figure><img src="https://i0.hdslb.com/bfs/album/4ef964e9fa39db2a76e44431fa75098ede6b9423.png" alt="image-20220815204412976" tabindex="0" loading="lazy"><figcaption>image-20220815204412976</figcaption></figure>
<p>3）查看网关</p>
<figure><img src="https://i0.hdslb.com/bfs/album/20163e57c1c6b82448af52cc1ff6c536f4a60052.png" alt="image-20220815204439960" tabindex="0" loading="lazy"><figcaption>image-20220815204439960</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/ab2b830cd96bb69e9f86fef52dec08e9e1654fba.png" alt="image-20220815204455124" tabindex="0" loading="lazy"><figcaption>image-20220815204455124</figcaption></figure>
<p>4）查看 windows 环境的中 VMnet8 网络配置</p>
<figure><img src="https://i0.hdslb.com/bfs/album/a3a76ec9a2880387198da9a307fdd4845abd1948.png" alt="image-20220815204605529" tabindex="0" loading="lazy"><figcaption>image-20220815204605529</figcaption></figure>
<h3> 2.3 配置网络 ip 地址</h3>
<h4> 2.3.1 自动抓取</h4>
<figure><img src="https://i0.hdslb.com/bfs/album/1dd45ae232ec2f3bc35b8cc2fda3ef8e708aa8c9.png" alt="image-20220815204635593" tabindex="0" loading="lazy"><figcaption>image-20220815204635593</figcaption></figure>
<p><strong><code>缺点：</code></strong> 每次自动获取的ip地址可能不一样，不适用于做服务器</p>
<h4> 2.3.2 指定ip地址</h4>
<p><code>ifconfig</code> 查看当前网络配置</p>
<blockquote>
<p>BOOTPROTO="static" #IP 的配置方法[none|static|bootp|dhcp]（引导 时不 使用协议|静态分配 IP|BOOTP 协议|DHCP 协议）</p>
<p>ONBOOT="yes" #系统启动的时候网络接口是否有效（yes/no）</p>
<p>#IP 地址
IPADDR=192.168.2.100 #网段必须符合要求，后面的主机地址自己设置
#网关
GATEWAY=192.168.2.2 #网关要和vm8虚拟交换机网关一样
#域名解析器
DNS1=192.168.2.2  #这个设置成和网关一样就行</p>
<p>子网掩码默认255.255.255.0</p>
</blockquote>
<p>直接修改配置文件来指定IP，并可以连接到外网，编辑：vim /etc/sysconfig/network-scripts/ifcfg-ens160</p>
<blockquote>
<p>centos7是ifcfg-ens33</p>
</blockquote>
<p><img src="https://i0.hdslb.com/bfs/album/a414c7903674fcdaf58a3f3e8ab13725f9a4b2ae.png" alt="image-20220815204909611" loading="lazy"><img src="https://i0.hdslb.com/bfs/album/46b13351b7f4804b7dd921392fe0114aedd6685d.png" alt="image-20220815204852826" loading="lazy"></p>
<p>重启网络服务：service network restart</p>
<blockquote>
<p>centos8重启网卡的方法</p>
<p>1.重启⽹卡之前⼀定要重新载⼊⼀下配置⽂件，不然不能⽴即⽣效</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2.重启⽹卡（下⾯的三条命令都可以）：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote>
<h3> 2.3 修改 IP 地址后可能会遇到的问题</h3>
<p>（1）物理机能 ping 通虚拟机，但是虚拟机 ping 不通物理机,一般都是因为物理机的 防火墙问题,把防火墙关闭就行 （</p>
<p>（2）虚拟机能 Ping 通物理机,但是虚拟机 Ping 不通外网,一般都是因为 DNS 的设置有 问题</p>
<p>（3）虚拟机 Ping <a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">www.baidu.com</a> 显示域名未知等信息,一般查看 GATEWAY 和 DNS 设 置是否正确</p>
<p>（4）如果以上全部设置完还是不行，需要关闭 NetworkManager 服务</p>
<blockquote>
<ul>
<li>systemctl stop NetworkManager 关闭</li>
<li>systemctl disable NetworkManager 禁用</li>
</ul>
</blockquote>
<p>（5）如果检查发现 systemctl status network 有问题 需要检查 ifcfg-ens160</p>
<h3> 2.4 配置主机名</h3>
<p><strong>修改主机名称</strong></p>
<p><code>hostname</code> （功能描述：查看当前服务器的主机名称）</p>
<p>如果感觉此主机名不合适，我们可以进行修改。通过编辑<code>vim /etc/hostname</code> 文文件</p>
<p>修改完成后重启生效。</p>
<blockquote>
<p>如果想立即生效可以通过<code>hostnamectl set-hostname dselegent-study【要修改的主机名】</code>这个命令，然后重启终端就可以看到效果了</p>
</blockquote>
<p><strong>修改 hosts 映射文件</strong></p>
<p>1）修改 linux 的主机映射文件（hosts 文件） 后续在 hadoop 阶段，虚拟机会比较多，配置时通常会采用主机名的方式配置， 比较简单方便。 不用刻意记 ip 地址。<code>vim /etc/host</code></p>
<p>添加如下内容</p>
<div class="language-tex line-numbers-mode" data-ext="tex"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启设备，重启后，查看主机名，已经修改成功</p>
<p>2）修改 windows 的主机映射文件（hosts 文件）</p>
<p>​	进入 <code>C:\Windows\System32\drivers\etc</code> 路径</p>
<p>​	打开 hosts 文件并添加如下内容</p>
<div class="language-tex line-numbers-mode" data-ext="tex"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>先将该文件只读关闭，然后写入内容保存，最后恢复到只读状态</p>
</blockquote>
<p>这时可以在windows通过<code>ping ds100</code>来测试是否连通虚拟机</p>
<h2> 3.远程登录</h2>
<p>通常在工作过程中，公司中使用的真实服务器或者是云服务器，都不允许除运维人员之 外的员工直接接触，因此就需要通过远程登录的方式来操作。所以，远程登录工具就是必不 可缺的，目前，比较主流的有 Xshell，SSH Secure Shell，SecureCRT，FinalShell 等，同学们 可以根据自己的习惯自行选择，以下以 Xshell5 为例。</p>
<h3> 3.1 远程登录方法</h3>
<blockquote>
<p>两个文件的安装步骤都在01文章中的<code>2.3centos安装</code>下的网盘链接中</p>
</blockquote>
<p><strong>配置 Xshell 终端</strong></p>
<p>1）打开安装好的 Xshell</p>
<figure><img src="https://i0.hdslb.com/bfs/album/8799ba5a5c1af42a2035903f81415919331e9c3b.png" alt="image-20220816142329675" tabindex="0" loading="lazy"><figcaption>image-20220816142329675</figcaption></figure>
<p>2） 编辑新链接</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d4c918530216bbab5bba6a4371a5f586a9108f29.png" alt="image-20220816142358241" tabindex="0" loading="lazy"><figcaption>image-20220816142358241</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/acac2d2e7ba90c6fb72d9e35acdc249d80e90720.png" alt="image-20220816142412603" tabindex="0" loading="lazy"><figcaption>image-20220816142412603</figcaption></figure>
<p>3）测试链接</p>
<figure><img src="https://i0.hdslb.com/bfs/album/0bfe335ebe98c8982111d6eb38edd560be4b673c.png" alt="image-20220816142430521" tabindex="0" loading="lazy"><figcaption>image-20220816142430521</figcaption></figure>
<p>4）连接成功</p>
<figure><img src="https://i0.hdslb.com/bfs/album/7d08f6bb4ef68e360b5476a27a087571e7f9d894.png" alt="image-20220816142441896" tabindex="0" loading="lazy"><figcaption>image-20220816142441896</figcaption></figure>
<p>5）断开连接</p>
<figure><img src="https://i0.hdslb.com/bfs/album/77b167490a8cdbf0f531d99ecc0758f677963a8b.png" alt="image-20220816142541451" tabindex="0" loading="lazy"><figcaption>image-20220816142541451</figcaption></figure>
<p>6）添加右键点击粘贴和选中复制</p>
<p><code>工具 -&gt; 选项</code></p>
<figure><img src="https://i0.hdslb.com/bfs/album/28158d380acad7463c82ac2037f31ea97057c649.png" alt="image-20220816142850894" tabindex="0" loading="lazy"><figcaption>image-20220816142850894</figcaption></figure>
<figure><img src="https://i0.hdslb.com/bfs/album/ce6971bffebe4a0db5901c765ab182a61cf0bce8.png" alt="image-20220816142931574" tabindex="0" loading="lazy"><figcaption>image-20220816142931574</figcaption></figure>
<h3> 3.2 ftp文件传输</h3>
<blockquote>
<p>主要用于向服务上传或下载文件</p>
</blockquote>
<p><strong>配置 Xftp</strong></p>
<p>1）创建新链接</p>
<figure><img src="https://i0.hdslb.com/bfs/album/8ad9550dc1d1cb181f1a5546d357bb2dc3ac14dd.png" alt="image-20220816143139643" tabindex="0" loading="lazy"><figcaption>image-20220816143139643</figcaption></figure>
<p>2）编辑新链接</p>
<figure><img src="https://i0.hdslb.com/bfs/album/1ec1f5d4049e4290ae9110fc0b2390e99d3f38f3.png" alt="image-20220816143220540" tabindex="0" loading="lazy"><figcaption>image-20220816143220540</figcaption></figure>
<blockquote>
<p>如果配置hosts，主机可以填和名称一样的</p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/cf14f548fc511fa35b3823e7fba82aa91dd4d7b8.png" alt="image-20220816143307410" tabindex="0" loading="lazy"><figcaption>image-20220816143307410</figcaption></figure>
<p>出现以上界面表示链接成功，可以进行 windows 和 linux 系统互传数据。</p>
<p><strong>注：有可能会有部分人右边是乱码，可以使用以下方式修改，修改后重启 Xftp。</strong></p>
<p><code>文件-当前会话属性--选项--编码：UTF-8</code></p>
<figure><img src="https://i0.hdslb.com/bfs/album/45e7ef25dd37c8ed35859e6e5e146a3d08f0ebb5.png" alt="image-20220816143434490" tabindex="0" loading="lazy"><figcaption>image-20220816143434490</figcaption></figure>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-01-30T06:57:36.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
  <entry>
    <title type="text">03 【基础篇-系统管理】</title>
    <id>https://blog.dselegent.cf/back_end/linux/03.html</id>
    <link href="https://blog.dselegent.cf/back_end/linux/03.html"/>
    <updated>2023-01-30T06:57:36.000Z</updated>
    <summary type="html"><![CDATA[<h1> 03 【基础篇-系统管理】</h1>
<h2> 1.Linux 中的进程和服务</h2>
<p>计算机中，一个正在执行的程序或命令，被叫做“进程”（process）。</p>
<p>启动之后一只存在、常驻内存的进程，一般被称作“服务”（service）。</p>
<blockquote>
<p>详细操作后面说明</p>
</blockquote>
<h2> 2.systemctl 服务管理</h2>
<blockquote>
<p>service 服务管理（CentOS 6 版本-了解）</p>
<p>systemctl （CentOS 7 版本-重点掌握）</p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<h1> 03 【基础篇-系统管理】</h1>
<h2> 1.Linux 中的进程和服务</h2>
<p>计算机中，一个正在执行的程序或命令，被叫做“进程”（process）。</p>
<p>启动之后一只存在、常驻内存的进程，一般被称作“服务”（service）。</p>
<blockquote>
<p>详细操作后面说明</p>
</blockquote>
<h2> 2.systemctl 服务管理</h2>
<blockquote>
<p>service 服务管理（CentOS 6 版本-了解）</p>
<p>systemctl （CentOS 7 版本-重点掌握）</p>
</blockquote>
<p>CentOS 7使用Systemd管理守护进程。centos7采用 systemd管理，服务独立的运行在内存中，服务响应速度快，但占用更多内存。独立服务的服务启动脚本都在目录 /usr/lib/systemd/system里。Systend的新特性：</p>
<ul>
<li>系统引导时实现服务的并行启动；</li>
<li>按需激活进程；</li>
<li>系统实现快照；</li>
<li>基于依赖关系定义服务的控制逻辑；</li>
</ul>
<p>systemctl可用于内省和控制“systemd”系统和服务管理器的状态。centos7.x系统环境下我们经常使用此命令启停服务，实际上此命令除了其他独立服务还有很多其他用途。</p>
<h3> 2.1 systemctl参数说明</h3>
<blockquote>
<p>基本语法：<code>systemctl start | stop | restart | status | reload 服务名</code></p>
<p><code>systemctl</code> 指令管理的服务在 /<code>usr/lib/systemd/system</code></p>
<p>查看查看服务的方法：<code>pwd /usr/lib/systemd/system</code></p>
</blockquote>
<p><strong>1、使用语法</strong></p>
<p>用法：systemctl [OPTIONS…] {COMMAND} …</p>
<p><strong>2 、参数说明</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">start</td>
<td style="text-align:left">立刻启动后面接的unit</td>
</tr>
<tr>
<td style="text-align:left">stop</td>
<td style="text-align:left">立刻关闭后面接的unit</td>
</tr>
<tr>
<td style="text-align:left">restart</td>
<td style="text-align:left">立刻关闭后启动后面接的unit，亦即执行stop再start的意思</td>
</tr>
<tr>
<td style="text-align:left">reload</td>
<td style="text-align:left">不关闭后面接的unit的情况下，重载配置文件，让设定生效</td>
</tr>
<tr>
<td style="text-align:left">enable</td>
<td style="text-align:left">设定下次开机时，后面接的unit会被启动</td>
</tr>
<tr>
<td style="text-align:left">disable</td>
<td style="text-align:left">设定下次开机时，后面接的unit 不会被启动</td>
</tr>
<tr>
<td style="text-align:left">status</td>
<td style="text-align:left">目前后面接的这个unit 的状态，会列出是否正在执行、是否开机启动等信息。</td>
</tr>
<tr>
<td style="text-align:left">is-active</td>
<td style="text-align:left">目前有没有正在运行中</td>
</tr>
<tr>
<td style="text-align:left">is-enable</td>
<td style="text-align:left">开机时有没有预设要启用这个unit</td>
</tr>
<tr>
<td style="text-align:left">kill</td>
<td style="text-align:left">不要被kill这个名字吓着了,它其实是向运行unit的进程发送信号</td>
</tr>
<tr>
<td style="text-align:left">show</td>
<td style="text-align:left">列出unit的配置。</td>
</tr>
<tr>
<td style="text-align:left">mask</td>
<td style="text-align:left">注销unit,注销后你就无法启动这个unit了</td>
</tr>
<tr>
<td style="text-align:left">unmask</td>
<td style="text-align:left">取消对unit的注销</td>
</tr>
<tr>
<td style="text-align:left">list-units</td>
<td style="text-align:left">依据unit列出目前有启动的unit。若加上–all才会列出没启动的。（等价于无参数）</td>
</tr>
<tr>
<td style="text-align:left">list-unit-files</td>
<td style="text-align:left">列出所有以安装unit以及他们的开机启动状态（enabled、disabled、static、mask）。</td>
</tr>
<tr>
<td style="text-align:left">–type=TYPE</td>
<td style="text-align:left">就是unit type，主要有service，socket，target等</td>
</tr>
<tr>
<td style="text-align:left">get-default</td>
<td style="text-align:left">取得目前的 target</td>
</tr>
<tr>
<td style="text-align:left">set-default</td>
<td style="text-align:left">设定后面接的 target 成为默认的操作模式</td>
</tr>
<tr>
<td style="text-align:left">isolate</td>
<td style="text-align:left">切换到后面接的模式</td>
</tr>
</tbody>
</table>
<p><strong>3、unit file结构</strong></p>
<p>文件通常由三部分组成：</p>
<ul>
<li>
<p>Unit: 定义与Unit类型无关的通用选项；用于提供unit的描述信息，unit行为及依赖关系等。</p>
</li>
<li>
<p>Service：与特定类型相关的专用选项；此处为Service类型。</p>
</li>
<li>
<p>Install：定义由"systemctl enable"及"systemctl disable"命令在实现服务启用或禁用时用到的一些选项。</p>
</li>
</ul>
<p><strong>4、Unit段的常用选项</strong></p>
<ul>
<li>Description：描述信息，意义性描述；</li>
<li>After：定义unit的启动次序；表示当前unit应晚于哪些unit启动；其功能与Before相反；</li>
<li>Requies：依赖到其它的units；强依赖，被依赖的units无法激活时，当前的unit即无法激活；</li>
<li>Wants：依赖到其它的units；弱依赖；</li>
<li>Confilcts：定义units 的冲突关系；</li>
</ul>
<p><strong>5、Service段的常用选项</strong></p>
<ul>
<li>Type：用于定义影响ExecStart及相关参数的功能的unit进程类型；
类型有：simple、forking、oneshot、dbus、notify、idle。</li>
<li>EnvironmentFile：环境配置文件；</li>
<li>ExecStart：指明启动unit要运行的命令或脚本；ExecStart, ExecStartPost</li>
<li>ExecStop：指明停止unit要运行的命令或脚本；</li>
<li>Restart:</li>
</ul>
<p><strong>6、Install段的常用配置：</strong></p>
<ul>
<li>Alias：</li>
<li>RequiredBy：被哪些unit所依赖；</li>
<li>WantBy：被哪些unit所依赖；</li>
</ul>
<p><strong>7、Unit文件样例</strong></p>
<blockquote>
<p>[root@s153 system]# cat chronyd.service
[Unit]
Description=NTP client/server
Documentation=man:chronyd(8) man:chrony.conf(5)
After=ntpdate.service sntp.service ntpd.service
Conflicts=ntpd.service systemd-timesyncd.service
ConditionCapability=CAP_SYS_TIME</p>
<p>[Service]
Type=forking
PIDFile=/var/run/chronyd.pid
EnvironmentFile=-/etc/sysconfig/chronyd
ExecStart=/usr/sbin/chronyd $OPTIONS
ExecStartPost=/usr/libexec/chrony-helper update-daemon
PrivateTmp=yes
ProtectHome=yes
ProtectSystem=full</p>
<p>[Install]
WantedBy=multi-user.target</p>
</blockquote>
<h3> 2.2 systemctl使用示例</h3>
<p>1.查看开机启动列表</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://i0.hdslb.com/bfs/album/8f3ccb6e4eb3773f018eafbcc5958c7f307c256d.png" alt="image-20220816153223542" tabindex="0" loading="lazy"><figcaption>image-20220816153223542</figcaption></figure>
<blockquote>
<p>可以<strong>写一半</strong>再查看完整的服务名，一般也可以简写：<code>firewalld.service = firewall</code></p>
</blockquote>
<figure><img src="https://i0.hdslb.com/bfs/album/d6f8f45c8d6d676c9037ae76599649939b44d19c.png" alt="image-20220816153519618" tabindex="0" loading="lazy"><figcaption>image-20220816153519618</figcaption></figure>
<p>说明防火墙是一个自启的状态，Linux系统启动的时候防火墙也会自启。</p>
<p>2.设置开机启动</p>
<blockquote>
<p>systemctl在enable、disable、mask子命令里面增加了–now选项，可以激活同时启动服务，激活同时停止服务等。</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3">
<li>取消开机启动</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>systemctl disable firewalld</code>时，下次重启系统时防火墙还是处于关闭的状态</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d0a44045e2e5d9b285645fcc1b1acfdd484cac29.png" alt="image-20220816153845865" tabindex="0" loading="lazy"><figcaption>image-20220816153845865</figcaption></figure>
<p>重新打开自启动防火墙：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/d7c296ec3443d9ab5ddc54905e7daf6ea7dec6da.png" alt="image-20220816153905563" tabindex="0" loading="lazy"><figcaption>image-20220816153905563</figcaption></figure>
<ol>
<li><code>systemctl enable 服务名</code> (设置服务开机启动)，对 <code>3</code> （无界面）和 <code>5</code> （GUI）运行级别都生效</li>
<li><code>systemctl disable 服务名</code> (关闭服务开机启动)，对 <code>3</code> （无界面）和 <code>5</code> （GUI）运行级别都生效</li>
</ol>
<p>4.开启服务</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开启防火墙：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/f87769820ac96afcfb6482b5cfe93585251e0821.png" alt="image-20220816153707677" tabindex="0" loading="lazy"><figcaption>image-20220816153707677</figcaption></figure>
<p>5.关闭服务(但是下次开机还是会启动)</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>关闭防火墙：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/ebacad6bc276ef0657f682f6fc16c3d429630be4.png" alt="image-20220816153641546" tabindex="0" loading="lazy"><figcaption>image-20220816153641546</figcaption></figure>
<p>6.重启服务</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>7.重新加载配置</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>8.输出服务运行的状态</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>查看防火墙的状态，现在是运行中：</p>
<figure><img src="https://i0.hdslb.com/bfs/album/2ab17ff6081e34c5e95ab4371c18afbbb3dbf6fd.png" alt="image-20220816153614211" tabindex="0" loading="lazy"><figcaption>image-20220816153614211</figcaption></figure>
<p>9.检查service是否在启动状态</p>
<blockquote>
<p>写脚本是判断服务器是否启动很管用</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>10.检测unit单元是否为自动启动</p>
<blockquote>
<p>写脚本时判断服务器是否开机自启很管用</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://i0.hdslb.com/bfs/album/71cc922dae47090936df0308581c83ee41d1e350.png" alt="image-20220816153416785" tabindex="0" loading="lazy"><figcaption>image-20220816153416785</figcaption></figure>
<p>11.注销一个服务(service)</p>
<blockquote>
<p>systemctl mask 是注销服务的意思。
注销服务意味着：
该服务在系统重启的时候不会启动
该服务无法进行做systemctl start/stop操作
该服务无法进行systemctl enable/disable操作</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>12.取消注销服务(service)</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>13.显示单元的手册页（前提是由unit提供）</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>14.当新增或修改service单元文件时，需要系统重新加载所有修改过的配置文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>15.查看systemd资源使用率</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>16.杀死服务</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.系统运行级别</h2>
<p>1）Linux 运行级别 CentOS 6</p>
<figure><img src="https://i0.hdslb.com/bfs/album/9e03760af35f6c5a47222c2cba602d0b10b0f797.png" alt="image-20220816154334839" tabindex="0" loading="lazy"><figcaption>image-20220816154334839</figcaption></figure>
<p>Centos7的启动流程图</p>
<figure><img src="https://i0.hdslb.com/bfs/album/42bd95859fd306d1d3182e5701374d77f733c980.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<blockquote>
<p>CentOS7中我们的初始化进程变为了systemd。执行默认target配置文件/etc/systemd/system/default.target（这是一个软链接，与默认运行级别有关）。然后执行sysinit.target来初始化系统和basic.target来准备操作系统。接着启动multi-user.target下的本机与服务器服务，并检查/etc/rc.d/rc.local文件是否有用户自定义脚本需要启动。最后执行multi-user下的getty.target及登录服务，检查default.target是否有其他的服务需要启动。</p>
<p>注意：/etc/systemd/system/default.target指向了/lib/systemd/system/目录下的graphical.target或multiuser.target。而graphical.target依赖multiuser.target，multiuser.target依赖basic.target，basic.target依赖sysinit.target，所以倒过来执行。</p>
</blockquote>
<p>2）CentOS7 的运行级别简化为:</p>
<ul>
<li>
<p>multi-user.target 等价于原运行级别 3（多用户有网，无图形界面）</p>
</li>
<li>
<p>graphical.target 等价于原运行级别 5（多用户有网，有图形界面）</p>
</li>
</ul>
<p>3） 查看当前运行级别:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>4）修改当前运行级别</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p>centos7中取消了通过修改配置文件设置系统默认运行级别</p>
<div class="language-php line-numbers-mode" data-ext="php"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote>
<h2> 4.关机重启命令</h2>
<h3> 4.1 关机重启命令汇总</h3>
<table>
<thead>
<tr>
<th>halt</th>
<th><strong>关机</strong></th>
<th><strong>root用户</strong></th>
<th><strong>halt：只关闭系统，电源还在运行</strong><br><strong>halt -p：关闭系统，关闭电源（先执行halt，再执行poweroff）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>poweroff</td>
<td>关机</td>
<td>root用户</td>
<td>poweroff会发送一个关闭电源的信号给acpi</td>
</tr>
<tr>
<td>reboot</td>
<td>重启</td>
<td>root用户</td>
<td></td>
</tr>
<tr>
<td>shutdown</td>
<td>-h：关机<br>-r：重启<br>-c：取消shutdown操作</td>
<td>root用户</td>
<td>shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff<br>shutdown -r now：一分钟后重启<br>shutdown -r 05:30：最近的5:30重启<br>shutdown -r +10：十分钟后重启</td>
</tr>
<tr>
<td>init</td>
<td>init 0：关机<br>init 6：重启</td>
<td>root用户</td>
<td>init：切换系统的运行级别</td>
</tr>
<tr>
<td>systemctl</td>
<td>systemctl halt [-i]：关机 systemctl poweroff [-i]：关机 systemctl reboot [-i]：重启</td>
<td>普通用户 超级用户</td>
<td>普通用户需要加-i root用户不需要加-i</td>
</tr>
</tbody>
</table>
<blockquote>
<p>（1）sync （功能描述：将数据由内存同步到硬盘中）</p>
<p>（2）halt （功能描述：停机，关闭系统，但不断电）</p>
<p>（3）poweroff （功能描述：关机，断电） （</p>
<p>(4）reboot （功能描述：就是重启，等同于 shutdown -r now）</p>
</blockquote>
<p>在关机或者重启之前，执行3至4次sync，将在内存中还未保存到硬盘的数据更新到硬盘中，否则会造成数据的丢失。执行sync时要以管理员的身份运行，因为管理员具有所有文件的权限，而普通用户只具有自己的部分文件的权限。</p>
<p>最经常使用的关机重启的命令是shutdown，因此下面详细学习的使用。</p>
<h3> 4.2 shutdown命令</h3>
<p>基本格式：shutdown [选项] [时间] [警告信息]</p>
<p><em>选项：</em></p>
<ol>
<li>-h：关机</li>
<li>-r：重启</li>
<li>-c：取消shutdown执行的关机或者重启命令</li>
<li>-k：不关机，发出警告</li>
</ol>
<p><em>时间：</em></p>
<ol>
<li>shutdown：一分钟后关机（默认）</li>
<li>shutdown now：立刻关机</li>
<li>shutdown 10：10分钟后关机</li>
<li>shutdown 05:00：5点关机</li>
</ol>
<p>示例：</p>
<p>shutdown -r now：系统立马重启（等同于 reboot
shutdown -r 05:30：最近的5:30重启
shutdown -r 10：十分钟后重启</p>
<p>shutdown -h now：立马关机（等同于 poweroff
shutdown -h 05:30：最近的5:30关机
shutdown -h +10：十分钟后关机</p>
<p>shutdown -c：取消上面的关机重启操作</p>
<p>shutdown -k +10 “I will shutdown in 10 minutes”：10分钟后并不会真的关机，但是会把警告信息发给所有的用户。</p>
<h3> 4.3 sync命令</h3>
<p>sync ：linux同步数据命令，<strong>将数据由内存同步到硬盘中</strong>，包含已修改的 i-node、已延迟的块 I/O 和读写映射文件。如果不去手动的输入sync命令来真正的去写磁盘，linux系统也会周期性的去sync数据。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用场景：
1.在 关机或者开机之前最好多执行这个几次，以确保数据写入硬盘。
2.挂载时，需要很长时间的操作动作（比如，cp 大文件，检测文件），在这个动作之后接sync。
3.卸载U盘或其他存储设备，需要很长时间，使用sync。</p>
<p><strong>经验技巧</strong></p>
<p>​	Linux 系统中为了提高磁盘的读写效率，对磁盘采取了 “预读迟写”操作方式。当用户 保存文件时，Linux 核心并不一定立即将保存数据写入物理磁盘中，而是将数据保存在缓 冲区中，等缓冲区满时再写入磁盘，这种方式可以极大的提高磁盘写入数据的效率。但是， 也带来了安全隐患，如果数据还未写入磁盘时，系统掉电或者其他严重问题出现，则将导 致数据丢失。使用 sync 指令可以立即将缓冲区的数据写入磁盘。</p>
]]></content>
    <author>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </author>
    <contributor>
      <name>dselegent</name>
      <uri>https://blog.dselegent.cf</uri>
    </contributor>
    <published>2023-01-30T06:57:36.000Z</published>
    <rights>Copyright by dselegent</rights>
  </entry>
</feed>