const e=JSON.parse('{"key":"v-49ec6112","path":"/front_end/front_end_framework/react/15.html","title":"15【react-Hook （下）】","lang":"zh-CN","frontmatter":{"description":"15【react-Hook （下）】 1.React.memo 1.1 基本介绍 这是一个高阶组件，用来做性能优化的，这个本来应该是写在React高级指引中的，但是这个案例会和后面的useCallback联合起来，所以就写在这里了 React.memo() 是一个高阶组件，如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。 它接收另一个组件作为参数，并且会返回一个包装过的新组件 包装过的新组件就会具有缓存功能，这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。 包装过后，只有组件的props发生变化，才会触发组件的重新的渲染，否则总是返回缓存中结果。如果函数组件被 React.memo 包裹，且其实现中拥有 useState，useReducer 或 useContext 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。","head":[["meta",{"property":"og:url","content":"https://blog.dselegent.cf/front_end/front_end_framework/react/15.html"}],["meta",{"property":"og:site_name","content":"dselegent-blog"}],["meta",{"property":"og:title","content":"15【react-Hook （下）】"}],["meta",{"property":"og:description","content":"15【react-Hook （下）】 1.React.memo 1.1 基本介绍 这是一个高阶组件，用来做性能优化的，这个本来应该是写在React高级指引中的，但是这个案例会和后面的useCallback联合起来，所以就写在这里了 React.memo() 是一个高阶组件，如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。 它接收另一个组件作为参数，并且会返回一个包装过的新组件 包装过的新组件就会具有缓存功能，这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。 包装过后，只有组件的props发生变化，才会触发组件的重新的渲染，否则总是返回缓存中结果。如果函数组件被 React.memo 包裹，且其实现中拥有 useState，useReducer 或 useContext 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-30T06:57:36.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-30T06:57:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"15【react-Hook （下）】\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-01-30T06:57:36.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1.React.memo","slug":"_1-react-memo","link":"#_1-react-memo","children":[{"level":3,"title":"1.1 基本介绍","slug":"_1-1-基本介绍","link":"#_1-1-基本介绍","children":[]},{"level":3,"title":"1.2 问题的引出","slug":"_1-2-问题的引出","link":"#_1-2-问题的引出","children":[]},{"level":3,"title":"1.3 使用React.memo","slug":"_1-3-使用react-memo","link":"#_1-3-使用react-memo","children":[]},{"level":3,"title":"1.4 使用注意","slug":"_1-4-使用注意","link":"#_1-4-使用注意","children":[]},{"level":3,"title":"1.5 容易出错的情况","slug":"_1-5-容易出错的情况","link":"#_1-5-容易出错的情况","children":[]}]},{"level":2,"title":"2.useCallback","slug":"_2-usecallback","link":"#_2-usecallback","children":[{"level":3,"title":"2.1 基本介绍","slug":"_2-1-基本介绍","link":"#_2-1-基本介绍","children":[]},{"level":3,"title":"2.2 解决1.5遗留的问题","slug":"_2-2-解决1-5遗留的问题","link":"#_2-2-解决1-5遗留的问题","children":[]},{"level":3,"title":"2.3 第二个参数的使用","slug":"_2-3-第二个参数的使用","link":"#_2-3-第二个参数的使用","children":[]}]},{"level":2,"title":"3.useMemo","slug":"_3-usememo","link":"#_3-usememo","children":[{"level":3,"title":"3.1 问题的引出","slug":"_3-1-问题的引出","link":"#_3-1-问题的引出","children":[]},{"level":3,"title":"3.2 使用 useMemo 解决上面的问题","slug":"_3-2-使用-usememo-解决上面的问题","link":"#_3-2-使用-usememo-解决上面的问题","children":[]},{"level":3,"title":"3.3 第二个参数的使用","slug":"_3-3-第二个参数的使用","link":"#_3-3-第二个参数的使用","children":[]}]},{"level":2,"title":"4.React.forwardRef","slug":"_4-react-forwardref","link":"#_4-react-forwardref","children":[]},{"level":2,"title":"5.useImperativeHandle","slug":"_5-useimperativehandle","link":"#_5-useimperativehandle","children":[]}],"git":{"createdTime":1675061856000,"updatedTime":1675061856000,"contributors":[{"name":"dselegent","email":"1799661558@qq.com","commits":1}]},"readingTime":{"minutes":12.77,"words":3832},"filePathRelative":"front_end/front_end_framework/react/15.md","localizedDate":"2023年1月30日","excerpt":"<h1> 15【react-Hook （下）】</h1>\\n<h2> 1.React.memo</h2>\\n<h3> 1.1 基本介绍</h3>\\n<blockquote>\\n<p>这是一个高阶组件，用来做性能优化的，这个本来应该是写在<code>React高级指引</code>中的，但是这个案例会和后面的<code>useCallback</code>联合起来，所以就写在这里了</p>\\n</blockquote>\\n<ul>\\n<li>React.memo() 是一个高阶组件，如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。\\n<ul>\\n<li>它接收另一个组件作为参数，并且会返回一个包装过的新组件</li>\\n<li>包装过的新组件就会具有缓存功能，这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</li>\\n<li>包装过后，只有组件的props发生变化，才会触发组件的重新的渲染，否则总是返回缓存中结果。如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <a href=\\"https://zh-hans.reactjs.org/docs/hooks-state.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>useState</code></a>，<a href=\\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>useReducer</code></a> 或 <a href=\\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>useContext</code></a> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
