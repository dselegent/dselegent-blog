const e=JSON.parse('{"key":"v-027865b2","path":"/front_end/js_advanced/typescript/02.html","title":"3.TypeScript常用类型","lang":"zh-CN","frontmatter":{"description":"3.TypeScript常用类型 3.1 概述 TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：类型系统 所有的 JS 代码都是 TS 代码 JS 有类型（比如，number/string 等），但是 JS 不会检查变量的类型是否发生变化，而 TS 会检查 TypeScript 类型系统的主要优势：可以显示标记出代码中的意外行为，从而降低了发生错误的可能性","head":[["meta",{"property":"og:url","content":"https://blog.dselegent.icu/front_end/js_advanced/typescript/02.html"}],["meta",{"property":"og:site_name","content":"dselegent-blog"}],["meta",{"property":"og:title","content":"3.TypeScript常用类型"}],["meta",{"property":"og:description","content":"3.TypeScript常用类型 3.1 概述 TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：类型系统 所有的 JS 代码都是 TS 代码 JS 有类型（比如，number/string 等），但是 JS 不会检查变量的类型是否发生变化，而 TS 会检查 TypeScript 类型系统的主要优势：可以显示标记出代码中的意外行为，从而降低了发生错误的可能性"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-30T06:57:36.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-30T06:57:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3.TypeScript常用类型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-01-30T06:57:36.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"3.1 概述","slug":"_3-1-概述","link":"#_3-1-概述","children":[]},{"level":2,"title":"3.2 TypeScript常见类型","slug":"_3-2-typescript常见类型","link":"#_3-2-typescript常见类型","children":[]},{"level":2,"title":"3.3 原始类型","slug":"_3-3-原始类型","link":"#_3-3-原始类型","children":[{"level":3,"title":"3.3.1 JS的八种内置类型","slug":"_3-3-1-js的八种内置类型","link":"#_3-3-1-js的八种内置类型","children":[]},{"level":3,"title":"3.3.2注意点","slug":"_3-3-2注意点","link":"#_3-3-2注意点","children":[]}]},{"level":2,"title":"3.4 数组类型","slug":"_3-4-数组类型","link":"#_3-4-数组类型","children":[]},{"level":2,"title":"3.5 联合类型与交叉类型","slug":"_3-5-联合类型与交叉类型","link":"#_3-5-联合类型与交叉类型","children":[{"level":3,"title":"3.5.1 联合类型","slug":"_3-5-1-联合类型","link":"#_3-5-1-联合类型","children":[]},{"level":3,"title":"3.5.1 交叉类型","slug":"_3-5-1-交叉类型","link":"#_3-5-1-交叉类型","children":[]}]},{"level":2,"title":"3.6 类型别名","slug":"_3-6-类型别名","link":"#_3-6-类型别名","children":[]},{"level":2,"title":"3.7 函数类型","slug":"_3-7-函数类型","link":"#_3-7-函数类型","children":[{"level":3,"title":"3.7.1 基本使用","slug":"_3-7-1-基本使用","link":"#_3-7-1-基本使用","children":[]},{"level":3,"title":"3.7.2 void 类型","slug":"_3-7-2-void-类型","link":"#_3-7-2-void-类型","children":[]},{"level":3,"title":"3.7.3 never 类型","slug":"_3-7-3-never-类型","link":"#_3-7-3-never-类型","children":[]},{"level":3,"title":"3.7.4 可选参数","slug":"_3-7-4-可选参数","link":"#_3-7-4-可选参数","children":[]},{"level":3,"title":"3.7.5 参数默认值","slug":"_3-7-5-参数默认值","link":"#_3-7-5-参数默认值","children":[]},{"level":3,"title":"3.7.6 剩余参数","slug":"_3-7-6-剩余参数","link":"#_3-7-6-剩余参数","children":[]},{"level":3,"title":"3.7.7 函数重载","slug":"_3-7-7-函数重载","link":"#_3-7-7-函数重载","children":[]}]},{"level":2,"title":"3.8 类型推断","slug":"_3-8-类型推断","link":"#_3-8-类型推断","children":[]},{"level":2,"title":"3.9 对象类型","slug":"_3-9-对象类型","link":"#_3-9-对象类型","children":[{"level":3,"title":"3.9.1 基本使用","slug":"_3-9-1-基本使用","link":"#_3-9-1-基本使用","children":[]},{"level":3,"title":"3.9.2 箭头函数形式的方法类型","slug":"_3-9-2-箭头函数形式的方法类型","link":"#_3-9-2-箭头函数形式的方法类型","children":[]},{"level":3,"title":"3.9.3 对象可选属性","slug":"_3-9-3-对象可选属性","link":"#_3-9-3-对象可选属性","children":[]},{"level":3,"title":"3.9.4 使用类型别名","slug":"_3-9-4-使用类型别名","link":"#_3-9-4-使用类型别名","children":[]},{"level":3,"title":"3.9.5 任意属性","slug":"_3-9-5-任意属性","link":"#_3-9-5-任意属性","children":[]}]},{"level":2,"title":"3.10 元组类型","slug":"_3-10-元组类型","link":"#_3-10-元组类型","children":[{"level":3,"title":"3.10.1 元祖定义","slug":"_3-10-1-元祖定义","link":"#_3-10-1-元祖定义","children":[]},{"level":3,"title":"3.10.2 元祖类型的解构赋值","slug":"_3-10-2-元祖类型的解构赋值","link":"#_3-10-2-元祖类型的解构赋值","children":[]},{"level":3,"title":"3.10.3 元组类型的可选元素","slug":"_3-10-3-元组类型的可选元素","link":"#_3-10-3-元组类型的可选元素","children":[]},{"level":3,"title":"3.10.4 元组类型的剩余元素","slug":"_3-10-4-元组类型的剩余元素","link":"#_3-10-4-元组类型的剩余元素","children":[]},{"level":3,"title":"3.10.5 只读的元组类型","slug":"_3-10-5-只读的元组类型","link":"#_3-10-5-只读的元组类型","children":[]}]}],"git":{"createdTime":1675061856000,"updatedTime":1675061856000,"contributors":[{"name":"dselegent","email":"1799661558@qq.com","commits":1}]},"readingTime":{"minutes":20.98,"words":6295},"filePathRelative":"front_end/js_advanced/typescript/02.md","localizedDate":"2023年1月30日","excerpt":"<h1> 3.TypeScript常用类型</h1>\\n<h2> 3.1 概述</h2>\\n<p>TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：<strong>类型系统</strong></p>\\n<ul>\\n<li>所有的 JS 代码都是 TS 代码</li>\\n<li><strong>JS 有类型</strong>（比如，number/string 等），但是 <strong>JS 不会检查变量的类型是否发生变化</strong>，而 TS 会检查</li>\\n</ul>\\n<p>TypeScript 类型系统的主要优势：<strong>可以显示标记出代码中的意外行为，从而降低了发生错误的可能性</strong></p>","autoDesc":true}');export{e as data};
