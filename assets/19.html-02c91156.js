const e=JSON.parse('{"key":"v-3c459c1a","path":"/front_end/front_end_framework/react/19.html","title":"19 【RTK Query】","lang":"zh-CN","frontmatter":{"description":"19 【RTK Query】 1.目前前端常见的发起 ajax 请求的方式 1、使用原生的ajax请求 2、使用jquery封装好的ajax请求 3、使用fetch发起请求 4、第三方的比如axios请求 5、angular中自带的HttpClient 就目前前端框架开发中来说我们在开发vue、react的时候一般都是使用fetch或axios自己封装一层来与后端数据交互，至于angular肯定是用自带的HttpClient请求方式，但是依然存在几个致命的弱点，","head":[["meta",{"property":"og:url","content":"https://blog.dselegent.icu/front_end/front_end_framework/react/19.html"}],["meta",{"property":"og:site_name","content":"dselegent-blog"}],["meta",{"property":"og:title","content":"19 【RTK Query】"}],["meta",{"property":"og:description","content":"19 【RTK Query】 1.目前前端常见的发起 ajax 请求的方式 1、使用原生的ajax请求 2、使用jquery封装好的ajax请求 3、使用fetch发起请求 4、第三方的比如axios请求 5、angular中自带的HttpClient 就目前前端框架开发中来说我们在开发vue、react的时候一般都是使用fetch或axios自己封装一层来与后端数据交互，至于angular肯定是用自带的HttpClient请求方式，但是依然存在几个致命的弱点，"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-11T09:36:47.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-11T09:36:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"19 【RTK Query】\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-04-11T09:36:47.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1.目前前端常见的发起 ajax 请求的方式","slug":"_1-目前前端常见的发起-ajax-请求的方式","link":"#_1-目前前端常见的发起-ajax-请求的方式","children":[]},{"level":2,"title":"2.RTK Query 概述","slug":"_2-rtk-query-概述","link":"#_2-rtk-query-概述","children":[]},{"level":2,"title":"3.基础开发流程","slug":"_3-基础开发流程","link":"#_3-基础开发流程","children":[{"level":3,"title":"3.1 定义 API Slice","slug":"_3-1-定义-api-slice","link":"#_3-1-定义-api-slice","children":[]},{"level":3,"title":"3.2 配置 Store","slug":"_3-2-配置-store","link":"#_3-2-配置-store","children":[]},{"level":3,"title":"3.3 在组件中使用 Query Hooks","slug":"_3-3-在组件中使用-query-hooks","link":"#_3-3-在组件中使用-query-hooks","children":[]}]},{"level":2,"title":"4.传递参数","slug":"_4-传递参数","link":"#_4-传递参数","children":[{"level":3,"title":"4.1 定义接收参数","slug":"_4-1-定义接收参数","link":"#_4-1-定义接收参数","children":[]},{"level":3,"title":"4.2 传递参数","slug":"_4-2-传递参数","link":"#_4-2-传递参数","children":[]}]},{"level":2,"title":"5.转换响应","slug":"_5-转换响应","link":"#_5-转换响应","children":[]},{"level":2,"title":"6.RTK Query 缓存简单介绍","slug":"_6-rtk-query-缓存简单介绍","link":"#_6-rtk-query-缓存简单介绍","children":[{"level":3,"title":"6.1 什么是相同查询","slug":"_6-1-什么是相同查询","link":"#_6-1-什么是相同查询","children":[]},{"level":3,"title":"6.2 引用计数与垃圾回收","slug":"_6-2-引用计数与垃圾回收","link":"#_6-2-引用计数与垃圾回收","children":[]},{"level":3,"title":"6.3 缓存初体验","slug":"_6-3-缓存初体验","link":"#_6-3-缓存初体验","children":[]}]},{"level":2,"title":"7.mutation 请求接口","slug":"_7-mutation-请求接口","link":"#_7-mutation-请求接口","children":[{"level":3,"title":"7.1 添加新的 Mutations 后请求接口","slug":"_7-1-添加新的-mutations-后请求接口","link":"#_7-1-添加新的-mutations-后请求接口","children":[]},{"level":3,"title":"7.2 在组件中使用 Mutation Hooks","slug":"_7-2-在组件中使用-mutation-hooks","link":"#_7-2-在组件中使用-mutation-hooks","children":[]}]},{"level":2,"title":"8.useQuery Hook 参数","slug":"_8-usequery-hook-参数","link":"#_8-usequery-hook-参数","children":[{"level":3,"title":"8.1 条件提取","slug":"_8-1-条件提取","link":"#_8-1-条件提取","children":[]},{"level":3,"title":"8.2 轮询","slug":"_8-2-轮询","link":"#_8-2-轮询","children":[]},{"level":3,"title":"8.3 从查询结果中选择数据","slug":"_8-3-从查询结果中选择数据","link":"#_8-3-从查询结果中选择数据","children":[]},{"level":3,"title":"8.4 refetchOnMountOrArgChange","slug":"_8-4-refetchonmountorargchange","link":"#_8-4-refetchonmountorargchange","children":[]},{"level":3,"title":"8.5 refetchOnFocus","slug":"_8-5-refetchonfocus","link":"#_8-5-refetchonfocus","children":[]},{"level":3,"title":"8.6 refetchOnReconnect","slug":"_8-6-refetchonreconnect","link":"#_8-6-refetchonreconnect","children":[]}]},{"level":2,"title":"9.刷新缓存数据","slug":"_9-刷新缓存数据","link":"#_9-刷新缓存数据","children":[{"level":3,"title":"9.1 手动刷新","slug":"_9-1-手动刷新","link":"#_9-1-手动刷新","children":[]},{"level":3,"title":"9.2 缓存失效自动刷新-数据标签","slug":"_9-2-缓存失效自动刷新-数据标签","link":"#_9-2-缓存失效自动刷新-数据标签","children":[]}]},{"level":2,"title":"10.RTKQ 结合 Axios","slug":"_10-rtkq-结合-axios","link":"#_10-rtkq-结合-axios","children":[{"level":3,"title":"10.1 BaseQuery","slug":"_10-1-basequery","link":"#_10-1-basequery","children":[]},{"level":3,"title":"10.2 AxiosBaseQuery","slug":"_10-2-axiosbasequery","link":"#_10-2-axiosbasequery","children":[]}]},{"level":2,"title":"11.小总结","slug":"_11-小总结","link":"#_11-小总结","children":[]}],"git":{"createdTime":1675061856000,"updatedTime":1681205807000,"contributors":[{"name":"dselegent","email":"1799661558@qq.com","commits":2}]},"readingTime":{"minutes":31.93,"words":9579},"filePathRelative":"front_end/front_end_framework/react/19.md","localizedDate":"2023年1月30日","excerpt":"<h1> 19 【RTK Query】</h1>\\n<h2> 1.目前前端常见的发起 ajax 请求的方式</h2>\\n<ul>\\n<li>1、使用原生的<code>ajax</code>请求</li>\\n<li>2、使用<code>jquery</code>封装好的<code>ajax</code>请求</li>\\n<li>3、使用<code>fetch</code>发起请求</li>\\n<li>4、第三方的比如<code>axios</code>请求</li>\\n<li>5、<code>angular</code>中自带的<code>HttpClient</code></li>\\n</ul>\\n<p>就目前前端框架开发中来说我们在开发<code>vue</code>、<code>react</code>的时候一般都是使用<code>fetch</code>或<code>axios</code>自己封装一层来与后端数据交互，至于<code>angular</code>肯定是用自带的<code>HttpClient</code>请求方式，但是依然存在几个致命的弱点，</p>","autoDesc":true}');export{e as data};
