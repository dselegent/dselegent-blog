const e=JSON.parse('{"key":"v-29d1a5dc","path":"/front_end/front_end_base/javascript/06.html","title":"06 【函数（下）】","lang":"zh-CN","frontmatter":{"description":"06 【函数（下）】 1.用new操作符调用函数 现在，我们学习一种新的函数调用方式：new 函数() 你可能知道 new 操作符和 “面向对象” 息息相关，但是现在我们先不探讨它的 “面向对象” 意义，而是先把用 new 调用函数的执行步骤和它上下文弄清楚。 1.1 用new调用函数的四步走 JS 规定，使用 new 操作符调用函数会进行 “四步走”： 函数体内会自动创建出一个空白对象 函数的上下文（this）会指向这个对象 函数体内的语句会执行 函数会自动返回上下文对象，即使函数没有 return 语句","head":[["meta",{"property":"og:url","content":"https://blog.dselegent.icu/front_end/front_end_base/javascript/06.html"}],["meta",{"property":"og:site_name","content":"dselegent-blog"}],["meta",{"property":"og:title","content":"06 【函数（下）】"}],["meta",{"property":"og:description","content":"06 【函数（下）】 1.用new操作符调用函数 现在，我们学习一种新的函数调用方式：new 函数() 你可能知道 new 操作符和 “面向对象” 息息相关，但是现在我们先不探讨它的 “面向对象” 意义，而是先把用 new 调用函数的执行步骤和它上下文弄清楚。 1.1 用new调用函数的四步走 JS 规定，使用 new 操作符调用函数会进行 “四步走”： 函数体内会自动创建出一个空白对象 函数的上下文（this）会指向这个对象 函数体内的语句会执行 函数会自动返回上下文对象，即使函数没有 return 语句"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-30T06:57:36.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-30T06:57:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"06 【函数（下）】\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-01-30T06:57:36.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1.用new操作符调用函数","slug":"_1-用new操作符调用函数","link":"#_1-用new操作符调用函数","children":[{"level":3,"title":"1.1 用new调用函数的四步走","slug":"_1-1-用new调用函数的四步走","link":"#_1-1-用new调用函数的四步走","children":[]},{"level":3,"title":"1.2 四步走详解","slug":"_1-2-四步走详解","link":"#_1-2-四步走详解","children":[]},{"level":3,"title":"1.3 上下文规则总结","slug":"_1-3-上下文规则总结","link":"#_1-3-上下文规则总结","children":[]}]},{"level":2,"title":"2.构造函数","slug":"_2-构造函数","link":"#_2-构造函数","children":[{"level":3,"title":"2.1 什么是构造函数","slug":"_2-1-什么是构造函数","link":"#_2-1-什么是构造函数","children":[]},{"level":3,"title":"2.2 如果不用new调用构造函数","slug":"_2-2-如果不用new调用构造函数","link":"#_2-2-如果不用new调用构造函数","children":[]},{"level":3,"title":"2.3 为对象添加方法","slug":"_2-3-为对象添加方法","link":"#_2-3-为对象添加方法","children":[]}]},{"level":2,"title":"3.类与实例","slug":"_3-类与实例","link":"#_3-类与实例","children":[{"level":3,"title":"3.1 基本介绍","slug":"_3-1-基本介绍","link":"#_3-1-基本介绍","children":[]},{"level":3,"title":"3.2 实例成员和静态成员","slug":"_3-2-实例成员和静态成员","link":"#_3-2-实例成员和静态成员","children":[]}]},{"level":2,"title":"4.原型(prototype)","slug":"_4-原型-prototype","link":"#_4-原型-prototype","children":[{"level":3,"title":"4.1 什么是prototype","slug":"_4-1-什么是prototype","link":"#_4-1-什么是prototype","children":[]},{"level":3,"title":"4.2 构造函数的prototype是实例的原型","slug":"_4-2-构造函数的prototype是实例的原型","link":"#_4-2-构造函数的prototype是实例的原型","children":[]},{"level":3,"title":"4.3 原型链查找","slug":"_4-3-原型链查找","link":"#_4-3-原型链查找","children":[]},{"level":3,"title":"4.4 hasOwnProperty","slug":"_4-4-hasownproperty","link":"#_4-4-hasownproperty","children":[]},{"level":3,"title":"4.5 in","slug":"_4-5-in","link":"#_4-5-in","children":[]}]},{"level":2,"title":"5.原型-添加属性和方法","slug":"_5-原型-添加属性和方法","link":"#_5-原型-添加属性和方法","children":[{"level":3,"title":"5.1 为什么要写在原型上","slug":"_5-1-为什么要写在原型上","link":"#_5-1-为什么要写在原型上","children":[]},{"level":3,"title":"5.2 方法要写到 prototype 上","slug":"_5-2-方法要写到-prototype-上","link":"#_5-2-方法要写到-prototype-上","children":[]}]},{"level":2,"title":"6.原型链","slug":"_6-原型链","link":"#_6-原型链","children":[]},{"level":2,"title":"7.包装类","slug":"_7-包装类","link":"#_7-包装类","children":[{"level":3,"title":"7.1 定义","slug":"_7-1-定义","link":"#_7-1-定义","children":[]},{"level":3,"title":"7.2 举例","slug":"_7-2-举例","link":"#_7-2-举例","children":[]},{"level":3,"title":"7.3 实例方法","slug":"_7-3-实例方法","link":"#_7-3-实例方法","children":[]},{"level":3,"title":"7.4 自定义方法","slug":"_7-4-自定义方法","link":"#_7-4-自定义方法","children":[]},{"level":3,"title":"7.5 总结","slug":"_7-5-总结","link":"#_7-5-总结","children":[]}]},{"level":2,"title":"8.垃圾回收","slug":"_8-垃圾回收","link":"#_8-垃圾回收","children":[]},{"level":2,"title":"9.高阶函数-回调函数","slug":"_9-高阶函数-回调函数","link":"#_9-高阶函数-回调函数","children":[]},{"level":2,"title":"10.高阶函数-闭包","slug":"_10-高阶函数-闭包","link":"#_10-高阶函数-闭包","children":[{"level":3,"title":"10.1 什么是闭包","slug":"_10-1-什么是闭包","link":"#_10-1-什么是闭包","children":[]},{"level":3,"title":"10.2 闭包常见写法","slug":"_10-2-闭包常见写法","link":"#_10-2-闭包常见写法","children":[]},{"level":3,"title":"10.3 闭包用途 - 记忆性","slug":"_10-3-闭包用途-记忆性","link":"#_10-3-闭包用途-记忆性","children":[]},{"level":3,"title":"11.3 使用闭包的注意点","slug":"_11-3-使用闭包的注意点","link":"#_11-3-使用闭包的注意点","children":[]},{"level":3,"title":"11.4 闭包面试题","slug":"_11-4-闭包面试题","link":"#_11-4-闭包面试题","children":[]}]},{"level":2,"title":"11.立即执行函数 IIFE","slug":"_11-立即执行函数-iife","link":"#_11-立即执行函数-iife","children":[{"level":3,"title":"11.1 形成 IIFE 的方法","slug":"_11-1-形成-iife-的方法","link":"#_11-1-形成-iife-的方法","children":[]},{"level":3,"title":"11.2 IIFE的作用1 - 为变量赋值","slug":"_11-2-iife的作用1-为变量赋值","link":"#_11-2-iife的作用1-为变量赋值","children":[]},{"level":3,"title":"11.3 IIFE的作用2 - 将全局变量变为局部变量","slug":"_11-3-iife的作用2-将全局变量变为局部变量","link":"#_11-3-iife的作用2-将全局变量变为局部变量","children":[]}]}],"git":{"createdTime":1675061856000,"updatedTime":1675061856000,"contributors":[{"name":"dselegent","email":"1799661558@qq.com","commits":1}]},"readingTime":{"minutes":21.29,"words":6388},"filePathRelative":"front_end/front_end_base/javascript/06.md","localizedDate":"2023年1月30日","excerpt":"<h1> 06 【函数（下）】</h1>\\n<h2> 1.用new操作符调用函数</h2>\\n<p>现在，我们学习一种新的函数调用方式：<code>new 函数()</code></p>\\n<p>你可能知道 new 操作符和 “面向对象” 息息相关，但是现在我们先不探讨它的 “面向对象” 意义，而是先把用 new 调用函数的执行步骤和它上下文弄清楚。</p>\\n<h3> 1.1 用new调用函数的四步走</h3>\\n<p>JS 规定，使用 new 操作符调用函数会进行 “四步走”：</p>\\n<ol>\\n<li>函数体内会自动创建出一个空白对象</li>\\n<li>函数的上下文（this）会指向这个对象</li>\\n<li>函数体内的语句会执行</li>\\n<li>函数会自动返回上下文对象，即使函数没有 return 语句</li>\\n</ol>","autoDesc":true}');export{e as data};
