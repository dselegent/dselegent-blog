const n=JSON.parse('{"key":"v-05972fa3","path":"/front_end/js_advanced/typescript/06.html","title":"8.泛型","lang":"zh-CN","frontmatter":{"description":"8.泛型 8.1 基本介绍 定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。 举个例子： function identity (arg: any): any{ \\treturn arg; } 上例中，identity 函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型 使用泛型： 为了解决上面的这些问题，我们使用泛型对上面的代码进行重构。和我们的定义不同，这里用了一个 类型 T，这个 T 是一个抽象类型，只有在调用的时候才确定它的值。 function identity&lt;T&gt;(arg: T): T { return arg; } 语法：在函数名称的后面添加 &lt;&gt;(尖括号)，尖括号中添加类型变量，比如此处的 Type 类型变量 Type，是一种特殊类型的变量，它处理类型而不是值 该类型变量相当于一个类型容器，能够捕获用户提供的类型(具体是什么类型由用户调用该函数时指定) 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型 类型变量 Type，可以是任意合法的变量名称 除了 T 之外，以下是常见泛型变量代表的意思： K（Key）：表示对象中的键类型； V（Value）：表示对象中的值类型； E（Element）：表示元素类型。 那么如何使用上边的函数呢？ 方式一（直接使用）： identity(10) 在调用泛型函数时，可以省略 &lt;类型&gt; 来简化泛型函数的调用 此时，TS 内部会采用一种叫做类型参数推断的机制，来根据传入的实参自动推断出类型变量 Type 的类型 比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型 推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读 说明：当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数 方式二（指定类型）： identity&lt;number&gt;(10) 语法：在函数名称的后面添加 &lt;&gt;(尖括号)，尖括号中指定具体的类型，比如，此处的 number 当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到 此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number 同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string 这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，实现了复用的同时保证了类型安全 其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数： function identity &lt;T, U&gt;(value: T, message: U) : T { console.log(message); return value; } console.log(identity&lt;Number, string&gt;(68, \\"Semlinker\\")); image-20220807134038387 使用泛型时，完全可以将泛型当成是一个普通的类去使用 类中同样可以使用泛型： class MyClass&lt;T&gt;{ prop: T; constructor(prop: T){ this.prop = prop; } }","head":[["meta",{"property":"og:url","content":"https://blog.dselegent.icu/front_end/js_advanced/typescript/06.html"}],["meta",{"property":"og:site_name","content":"dselegent-blog"}],["meta",{"property":"og:title","content":"8.泛型"}],["meta",{"property":"og:description","content":"8.泛型 8.1 基本介绍 定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。 举个例子： function identity (arg: any): any{ \\treturn arg; } 上例中，identity 函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型 使用泛型： 为了解决上面的这些问题，我们使用泛型对上面的代码进行重构。和我们的定义不同，这里用了一个 类型 T，这个 T 是一个抽象类型，只有在调用的时候才确定它的值。 function identity&lt;T&gt;(arg: T): T { return arg; } 语法：在函数名称的后面添加 &lt;&gt;(尖括号)，尖括号中添加类型变量，比如此处的 Type 类型变量 Type，是一种特殊类型的变量，它处理类型而不是值 该类型变量相当于一个类型容器，能够捕获用户提供的类型(具体是什么类型由用户调用该函数时指定) 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型 类型变量 Type，可以是任意合法的变量名称 除了 T 之外，以下是常见泛型变量代表的意思： K（Key）：表示对象中的键类型； V（Value）：表示对象中的值类型； E（Element）：表示元素类型。 那么如何使用上边的函数呢？ 方式一（直接使用）： identity(10) 在调用泛型函数时，可以省略 &lt;类型&gt; 来简化泛型函数的调用 此时，TS 内部会采用一种叫做类型参数推断的机制，来根据传入的实参自动推断出类型变量 Type 的类型 比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型 推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读 说明：当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数 方式二（指定类型）： identity&lt;number&gt;(10) 语法：在函数名称的后面添加 &lt;&gt;(尖括号)，尖括号中指定具体的类型，比如，此处的 number 当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到 此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number 同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string 这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，实现了复用的同时保证了类型安全 其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数： function identity &lt;T, U&gt;(value: T, message: U) : T { console.log(message); return value; } console.log(identity&lt;Number, string&gt;(68, \\"Semlinker\\")); image-20220807134038387 使用泛型时，完全可以将泛型当成是一个普通的类去使用 类中同样可以使用泛型： class MyClass&lt;T&gt;{ prop: T; constructor(prop: T){ this.prop = prop; } }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-30T06:57:36.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-30T06:57:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"8.泛型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-01-30T06:57:36.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"8.1 基本介绍","slug":"_8-1-基本介绍","link":"#_8-1-基本介绍","children":[]},{"level":2,"title":"8.2 泛型约束","slug":"_8-2-泛型约束","link":"#_8-2-泛型约束","children":[{"level":3,"title":"8.2.1 指定更加具体的类型","slug":"_8-2-1-指定更加具体的类型","link":"#_8-2-1-指定更加具体的类型","children":[]},{"level":3,"title":"8.2.2 添加约束","slug":"_8-2-2-添加约束","link":"#_8-2-2-添加约束","children":[]}]},{"level":2,"title":"8.3 泛型接口","slug":"_8-3-泛型接口","link":"#_8-3-泛型接口","children":[]}],"git":{"createdTime":1675061856000,"updatedTime":1675061856000,"contributors":[{"name":"dselegent","email":"1799661558@qq.com","commits":1}]},"readingTime":{"minutes":5.48,"words":1644},"filePathRelative":"front_end/js_advanced/typescript/06.md","localizedDate":"2023年1月30日","excerpt":"<h1> 8.泛型</h1>\\n<h2> 8.1 基本介绍</h2>\\n<p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</p>\\n<ul>\\n<li>\\n<p>举个例子：</p>\\n<ul>\\n<li>\\n<div class=\\"language-typescript line-numbers-mode\\" data-ext=\\"ts\\"><pre class=\\"language-typescript\\"><code><span class=\\"token keyword\\">function</span> <span class=\\"token function\\">identity</span> <span class=\\"token punctuation\\">(</span>arg<span class=\\"token operator\\">:</span> <span class=\\"token builtin\\">any</span><span class=\\"token punctuation\\">)</span><span class=\\"token operator\\">:</span> <span class=\\"token builtin\\">any</span><span class=\\"token punctuation\\">{</span>\\n\\t<span class=\\"token keyword\\">return</span> arg<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<p>上例中，identity 函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p>\\n</li>\\n<li>\\n<p>使用泛型：\\n为了解决上面的这些问题，我们<strong>使用泛型对上面的代码进行重构</strong>。和我们的定义不同，这里用了一个 类型 T，这个 <strong>T 是一个抽象类型，只有在调用的时候才确定它的值</strong>。</p>\\n</li>\\n<li>\\n<div class=\\"language-typescript line-numbers-mode\\" data-ext=\\"ts\\"><pre class=\\"language-typescript\\"><code><span class=\\"token keyword\\">function</span> <span class=\\"token generic-function\\"><span class=\\"token function\\">identity</span><span class=\\"token generic class-name\\"><span class=\\"token operator\\">&lt;</span><span class=\\"token constant\\">T</span><span class=\\"token operator\\">&gt;</span></span></span><span class=\\"token punctuation\\">(</span>arg<span class=\\"token operator\\">:</span> <span class=\\"token constant\\">T</span><span class=\\"token punctuation\\">)</span><span class=\\"token operator\\">:</span> <span class=\\"token constant\\">T</span> <span class=\\"token punctuation\\">{</span>\\n  <span class=\\"token keyword\\">return</span> arg<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<ol>\\n<li>语法：在函数名称的后面添加 <code>&lt;&gt;</code>(尖括号)，<strong>尖括号中添加类型变量</strong>，比如此处的 Type</li>\\n<li><strong>类型变量 Type，是一种特殊类型的变量，它处理类型而不是值</strong></li>\\n<li><strong>该类型变量相当于一个类型容器</strong>，能够捕获用户提供的类型(具体是什么类型由用户调用该函数时指定)</li>\\n<li>因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型</li>\\n<li>类型变量 Type，可以是任意合法的变量名称</li>\\n</ol>\\n</li>\\n<li>\\n<p>除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p>\\n<ul>\\n<li>K（Key）：表示对象中的键类型；</li>\\n<li>V（Value）：表示对象中的值类型；</li>\\n<li>E（Element）：表示元素类型。\\n<img src=\\"https://i0.hdslb.com/bfs/album/f0875f26e68c8533ab32d23a82bbae11e2232b50.png\\" alt=\\"image-20220807133943971\\" loading=\\"lazy\\"></li>\\n</ul>\\n</li>\\n<li>\\n<p>那么如何使用上边的函数呢？</p>\\n<ul>\\n<li>\\n<p>方式一（直接使用）：</p>\\n<ul>\\n<li>\\n<div class=\\"language-typescript line-numbers-mode\\" data-ext=\\"ts\\"><pre class=\\"language-typescript\\"><code><span class=\\"token function\\">identity</span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">10</span><span class=\\"token punctuation\\">)</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<ol>\\n<li>在调用泛型函数时，<strong>可以省略 <code>&lt;类型&gt;</code> 来简化泛型函数的调用</strong></li>\\n<li>此时，TS 内部会采用一种叫做<strong>类型参数推断</strong>的机制，来根据传入的实参自动推断出类型变量 Type 的类型</li>\\n<li>比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型</li>\\n</ol>\\n<blockquote>\\n<ul>\\n<li>推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读</li>\\n<li>说明：<strong>当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数</strong></li>\\n</ul>\\n</blockquote>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>方式二（指定类型）：</p>\\n<ul>\\n<li>\\n<div class=\\"language-typescript line-numbers-mode\\" data-ext=\\"ts\\"><pre class=\\"language-typescript\\"><code><span class=\\"token generic-function\\"><span class=\\"token function\\">identity</span><span class=\\"token generic class-name\\"><span class=\\"token operator\\">&lt;</span><span class=\\"token builtin\\">number</span><span class=\\"token operator\\">&gt;</span></span></span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">10</span><span class=\\"token punctuation\\">)</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<ol>\\n<li>\\n<p>语法：在函数名称的后面添加 <code>&lt;&gt;</code>(尖括号)，<strong>尖括号中指定具体的类型</strong>，比如，此处的 number</p>\\n</li>\\n<li>\\n<p>当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到</p>\\n</li>\\n<li>\\n<p>此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number</p>\\n<blockquote>\\n<ul>\\n<li>\\n<p>同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string</p>\\n</li>\\n<li>\\n<p>这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，<strong>实现了复用的同时保证了类型安全</strong></p>\\n</li>\\n</ul>\\n</blockquote>\\n</li>\\n</ol>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p>\\n<ul>\\n<li>\\n<div class=\\"language-typescript line-numbers-mode\\" data-ext=\\"ts\\"><pre class=\\"language-typescript\\"><code><span class=\\"token keyword\\">function</span> <span class=\\"token generic-function\\"><span class=\\"token function\\">identity</span> <span class=\\"token generic class-name\\"><span class=\\"token operator\\">&lt;</span><span class=\\"token constant\\">T</span><span class=\\"token punctuation\\">,</span> <span class=\\"token constant\\">U</span><span class=\\"token operator\\">&gt;</span></span></span><span class=\\"token punctuation\\">(</span>value<span class=\\"token operator\\">:</span> <span class=\\"token constant\\">T</span><span class=\\"token punctuation\\">,</span> message<span class=\\"token operator\\">:</span> <span class=\\"token constant\\">U</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">:</span> <span class=\\"token constant\\">T</span> <span class=\\"token punctuation\\">{</span>\\n  <span class=\\"token builtin\\">console</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span>message<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n  <span class=\\"token keyword\\">return</span> value<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n<span class=\\"token builtin\\">console</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span><span class=\\"token generic-function\\"><span class=\\"token function\\">identity</span><span class=\\"token generic class-name\\"><span class=\\"token operator\\">&lt;</span>Number<span class=\\"token punctuation\\">,</span> <span class=\\"token builtin\\">string</span><span class=\\"token operator\\">&gt;</span></span></span><span class=\\"token punctuation\\">(</span><span class=\\"token number\\">68</span><span class=\\"token punctuation\\">,</span> <span class=\\"token string\\">\\"Semlinker\\"</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><figure><img src=\\"https://i0.hdslb.com/bfs/album/1d646c21096038011017b93333d8fecd97639e4f.png\\" alt=\\"image-20220807134038387\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>image-20220807134038387</figcaption></figure>\\n</li>\\n<li>\\n<p>使用泛型时，完全可以将泛型当成是一个普通的类去使用</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>类中同样可以使用泛型：</p>\\n<ul>\\n<li>\\n<div class=\\"language-typescript line-numbers-mode\\" data-ext=\\"ts\\"><pre class=\\"language-typescript\\"><code><span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">MyClass<span class=\\"token operator\\">&lt;</span><span class=\\"token constant\\">T</span><span class=\\"token operator\\">&gt;</span></span><span class=\\"token punctuation\\">{</span>\\n    prop<span class=\\"token operator\\">:</span> <span class=\\"token constant\\">T</span><span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token function\\">constructor</span><span class=\\"token punctuation\\">(</span>prop<span class=\\"token operator\\">:</span> <span class=\\"token constant\\">T</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token keyword\\">this</span><span class=\\"token punctuation\\">.</span>prop <span class=\\"token operator\\">=</span> prop<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{n as data};
