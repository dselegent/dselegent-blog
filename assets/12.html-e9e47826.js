const e=JSON.parse('{"key":"v-699514b8","path":"/front_end/front_end_framework/vue3/12.html","title":"12 【其它组合式API】","lang":"zh-CN","frontmatter":{"description":"12 【其它组合式API】 ref、unref、toRef、toRefs、isRef、customRef、shallowRef、triggerRef refs api中的重点为：ref、toRefs、shallowRef、customRef，其次是 isRef 等。 1.toRef 与 toRefs 1.1 toRef 作用：可以用来为源响应式对象上的某个 property 新创建一个 ref。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。 语法 (源对象 , 源对象属性)````const name = toRef(person,\'name\')``` 应用: 源响应式对象(toRef的第一个参数) 上的某个 property 新创建一个 ref toRef示例 const state = reactive({ foo: 1, bar: 2 }) const fooRef = toRef(state, \'foo\') // 更改该 ref 会更新源属性 fooRef.value++ console.log(state.foo) // 2 // 更改源属性也会更新该 ref state.foo++ console.log(fooRef.value) // 3 请注意，这不同于： const fooRef = ref(state.foo) 上面这个 ref 不会和 state.foo 保持同步，因为这个 ref() 接收到的是一个纯数值。 toRef() 这个函数在你想把一个 prop 的 ref 传递给一个组合式函数时会很有用： &lt;script setup&gt; import { toRef } from \'vue\' const props = defineProps(/* ... */) // 将 `props.foo` 转换为 ref，然后传入 // 一个组合式函数 useSomeFeature(toRef(props, \'foo\')) &lt;/script&gt; 当 toRef 与组件 props 结合使用时，关于禁止对 props 做出更改的限制依然有效。尝试将新的值传递给 ref 等效于尝试直接更改 props，这是不允许的。在这种场景下，你可能可以考虑使用带有 get 和 set 的 computed 替代。详情请见在组件上使用 v-model 指南。 即使源属性当前不存在，toRef() 也会返回一个可用的 ref。这让它在处理可选 props 的时候格外实用，相比之下 toRefs 就不会为可选 props 创建对应的 refs。","head":[["meta",{"property":"og:url","content":"https://blog.dselegent.cf/front_end/front_end_framework/vue3/12.html"}],["meta",{"property":"og:site_name","content":"dselegent-blog"}],["meta",{"property":"og:title","content":"12 【其它组合式API】"}],["meta",{"property":"og:description","content":"12 【其它组合式API】 ref、unref、toRef、toRefs、isRef、customRef、shallowRef、triggerRef refs api中的重点为：ref、toRefs、shallowRef、customRef，其次是 isRef 等。 1.toRef 与 toRefs 1.1 toRef 作用：可以用来为源响应式对象上的某个 property 新创建一个 ref。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。 语法 (源对象 , 源对象属性)````const name = toRef(person,\'name\')``` 应用: 源响应式对象(toRef的第一个参数) 上的某个 property 新创建一个 ref toRef示例 const state = reactive({ foo: 1, bar: 2 }) const fooRef = toRef(state, \'foo\') // 更改该 ref 会更新源属性 fooRef.value++ console.log(state.foo) // 2 // 更改源属性也会更新该 ref state.foo++ console.log(fooRef.value) // 3 请注意，这不同于： const fooRef = ref(state.foo) 上面这个 ref 不会和 state.foo 保持同步，因为这个 ref() 接收到的是一个纯数值。 toRef() 这个函数在你想把一个 prop 的 ref 传递给一个组合式函数时会很有用： &lt;script setup&gt; import { toRef } from \'vue\' const props = defineProps(/* ... */) // 将 `props.foo` 转换为 ref，然后传入 // 一个组合式函数 useSomeFeature(toRef(props, \'foo\')) &lt;/script&gt; 当 toRef 与组件 props 结合使用时，关于禁止对 props 做出更改的限制依然有效。尝试将新的值传递给 ref 等效于尝试直接更改 props，这是不允许的。在这种场景下，你可能可以考虑使用带有 get 和 set 的 computed 替代。详情请见在组件上使用 v-model 指南。 即使源属性当前不存在，toRef() 也会返回一个可用的 ref。这让它在处理可选 props 的时候格外实用，相比之下 toRefs 就不会为可选 props 创建对应的 refs。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-01-30T06:57:36.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-30T06:57:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"12 【其它组合式API】\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-01-30T06:57:36.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"1.toRef 与 toRefs","slug":"_1-toref-与-torefs","link":"#_1-toref-与-torefs","children":[{"level":3,"title":"1.1 toRef","slug":"_1-1-toref","link":"#_1-1-toref","children":[]},{"level":3,"title":"1.2 toRefs","slug":"_1-2-torefs","link":"#_1-2-torefs","children":[]},{"level":3,"title":"1.3 总结","slug":"_1-3-总结","link":"#_1-3-总结","children":[]}]},{"level":2,"title":"2.shallowReactive 与 shallowRef","slug":"_2-shallowreactive-与-shallowref","link":"#_2-shallowreactive-与-shallowref","children":[]},{"level":2,"title":"3.readonly 与 shallowReadonly","slug":"_3-readonly-与-shallowreadonly","link":"#_3-readonly-与-shallowreadonly","children":[]},{"level":2,"title":"4.toRaw 与 markRaw","slug":"_4-toraw-与-markraw","link":"#_4-toraw-与-markraw","children":[]},{"level":2,"title":"5.customRef","slug":"_5-customref","link":"#_5-customref","children":[]},{"level":2,"title":"6.unref","slug":"_6-unref","link":"#_6-unref","children":[]},{"level":2,"title":"7.triggerRef","slug":"_7-triggerref","link":"#_7-triggerref","children":[]},{"level":2,"title":"8.响应式数据的判断","slug":"_8-响应式数据的判断","link":"#_8-响应式数据的判断","children":[]}],"git":{"createdTime":1675061856000,"updatedTime":1675061856000,"contributors":[{"name":"dselegent","email":"1799661558@qq.com","commits":1}]},"readingTime":{"minutes":11.91,"words":3573},"filePathRelative":"front_end/front_end_framework/vue3/12.md","localizedDate":"2023年1月30日","excerpt":"<h1> 12 【其它组合式API】</h1>\\n<p>ref、unref、toRef、toRefs、isRef、customRef、shallowRef、triggerRef</p>\\n<p>refs api中的重点为：ref、toRefs、shallowRef、customRef，其次是 isRef 等。</p>\\n<h2> 1.toRef 与 toRefs</h2>\\n<h3> 1.1 toRef</h3>\\n<ul>\\n<li>\\n<p>作用：可以用来为源响应式对象上的某个 property 新创建一个 ref。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。</p>\\n</li>\\n<li>\\n<p>语法 (源对象 , 源对象属性)````const name = toRef(person,\'name\')```</p>\\n</li>\\n<li>\\n<p>应用: 源响应式对象(toRef的第一个参数) 上的某个 property 新创建一个 ref</p>\\n</li>\\n<li>\\n<p><strong>toRef示例</strong></p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token keyword\\">const</span> state <span class=\\"token operator\\">=</span> <span class=\\"token function\\">reactive</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">{</span>\\n  <span class=\\"token literal-property property\\">foo</span><span class=\\"token operator\\">:</span> <span class=\\"token number\\">1</span><span class=\\"token punctuation\\">,</span>\\n  <span class=\\"token literal-property property\\">bar</span><span class=\\"token operator\\">:</span> <span class=\\"token number\\">2</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">)</span>\\n\\n<span class=\\"token keyword\\">const</span> fooRef <span class=\\"token operator\\">=</span> <span class=\\"token function\\">toRef</span><span class=\\"token punctuation\\">(</span>state<span class=\\"token punctuation\\">,</span> <span class=\\"token string\\">\'foo\'</span><span class=\\"token punctuation\\">)</span>\\n\\n<span class=\\"token comment\\">// 更改该 ref 会更新源属性</span>\\nfooRef<span class=\\"token punctuation\\">.</span>value<span class=\\"token operator\\">++</span>\\nconsole<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span>state<span class=\\"token punctuation\\">.</span>foo<span class=\\"token punctuation\\">)</span> <span class=\\"token comment\\">// 2</span>\\n\\n<span class=\\"token comment\\">// 更改源属性也会更新该 ref</span>\\nstate<span class=\\"token punctuation\\">.</span>foo<span class=\\"token operator\\">++</span>\\nconsole<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">log</span><span class=\\"token punctuation\\">(</span>fooRef<span class=\\"token punctuation\\">.</span>value<span class=\\"token punctuation\\">)</span> <span class=\\"token comment\\">// 3</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>请注意，这不同于：</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token keyword\\">const</span> fooRef <span class=\\"token operator\\">=</span> <span class=\\"token function\\">ref</span><span class=\\"token punctuation\\">(</span>state<span class=\\"token punctuation\\">.</span>foo<span class=\\"token punctuation\\">)</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div></div></div><p>上面这个 ref <strong>不会</strong>和 <code>state.foo</code> 保持同步，因为这个 <code>ref()</code> 接收到的是一个纯数值。</p>\\n<p><code>toRef()</code> 这个函数在你想把一个 prop 的 ref 传递给一个组合式函数时会很有用：</p>\\n<div class=\\"language-javascript line-numbers-mode\\" data-ext=\\"js\\"><pre class=\\"language-javascript\\"><code><span class=\\"token operator\\">&lt;</span>script setup<span class=\\"token operator\\">&gt;</span>\\n<span class=\\"token keyword\\">import</span> <span class=\\"token punctuation\\">{</span> toRef <span class=\\"token punctuation\\">}</span> <span class=\\"token keyword\\">from</span> <span class=\\"token string\\">\'vue\'</span>\\n\\n<span class=\\"token keyword\\">const</span> props <span class=\\"token operator\\">=</span> <span class=\\"token function\\">defineProps</span><span class=\\"token punctuation\\">(</span><span class=\\"token comment\\">/* ... */</span><span class=\\"token punctuation\\">)</span>\\n\\n<span class=\\"token comment\\">// 将 `props.foo` 转换为 ref，然后传入</span>\\n<span class=\\"token comment\\">// 一个组合式函数</span>\\n<span class=\\"token function\\">useSomeFeature</span><span class=\\"token punctuation\\">(</span><span class=\\"token function\\">toRef</span><span class=\\"token punctuation\\">(</span>props<span class=\\"token punctuation\\">,</span> <span class=\\"token string\\">\'foo\'</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span>\\n<span class=\\"token operator\\">&lt;</span><span class=\\"token operator\\">/</span>script<span class=\\"token operator\\">&gt;</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div><p>当 <code>toRef</code> 与组件 props 结合使用时，关于禁止对 props 做出更改的限制依然有效。尝试将新的值传递给 ref 等效于尝试直接更改 props，这是不允许的。在这种场景下，你可能可以考虑使用带有 <code>get</code> 和 <code>set</code> 的 <a href=\\"https://staging-cn.vuejs.org/api/reactivity-core.html#computed\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>computed</code></a> 替代。详情请见<a href=\\"https://staging-cn.vuejs.org/guide/components/events.html#usage-with-v-model\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">在组件上使用 <code>v-model</code></a> 指南。</p>\\n<p>即使源属性当前不存在，<code>toRef()</code> 也会返回一个可用的 ref。这让它在处理可选 props 的时候格外实用，相比之下 <a href=\\"https://staging-cn.vuejs.org/api/reactivity-utilities.html#torefs\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>toRefs</code></a> 就不会为可选 props 创建对应的 refs。</p>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
